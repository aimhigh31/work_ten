import React, { useState, useCallback, useMemo, useReducer, memo, useEffect, useRef } from 'react';
import { createClient } from '@supabase/supabase-js';
import { useSession } from 'next-auth/react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Typography,
  Box,
  Tabs,
  Tab,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Stack,
  Avatar,
  Chip,
  Grid,
  Checkbox,
  Paper,
  IconButton,
  ToggleButtonGroup,
  ToggleButton,
  SvgIcon,
  Alert,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Pagination
} from '@mui/material';
import { TaskTableData, TaskStatus, SoftwareStatus } from '../types/software';
import { useOptimizedInput } from '../hooks/useDebounce';
// import { usePerformanceMonitor } from '../utils/performance';

// Supabase hook
import { useSupabaseSoftware, SoftwareData } from '../hooks/useSupabaseSoftware';

// Supabase ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÑ§Ï†ï
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
const supabase = createClient(supabaseUrl, supabaseKey);

// GROUP015 hook
import { useGroup015 } from '../hooks/useGroup015';

// GROUP017 hook
import { useGroup017 } from '../hooks/useGroup017';

// GROUP002 hook
import { useGroup002 } from '../hooks/useGroup002';

// GROUP016 hook
import { useGroup016 } from '../hooks/useGroup016';

// Users hook
import { useSupabaseUsers } from '../hooks/useSupabaseUsers';

// Software User hook
import { useSupabaseSoftwareUser, UserHistory } from '../hooks/useSupabaseSoftwareUser';
// Software History hook
import { useSupabaseSoftwareHistory, PurchaseHistory } from '../hooks/useSupabaseSoftwareHistory';
// Feedback hook
import { useSupabaseFeedback } from '../hooks/useSupabaseFeedback';
import { PAGE_IDENTIFIERS } from '../types/feedback';

// Icons
import { TableDocument, Category, Element } from '@wandersonalwes/iconsax-react';

// ÏÉÅÌÉú Í¥ÄÎ¶¨Î•º ÏúÑÌïú reducer
interface EditSoftwareState {
  softwareName: string;
  description: string;
  softwareCategory: string;
  spec: string;
  status: TaskStatus;
  startDate: string;
  completedDate: string;
  currentUser: string;
  assignee: string;
  team: string;
  solutionProvider: string;
  userCount: number;
  licenseType: string;
  licenseKey: string;
  registrationDate: string;
  code: string;
}

type EditSoftwareAction =
  | { type: 'SET_FIELD'; field: keyof EditSoftwareState; value: string | number }
  | { type: 'SET_SOFTWARE'; software: TaskTableData }
  | { type: 'RESET' }
  | { type: 'INIT_NEW_SOFTWARE'; code: string; registrationDate: string };

const editSoftwareReducer = (state: EditSoftwareState, action: EditSoftwareAction): EditSoftwareState => {
  switch (action.type) {
    case 'SET_FIELD':
      return { ...state, [action.field]: action.value };
    case 'SET_SOFTWARE':
      const result = {
        softwareName: (action.software as any).softwareName || action.software.workContent || '',
        description: (action.software as any).description || '',
        softwareCategory: (action.software as any).softwareCategory || '',
        spec: (action.software as any).spec || '',
        status: action.software.status as TaskStatus,
        startDate: action.software.startDate || '',
        completedDate: action.software.completedDate || '',
        currentUser: (action.software as any).currentUser || '',
        assignee: action.software.assignee,
        team: (action.software as any).team || '',
        solutionProvider: (action.software as any).solutionProvider || '',
        userCount: (action.software as any).userCount || 0,
        licenseType: (action.software as any).licenseType || '',
        licenseKey: (action.software as any).licenseKey || '',
        registrationDate: action.software.registrationDate || '',
        code: action.software.code
      };

      console.log('üîÑ SET_SOFTWARE Ïï°ÏÖò Ïã§Ìñâ:', {
        taskId: action.software.id,
        softwareName: result.softwareName,
        code: result.code,
        status: result.status,
        assignee: result.assignee,
        currentUser: result.currentUser,
        rawData: action.software
      });

      return result;
    case 'INIT_NEW_SOFTWARE':
      return {
        softwareName: '',
        description: '',
        softwareCategory: '',
        spec: '',
        status: 'ÎåÄÍ∏∞',
        startDate: '',
        completedDate: '',
        currentUser: '',
        assignee: '',
        team: '',
        solutionProvider: '',
        userCount: 0,
        licenseType: '',
        licenseKey: '',
        registrationDate: action.registrationDate,
        code: action.code
      };
    case 'RESET':
      return {
        softwareName: '',
        description: '',
        softwareCategory: '',
        spec: '',
        status: 'ÎåÄÍ∏∞',
        startDate: '',
        completedDate: '',
        currentUser: '',
        assignee: '',
        team: '',
        solutionProvider: '',
        userCount: 0,
        licenseType: '',
        licenseKey: '',
        registrationDate: '',
        code: ''
      };
    default:
      return state;
  }
};

// Í∏∞Î°ù ÌÉ≠ Ïª¥Ìè¨ÎÑåÌä∏
const RecordTab = memo(
  ({
    comments,
    newComment,
    onNewCommentChange,
    onAddComment,
    editingCommentId,
    editingCommentText,
    onEditComment,
    onSaveEditComment,
    onCancelEditComment,
    onDeleteComment,
    onEditCommentTextChange,
    currentUserName,
    currentUserAvatar,
    currentUserRole,
    currentUserDepartment
  }: {
    comments: Array<{
      id: string;
      author: string;
      content: string;
      timestamp: string;
      avatar?: string;
      department?: string;
      position?: string;
      role?: string;
    }>;
    newComment: string;
    onNewCommentChange: (value: string) => void;
    onAddComment: () => void;
    editingCommentId: string | null;
    editingCommentText: string;
    onEditComment: (id: string, content: string) => void;
    onSaveEditComment: () => void;
    onCancelEditComment: () => void;
    onDeleteComment: (id: string) => void;
    onEditCommentTextChange: (value: string) => void;
    currentUserName?: string;
    currentUserAvatar?: string;
    currentUserRole?: string;
    currentUserDepartment?: string;
  }) => {
    const [page, setPage] = useState(1);
    const itemsPerPage = 5;

    const handleCommentKeyPress = useCallback(
      (e: React.KeyboardEvent) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          onAddComment();
        }
      },
      [onAddComment]
    );

    const handlePageChange = useCallback((event: React.ChangeEvent<unknown>, value: number) => {
      setPage(value);
    }, []);

    // ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò Í≥ÑÏÇ∞
    const totalPages = Math.ceil(comments.length / itemsPerPage);
    const startIndex = (page - 1) * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    const paginatedComments = comments.slice(startIndex, endIndex);

    return (
      <Box sx={{ height: '720px', display: 'flex', flexDirection: 'column', px: 5, pt: 3, position: 'relative', overflow: 'hidden' }}>
        {/* ÏÉà Í∏∞Î°ù Îì±Î°ù - Ï¢åÏö∞ Î∞∞Ïπò */}
        <Box sx={{ display: 'flex', gap: 2, alignItems: 'flex-start', mb: 3 }}>
          <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 0.5 }}>
            <Avatar src={currentUserAvatar} sx={{ width: 35, height: 35 }}>
              {currentUserName?.charAt(0) || 'U'}
            </Avatar>
            <Box sx={{ display: 'flex', gap: 0.5, alignItems: 'center' }}>
              <Typography variant="caption" sx={{ fontWeight: 600, fontSize: '11px' }}>
                {currentUserName || 'ÏÇ¨Ïö©Ïûê'}
              </Typography>
              {currentUserRole && (
                <Typography variant="caption" sx={{ color: 'text.secondary', fontSize: '10px' }}>
                  {currentUserRole}
                </Typography>
              )}
            </Box>
            {currentUserDepartment && (
              <Typography variant="caption" sx={{ color: 'text.secondary', fontSize: '10px' }}>
                {currentUserDepartment}
              </Typography>
            )}
          </Box>
          <TextField
            multiline
            rows={3}
            placeholder="ÏÉà Í∏∞Î°ùÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî..."
            value={newComment}
            onChange={(e) => onNewCommentChange(e.target.value)}
            onKeyPress={handleCommentKeyPress}
            variant="outlined"
            size="small"
            InputLabelProps={{ shrink: true }}
            sx={{ flex: 1, maxWidth: '95%' }}
          />
          <Button
            variant="contained"
            onClick={onAddComment}
            disabled={!newComment.trim()}
            sx={{ minWidth: '80px', height: '40px', mt: 0.5 }}
          >
            Îì±Î°ù
          </Button>
        </Box>

        {/* Í∏∞Î°ù Ìï≠Î™©Îì§ */}
        <Box
          sx={{
            flex: 1,
            maxHeight: '500px',
            overflowY: 'auto',
            minHeight: 0,
            pb: 0,
            '&::-webkit-scrollbar': {
              width: '8px'
            },
            '&::-webkit-scrollbar-track': {
              background: 'transparent'
            },
            '&::-webkit-scrollbar-thumb': {
              background: '#c1c1c1',
              borderRadius: '4px',
              '&:hover': {
                background: '#a8a8a8'
              }
            }
          }}
        >
          <Stack spacing={2} sx={{ px: 3 }}>
            {paginatedComments.map((comment) => (
              <Paper
                key={`comment-${comment.id}`}
                variant="outlined"
                sx={{
                  p: 2,
                  borderRadius: 2,
                  border: '1px solid',
                  borderColor: 'grey.300',
                  backgroundColor: 'background.paper',
                  transition: 'all 0.2s ease-in-out',
                  '&:hover': {
                    borderColor: 'primary.light',
                    boxShadow: 1
                  }
                }}
              >
                <Stack direction="row" spacing={2} alignItems="flex-start">
                  {/* ÏÇ¨Ïö©Ïûê ÏïÑÎ∞îÌÉÄ */}
                  <Avatar src={comment.avatar} sx={{ width: 30, height: 30 }}>
                    {comment.author.charAt(0)}
                  </Avatar>

                  {/* Í∏∞Î°ù ÎÇ¥Ïö© ÏòÅÏó≠ */}
                  <Box sx={{ flexGrow: 1 }}>
                    {/* ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Î∞è ÏãúÍ∞Ñ */}
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
                      <Typography variant="subtitle2" sx={{ fontWeight: 600, fontSize: '13px' }}>
                        {comment.author}
                      </Typography>
                      {comment.role && (
                        <Typography variant="caption" sx={{ color: 'text.secondary', fontSize: '11px' }}>
                          {comment.role}
                        </Typography>
                      )}
                      {comment.department && (
                        <Typography variant="caption" sx={{ color: 'text.secondary', fontSize: '11px' }}>
                          ‚Ä¢ {comment.department}
                        </Typography>
                      )}
                      <Typography variant="caption" color="text.secondary" sx={{ fontSize: '11px', ml: 'auto' }}>
                        {comment.timestamp}
                      </Typography>
                    </Box>

                    {/* Í∏∞Î°ù ÎÇ¥Ïö© */}
                    {editingCommentId === comment.id ? (
                      <TextField
                        fullWidth
                        multiline
                        rows={3}
                        value={editingCommentText}
                        onChange={(e) => onEditCommentTextChange(e.target.value)}
                        onKeyPress={(e) => {
                          if (e.key === 'Enter' && e.ctrlKey) onSaveEditComment();
                          if (e.key === 'Escape') onCancelEditComment();
                        }}
                        variant="outlined"
                        size="small"
                        autoFocus
                        InputLabelProps={{ shrink: true }}
                      />
                    ) : (
                      <Typography
                        variant="body2"
                        sx={{
                          whiteSpace: 'pre-wrap',
                          cursor: 'pointer',
                          '&:hover': {
                            backgroundColor: 'action.hover',
                            borderRadius: 1,
                            px: 1
                          }
                        }}
                        onClick={() => onEditComment(comment.id, comment.content)}
                      >
                        {comment.content}
                      </Typography>
                    )}
                  </Box>

                  {/* Ïï°ÏÖò Î≤ÑÌäºÎì§ */}
                  <Stack direction="row" spacing={1}>
                    {editingCommentId === comment.id ? (
                      <>
                        <IconButton size="small" onClick={onSaveEditComment} color="success" sx={{ p: 0.5 }} title="Ï†ÄÏû• (Ctrl+Enter)">
                          <Typography fontSize="14px">‚úì</Typography>
                        </IconButton>
                        <IconButton size="small" onClick={onCancelEditComment} color="error" sx={{ p: 0.5 }} title="Ï∑®ÏÜå (Escape)">
                          <Typography fontSize="14px">‚úï</Typography>
                        </IconButton>
                      </>
                    ) : (
                      <>
                        <IconButton
                          size="small"
                          onClick={() => onEditComment(comment.id, comment.content)}
                          color="primary"
                          sx={{ p: 0.5 }}
                          title="ÏàòÏ†ï"
                        >
                          <Typography fontSize="14px">‚úèÔ∏è</Typography>
                        </IconButton>
                        <IconButton size="small" onClick={() => onDeleteComment(comment.id)} color="error" sx={{ p: 0.5 }} title="ÏÇ≠Ï†ú">
                          <Typography fontSize="14px">üóëÔ∏è</Typography>
                        </IconButton>
                      </>
                    )}
                  </Stack>
                </Stack>
              </Paper>
            ))}
          </Stack>

          {/* Îπà ÏÉÅÌÉú Î©îÏãúÏßÄ */}
          {comments.length === 0 && (
            <Paper
              variant="outlined"
              sx={{
                p: 4,
                textAlign: 'center',
                borderStyle: 'dashed',
                borderColor: 'grey.300',
                backgroundColor: 'grey.50',
                mt: 2
              }}
            >
              <Typography variant="body2" color="text.secondary">
                üìù ÏïÑÏßÅ Í∏∞Î°ùÏù¥ ÏóÜÏäµÎãàÎã§.
                <br />
                ÏúÑÏùò ÏûÖÎ†• ÌïÑÎìúÏóêÏÑú ÏÉà Í∏∞Î°ùÏùÑ Îì±Î°ùÌï¥Î≥¥ÏÑ∏Ïöî.
              </Typography>
            </Paper>
          )}
        </Box>

        {/* ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò - ÌïòÎã® Í≥†Ï†ï */}
        <Box
          sx={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            mt: 'auto',
            pt: 3,
            pb: 3,
            px: 4,
            borderTop: '1px solid',
            borderColor: 'divider',
            backgroundColor: 'background.paper',
            position: 'absolute',
            bottom: '0px',
            left: '40px',
            right: '40px'
          }}
        >
          <Typography variant="body2" color="text.secondary">
            {comments.length > 0
              ? `${startIndex + 1}-${Math.min(endIndex, comments.length)} of ${comments.length}`
              : '0-0 of 0'}
          </Typography>
          {comments.length > 0 && (
            <Pagination
              count={totalPages}
              page={page}
              onChange={handlePageChange}
              color="primary"
              size="small"
              showFirstButton
              showLastButton
              sx={{
                '& .MuiPaginationItem-root': {
                  fontSize: '0.875rem',
                  minWidth: '32px',
                  height: '32px',
                  borderRadius: '4px'
                },
                '& .MuiPaginationItem-page.Mui-selected': {
                  backgroundColor: 'primary.main',
                  color: 'white !important',
                  borderRadius: '4px',
                  fontWeight: 500,
                  '&:hover': {
                    backgroundColor: 'primary.dark',
                    color: 'white !important'
                  }
                },
                '& .MuiPaginationItem-page': {
                  borderRadius: '4px',
                  '&:hover': {
                    backgroundColor: 'grey.100'
                  }
                }
              }}
            />
          )}
        </Box>
      </Box>
    );
  }
);

RecordTab.displayName = 'RecordTab';

// Í∞úÏöî ÌÉ≠ Ïª¥Ìè¨ÎÑåÌä∏
const OverviewTab = memo(
  ({
    softwareState,
    onFieldChange,
    users,
    usersLoading,
    usersError,
    statusOptions,
    statusColors,
    softwareCategories,
    licenseTypes,
    categoriesLoading,
    categoriesError,
    statusLoading,
    statusError,
    masterStatusOptions,
    licenseLoading,
    licenseError,
    masterLicenseTypes
  }: {
    softwareState: EditSoftwareState;
    onFieldChange: (field: keyof EditSoftwareState, value: string | number) => void;
    users: any[];
    usersLoading: boolean;
    usersError: string | null;
    statusOptions: SoftwareStatus[];
    statusColors: Record<SoftwareStatus, any>;
    softwareCategories: string[];
    licenseTypes: string[];
    categoriesLoading: boolean;
    categoriesError: string | null;
    statusLoading: boolean;
    statusError: string | null;
    masterStatusOptions: string[];
    licenseLoading: boolean;
    licenseError: string | null;
    masterLicenseTypes: string[];
  }) => {
    // TextField ÏßÅÏ†ë Ï∞∏Ï°∞Î•º ÏúÑÌïú ref
    const workContentRef = useRef<HTMLInputElement>(null);
    const descriptionRef = useRef<HTMLTextAreaElement>(null);

    // ÌÖçÏä§Ìä∏ ÌïÑÎìúÏö© ÏµúÏ†ÅÌôîÎêú ÏûÖÎ†• Í¥ÄÎ¶¨
    const softwareNameInput = useOptimizedInput(softwareState.softwareName, 150);
    const descriptionInput = useOptimizedInput(softwareState.description, 200);

    // Î¨¥Ìïú Î£®ÌîÑ Î∞©ÏßÄÎ•º ÏúÑÌïú ref
    const isUpdatingRef = useRef(false);

    // debounced Í∞íÏù¥ Î≥ÄÍ≤ΩÎê† ÎïåÎßàÎã§ ÏÉÅÏúÑ Ïª¥Ìè¨ÎÑåÌä∏Ïóê ÏïåÎ¶º (onFieldChange ÏùòÏ°¥ÏÑ± Ï†úÍ±∞Î°ú ÏµúÏ†ÅÌôî)
    useEffect(() => {
      if (!isUpdatingRef.current && softwareNameInput.debouncedValue !== softwareState.softwareName) {
        onFieldChange('softwareName', softwareNameInput.debouncedValue);
      }
    }, [softwareNameInput.debouncedValue, softwareState.softwareName]); // onFieldChange Ï†úÍ±∞

    useEffect(() => {
      if (!isUpdatingRef.current && descriptionInput.debouncedValue !== softwareState.description) {
        onFieldChange('description', descriptionInput.debouncedValue);
      }
    }, [descriptionInput.debouncedValue, softwareState.description]); // onFieldChange Ï†úÍ±∞

    // Ïô∏Î∂ÄÏóêÏÑú ÏÉÅÌÉúÍ∞Ä Î≥ÄÍ≤ΩÎê† Îïå ÏûÖÎ†• Í∞í ÎèôÍ∏∞Ìôî (reset Ìï®Ïàò ÏùòÏ°¥ÏÑ± Ï†úÍ±∞Î°ú ÏµúÏ†ÅÌôî)
    useEffect(() => {
      if (softwareState.softwareName !== softwareNameInput.inputValue && softwareState.softwareName !== softwareNameInput.debouncedValue) {
        isUpdatingRef.current = true;
        softwareNameInput.reset(softwareState.softwareName);
        setTimeout(() => {
          isUpdatingRef.current = false;
        }, 0);
      }
    }, [softwareState.softwareName, softwareNameInput.inputValue, softwareNameInput.debouncedValue]); // reset Ï†úÍ±∞

    useEffect(() => {
      if (softwareState.description !== descriptionInput.inputValue && softwareState.description !== descriptionInput.debouncedValue) {
        isUpdatingRef.current = true;
        descriptionInput.reset(softwareState.description);
        setTimeout(() => {
          isUpdatingRef.current = false;
        }, 0);
      }
    }, [softwareState.description, descriptionInput.inputValue, descriptionInput.debouncedValue]); // reset Ï†úÍ±∞

    const handleFieldChange = useCallback(
      (field: keyof EditSoftwareState) =>
        (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement> | { target: { value: string | number } }) => {
          const value = e.target.value;
          if (field === 'userCount') {
            onFieldChange(field, Number(value));
          } else {
            onFieldChange(field, String(value));
          }
        },
      [onFieldChange]
    );

    // ÌòÑÏû¨ ÏûÖÎ†• Í∞íÎì§ÏùÑ Î∞òÌôòÌïòÎäî Ìï®Ïàò (ÏùòÏ°¥ÏÑ± Î∞∞Ïó¥ Ï†úÍ±∞Î°ú ÏµúÏ†ÅÌôî)
    const getCurrentValues = useCallback(() => {
      return {
        softwareName: workContentRef.current?.value || softwareNameInput.inputValue,
        description: descriptionRef.current?.value || descriptionInput.inputValue
      };
    }, []); // ÏùòÏ°¥ÏÑ± Î∞∞Ïó¥ Ï†úÍ±∞ - refÎ•º ÌÜµÌï¥ ÏµúÏã† Í∞í Ï†ëÍ∑º

    // Ïª¥Ìè¨ÎÑåÌä∏Í∞Ä ÎßàÏö¥Ìä∏Îê† Îïå getCurrentValues Ìï®ÏàòÎ•º Ï†ÑÏó≠ÏóêÏÑú Ï†ëÍ∑º Í∞ÄÎä•ÌïòÎèÑÎ°ù ÏÑ§Ï†ï
    useEffect(() => {
      (window as any).getOverviewTabCurrentValues = getCurrentValues;
      return () => {
        delete (window as any).getOverviewTabCurrentValues;
      };
    }, []); // ÏùòÏ°¥ÏÑ± Î∞∞Ïó¥ÏóêÏÑú getCurrentValues Ï†úÍ±∞

    return (
      <Box sx={{ height: '650px', overflowY: 'auto', pr: 1, px: 3, py: 3 }}>
        <Stack spacing={3}>
          {/* ÏÜåÌîÑÌä∏Ïõ®Ïñ¥Î™Ö - Ï†ÑÏ≤¥ ÎÑàÎπÑ */}
          <TextField
            fullWidth
            label={
              <span>
                ÏÜåÌîÑÌä∏Ïõ®Ïñ¥Î™Ö <span style={{ color: 'red' }}>*</span>
              </span>
            }
            value={softwareNameInput.inputValue}
            onChange={(e) => softwareNameInput.handleChange(e.target.value)}
            variant="outlined"
            inputRef={workContentRef}
            InputLabelProps={{ shrink: true }}
          />

          {/* ÏÑ§Î™Ö - Ï†ÑÏ≤¥ ÎÑàÎπÑ */}
          <TextField
            fullWidth
            label="ÏÑ§Î™Ö"
            multiline
            rows={4}
            value={descriptionInput.inputValue}
            onChange={(e) => descriptionInput.handleChange(e.target.value)}
            variant="outlined"
            InputLabelProps={{ shrink: true }}
            inputRef={descriptionRef}
          />

          {/* ÏÜåÌîÑÌä∏Ïõ®Ïñ¥Î∂ÑÎ•ò, Ïä§Ìéô, ÏÉÅÌÉú - 3Îì±Î∂Ñ Î∞∞Ïπò */}
          <Stack direction="row" spacing={2}>
            <FormControl fullWidth>
              <InputLabel shrink>
                <span>
                  ÏÜåÌîÑÌä∏Ïõ®Ïñ¥Î∂ÑÎ•ò <span style={{ color: 'red' }}>*</span>
                </span>
              </InputLabel>
              <Select
                value={softwareState.softwareCategory}
                label="ÏÜåÌîÑÌä∏Ïõ®Ïñ¥Î∂ÑÎ•ò"
                onChange={handleFieldChange('softwareCategory')}
                disabled={categoriesLoading}
                displayEmpty
              >
                {categoriesLoading ? (
                  <MenuItem disabled>
                    <Typography variant="body2" sx={{ color: 'text.secondary' }}>
                      Î°úÎî© Ï§ë...
                    </Typography>
                  </MenuItem>
                ) : categoriesError ? (
                  <MenuItem disabled>
                    <Typography variant="body2" sx={{ color: 'error.main' }}>
                      Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®
                    </Typography>
                  </MenuItem>
                ) : (
                  [
                    <MenuItem key="empty" value="">
                      ÏÑ†ÌÉù
                    </MenuItem>,
                    ...softwareCategories.map((category) => (
                      <MenuItem key={category} value={category}>
                        {category}
                      </MenuItem>
                    ))
                  ]
                )}
              </Select>
              {categoriesError && (
                <Typography variant="caption" sx={{ color: 'error.main', mt: 0.5 }}>
                  GROUP015 ÎßàÏä§ÌÑ∞ÏΩîÎìú Î°úÎìúÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.
                </Typography>
              )}
            </FormControl>

            <TextField
              fullWidth
              label="Ïä§Ìéô"
              value={softwareState.spec}
              onChange={handleFieldChange('spec')}
              variant="outlined"
              InputLabelProps={{ shrink: true }}
            />

            <FormControl fullWidth>
              <InputLabel shrink>ÏÉÅÌÉú</InputLabel>
              <Select
                value={softwareState.status}
                label="ÏÉÅÌÉú"
                onChange={handleFieldChange('status')}
                disabled={statusLoading}
              >
                {statusLoading ? (
                  <MenuItem disabled>
                    <Typography variant="body2" sx={{ color: 'text.secondary' }}>
                      Î°úÎî© Ï§ë...
                    </Typography>
                  </MenuItem>
                ) : statusError ? (
                  <MenuItem disabled>
                    <Typography variant="body2" sx={{ color: 'error.main' }}>
                      Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®
                    </Typography>
                  </MenuItem>
                ) : (
                  masterStatusOptions.map((status) => {
                    const getStatusColor = (statusName: string) => {
                      switch (statusName) {
                        case 'ÎåÄÍ∏∞':
                          return { bgcolor: '#F5F5F5', color: '#757575' };
                        case 'ÏßÑÌñâ':
                          return { bgcolor: '#E3F2FD', color: '#1976D2' };
                        case 'ÏÇ¨Ïö©Ï§ë':
                        case 'ÏôÑÎ£å':
                          return { bgcolor: '#E8F5E9', color: '#388E3C' };
                        case 'ÌôÄÎî©':
                        case 'ÌôÄÎî©22':
                          return { bgcolor: '#FFEBEE', color: '#D32F2F' };
                        default:
                          return { bgcolor: '#F5F5F5', color: '#757575' };
                      }
                    };

                    return (
                      <MenuItem key={status} value={status}>
                        <Chip
                          label={status}
                          size="small"
                          sx={{
                            backgroundColor: getStatusColor(status).bgcolor,
                            color: getStatusColor(status).color,
                            fontSize: '13px',
                            fontWeight: 400
                          }}
                        />
                      </MenuItem>
                    );
                  })
                )}
              </Select>
              {statusError && (
                <Typography variant="caption" sx={{ color: 'error.main', mt: 0.5 }}>
                  GROUP002 ÎßàÏä§ÌÑ∞ÏΩîÎìú Î°úÎìúÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.
                </Typography>
              )}
            </FormControl>
          </Stack>

          {/* ÏÜîÎ£®ÏÖòÏóÖÏ≤¥ - ÏÇ¨Ïö©ÏûêÏàò - ÏÇ¨Ïö©Ïûê - 3Îì±Î∂Ñ Î∞∞Ïπò */}
          <Stack direction="row" spacing={2}>
            <TextField
              fullWidth
              label={
                <span>
                  ÏÜîÎ£®ÏÖòÏóÖÏ≤¥ <span style={{ color: 'red' }}>*</span>
                </span>
              }
              value={softwareState.solutionProvider}
              onChange={handleFieldChange('solutionProvider')}
              variant="outlined"
              InputLabelProps={{ shrink: true }}
            />

            <TextField
              fullWidth
              label="ÏÇ¨Ïö©ÏûêÏàò"
              type="number"
              value={softwareState.userCount}
              onChange={handleFieldChange('userCount')}
              variant="outlined"
              InputLabelProps={{ shrink: true }}
              inputProps={{ min: 0 }}
            />

            <TextField
              fullWidth
              label="ÏÇ¨Ïö©Ïûê"
              value={softwareState.currentUser}
              onChange={handleFieldChange('currentUser')}
              variant="outlined"
              InputLabelProps={{ shrink: true }}
            />
          </Stack>

          {/* ÎùºÏù¥ÏÑºÏä§Ïú†ÌòïÍ≥º ÎùºÏù¥ÏÑºÏä§ÌÇ§ - Ï¢åÏö∞ Î∞∞Ïπò */}
          <Stack direction="row" spacing={2}>
            <FormControl fullWidth>
              <InputLabel shrink>
                <span>
                  ÎùºÏù¥ÏÑºÏä§Ïú†Ìòï <span style={{ color: 'red' }}>*</span>
                </span>
              </InputLabel>
              <Select
                value={softwareState.licenseType}
                label="ÎùºÏù¥ÏÑºÏä§Ïú†Ìòï"
                onChange={handleFieldChange('licenseType')}
                disabled={licenseLoading}
                displayEmpty
              >
                {licenseLoading ? (
                  <MenuItem disabled>
                    <Typography variant="body2" sx={{ color: 'text.secondary' }}>
                      Î°úÎî© Ï§ë...
                    </Typography>
                  </MenuItem>
                ) : licenseError ? (
                  <MenuItem disabled>
                    <Typography variant="body2" sx={{ color: 'error.main' }}>
                      Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®
                    </Typography>
                  </MenuItem>
                ) : (
                  [
                    <MenuItem key="empty" value="">
                      ÏÑ†ÌÉù
                    </MenuItem>,
                    ...masterLicenseTypes.map((licenseType) => (
                      <MenuItem key={licenseType} value={licenseType}>
                        {licenseType}
                      </MenuItem>
                    ))
                  ]
                )}
              </Select>
              {licenseError && (
                <Typography variant="caption" sx={{ color: 'error.main', mt: 0.5 }}>
                  GROUP016 ÎßàÏä§ÌÑ∞ÏΩîÎìú Î°úÎìúÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.
                </Typography>
              )}
            </FormControl>

            <TextField
              fullWidth
              label="ÎùºÏù¥ÏÑºÏä§ÌÇ§"
              value={softwareState.licenseKey}
              onChange={handleFieldChange('licenseKey')}
              variant="outlined"
              InputLabelProps={{ shrink: true }}
            />
          </Stack>

          {/* ÌåÄÍ≥º Îã¥ÎãπÏûê - Ï¢åÏö∞ Î∞∞Ïπò */}
          <Stack direction="row" spacing={2}>
            <TextField
              fullWidth
              label="ÌåÄ"
              value={softwareState.team || 'ÌåÄ ÎØ∏ÏßÄÏ†ï'}
              variant="outlined"
              InputLabelProps={{ shrink: true }}
              InputProps={{
                readOnly: true
              }}
              sx={{
                '& .MuiOutlinedInput-root': {
                  backgroundColor: '#f5f5f5',
                  '& fieldset': {
                    borderColor: '#e0e0e0'
                  },
                  '&:hover fieldset': {
                    borderColor: '#e0e0e0'
                  },
                  '&.Mui-focused fieldset': {
                    borderColor: '#e0e0e0'
                  }
                },
                '& .MuiInputBase-input': {
                  color: '#666666'
                }
              }}
            />

            <TextField
              fullWidth
              label="Îã¥ÎãπÏûê"
              value={softwareState.assignee || 'Îã¥ÎãπÏûê ÎØ∏ÏßÄÏ†ï'}
              variant="outlined"
              InputLabelProps={{ shrink: true }}
              InputProps={{
                readOnly: true,
                startAdornment: softwareState.assignee ? (
                  <Avatar
                    src={(() => {
                      const user = users.find((u) => u.user_name === softwareState.assignee);
                      return user?.avatar_url || user?.profile_image_url;
                    })()}
                    alt={softwareState.assignee}
                    sx={{ width: 24, height: 24, mr: -0.5 }}
                  >
                    {softwareState.assignee?.charAt(0)}
                  </Avatar>
                ) : null
              }}
              sx={{
                '& .MuiOutlinedInput-root': {
                  backgroundColor: '#f5f5f5',
                  '& fieldset': {
                    borderColor: '#e0e0e0'
                  },
                  '&:hover fieldset': {
                    borderColor: '#e0e0e0'
                  },
                  '&.Mui-focused fieldset': {
                    borderColor: '#e0e0e0'
                  }
                },
                '& .MuiInputBase-input': {
                  color: '#666666'
                }
              }}
            />
          </Stack>

          {/* Îì±Î°ùÏùºÍ≥º ÏΩîÎìú - Ï¢åÏö∞ Î∞∞Ïπò */}
          <Stack direction="row" spacing={2}>
            <TextField
              fullWidth
              label="Îì±Î°ùÏùº"
              type="date"
              value={softwareState.registrationDate}
              InputLabelProps={{ shrink: true }}
              variant="outlined"
              InputProps={{
                readOnly: true
              }}
              sx={{
                '& .MuiOutlinedInput-root': {
                  backgroundColor: '#f5f5f5',
                  '& fieldset': {
                    borderColor: '#e0e0e0'
                  },
                  '&:hover fieldset': {
                    borderColor: '#e0e0e0'
                  },
                  '&.Mui-focused fieldset': {
                    borderColor: '#e0e0e0'
                  }
                },
                '& .MuiInputBase-input': {
                  color: '#666666'
                }
              }}
            />

            <TextField
              fullWidth
              label="ÏΩîÎìú"
              value={softwareState.code}
              InputLabelProps={{ shrink: true }}
              variant="outlined"
              InputProps={{
                readOnly: true
              }}
              sx={{
                '& .MuiOutlinedInput-root': {
                  backgroundColor: '#f5f5f5',
                  '& fieldset': {
                    borderColor: '#e0e0e0'
                  },
                  '&:hover fieldset': {
                    borderColor: '#e0e0e0'
                  },
                  '&.Mui-focused fieldset': {
                    borderColor: '#e0e0e0'
                  }
                },
                '& .MuiInputBase-input': {
                  color: '#666666'
                }
              }}
            />
          </Stack>
        </Stack>
      </Box>
    );
  }
);

OverviewTab.displayName = 'OverviewTab';

// Î™®ÎçòÌïú Ï†ëÍ∏∞/ÌéºÏπòÍ∏∞ ÏïÑÏù¥ÏΩò Ïª¥Ìè¨ÎÑåÌä∏
const ExpandIcon = ({ expanded }: { expanded: boolean }) => (
  <SvgIcon
    sx={{
      transition: 'transform 0.2s ease-in-out, color 0.2s ease-in-out',
      transform: expanded ? 'rotate(0deg)' : 'rotate(-90deg)',
      fontSize: '14px',
      '&:hover': {
        transform: expanded ? 'rotate(0deg) scale(1.1)' : 'rotate(-90deg) scale(1.1)',
        color: 'primary.main'
      }
    }}
  >
    <path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" />
  </SvgIcon>
);

// ÏûêÎ£å ÌÉ≠ Ïª¥Ìè¨ÎÑåÌä∏
const MaterialTab = memo(
  ({
    materials,
    onAddMaterial,
    editingMaterialId,
    editingMaterialText,
    onEditMaterial,
    onSaveEditMaterial,
    onCancelEditMaterial,
    onDeleteMaterial,
    onEditMaterialTextChange,
    onDownloadMaterial
  }: any) => {
    const fileInputRef = useRef<HTMLInputElement>(null);

    const handleFileUpload = useCallback(
      (event: React.ChangeEvent<HTMLInputElement>) => {
        const files = event.target.files;
        if (!files || files.length === 0) return;

        Array.from(files).forEach((file) => {
          const material = {
            id: Date.now() + Math.random(),
            name: file.name,
            type: file.type || 'application/octet-stream',
            size: formatFileSize(file.size),
            file: file,
            uploadDate: new Date().toISOString().split('T')[0]
          };

          onAddMaterial(material);
        });

        // ÌååÏùº ÏûÖÎ†• Ï¥àÍ∏∞Ìôî
        if (fileInputRef.current) {
          fileInputRef.current.value = '';
        }
      },
      [onAddMaterial]
    );

    const formatFileSize = (bytes: number): string => {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    };

    const getFileIcon = (type: string): string => {
      if (type.startsWith('image/')) return 'üñºÔ∏è';
      if (type.startsWith('video/')) return 'üé•';
      if (type.startsWith('audio/')) return 'üéµ';
      if (type.includes('pdf')) return 'üìÑ';
      if (type.includes('word') || type.includes('document')) return 'üìù';
      if (type.includes('excel') || type.includes('spreadsheet')) return 'üìä';
      if (type.includes('powerpoint') || type.includes('presentation')) return 'üìã';
      if (type.includes('zip') || type.includes('rar') || type.includes('archive')) return 'üì¶';
      return 'üìÑ';
    };

    const handleUploadClick = useCallback(() => {
      fileInputRef.current?.click();
    }, []);

    return (
      <Box sx={{ height: '650px', px: '5%' }}>
        {/* ÌååÏùº ÏóÖÎ°úÎìú ÏòÅÏó≠ */}
        <Box sx={{ mb: 3, pt: 2 }}>
          <input type="file" ref={fileInputRef} onChange={handleFileUpload} multiple style={{ display: 'none' }} accept="*/*" />

          {/* ÏóÖÎ°úÎìú Î≤ÑÌäºÍ≥º ÎìúÎûòÍ∑∏ Ïï§ ÎìúÎ°≠ ÏòÅÏó≠ */}
          <Paper
            variant="outlined"
            sx={{
              p: 3,
              textAlign: 'center',
              borderStyle: 'dashed',
              borderColor: 'primary.main',
              backgroundColor: 'primary.50',
              cursor: 'pointer',
              transition: 'all 0.2s ease-in-out',
              '&:hover': {
                borderColor: 'primary.dark',
                backgroundColor: 'primary.100'
              }
            }}
            onClick={handleUploadClick}
          >
            <Stack spacing={2} alignItems="center">
              <Typography fontSize="48px">üìÅ</Typography>
              <Typography variant="h6" color="primary.main">
                ÌååÏùºÏùÑ ÏóÖÎ°úÎìúÌïòÏÑ∏Ïöî
              </Typography>
              <Typography variant="body2" color="text.secondary">
                ÌÅ¥Î¶≠ÌïòÍ±∞ÎÇò ÌååÏùºÏùÑ Ïó¨Í∏∞Î°ú ÎìúÎûòÍ∑∏ÌïòÏÑ∏Ïöî
              </Typography>
              <Button variant="contained" size="small" startIcon={<Typography>üì§</Typography>}>
                ÌååÏùº ÏÑ†ÌÉù
              </Button>
            </Stack>
          </Paper>
        </Box>

        {/* ÏûêÎ£å Ìï≠Î™©Îì§ */}
        <Box sx={{ flex: 1, overflowY: 'auto', minHeight: 0 }}>
          <Stack spacing={2}>
            {materials.map((material: any, index: number) => (
              <Paper
                key={material.id}
                variant="outlined"
                sx={{
                  p: 2,
                  borderRadius: 2,
                  border: '1px solid',
                  borderColor: 'grey.300',
                  backgroundColor: 'background.paper',
                  transition: 'all 0.2s ease-in-out',
                  '&:hover': {
                    borderColor: 'primary.light',
                    boxShadow: 1
                  }
                }}
              >
                <Stack direction="row" spacing={2} alignItems="center">
                  {/* ÌååÏùº ÏïÑÏù¥ÏΩò */}
                  <Box
                    sx={{
                      width: 48,
                      height: 48,
                      borderRadius: 1,
                      backgroundColor: 'primary.50',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center'
                    }}
                  >
                    <Typography fontSize="24px">{getFileIcon(material.type || '')}</Typography>
                  </Box>

                  {/* ÌååÏùº Ï†ïÎ≥¥ ÏòÅÏó≠ */}
                  <Box sx={{ flexGrow: 1 }}>
                    {editingMaterialId === material.id ? (
                      <TextField
                        fullWidth
                        value={editingMaterialText}
                        onChange={(e) => onEditMaterialTextChange(e.target.value)}
                        onKeyPress={(e) => {
                          if (e.key === 'Enter') onSaveEditMaterial();
                          if (e.key === 'Escape') onCancelEditMaterial();
                        }}
                        variant="outlined"
                        size="small"
                        autoFocus
                        InputLabelProps={{ shrink: true }}
                      />
                    ) : (
                      <Typography
                        variant="body1"
                        sx={{
                          fontWeight: 500,
                          cursor: 'pointer',
                          '&:hover': {
                            backgroundColor: 'action.hover',
                            borderRadius: 1,
                            px: 1
                          }
                        }}
                        onClick={() => onEditMaterial(material.id, material.name)}
                      >
                        {material.name}
                      </Typography>
                    )}
                    <Typography variant="caption" color="text.secondary">
                      {material.type} ‚Ä¢ {material.size}
                      {material.uploadDate && ` ‚Ä¢ ${material.uploadDate}`}
                    </Typography>
                  </Box>

                  {/* Ïï°ÏÖò Î≤ÑÌäºÎì§ */}
                  <Stack direction="row" spacing={1}>
                    {editingMaterialId === material.id ? (
                      <>
                        <IconButton size="small" onClick={onSaveEditMaterial} color="success" sx={{ p: 0.5 }} title="Ï†ÄÏû•">
                          <Typography fontSize="14px">‚úì</Typography>
                        </IconButton>
                        <IconButton size="small" onClick={onCancelEditMaterial} color="error" sx={{ p: 0.5 }} title="Ï∑®ÏÜå">
                          <Typography fontSize="14px">‚úï</Typography>
                        </IconButton>
                      </>
                    ) : (
                      <>
                        <IconButton
                          size="small"
                          onClick={() => onDownloadMaterial(material)}
                          color="primary"
                          sx={{ p: 0.5 }}
                          title="Îã§Ïö¥Î°úÎìú"
                        >
                          <Typography fontSize="14px">‚¨áÔ∏è</Typography>
                        </IconButton>
                        <IconButton
                          size="small"
                          onClick={() => onEditMaterial(material.id, material.name)}
                          color="primary"
                          sx={{ p: 0.5 }}
                          title="ÏàòÏ†ï"
                        >
                          <Typography fontSize="14px">‚úèÔ∏è</Typography>
                        </IconButton>
                        <IconButton size="small" onClick={() => onDeleteMaterial(material.id)} color="error" sx={{ p: 0.5 }} title="ÏÇ≠Ï†ú">
                          <Typography fontSize="14px">üóëÔ∏è</Typography>
                        </IconButton>
                      </>
                    )}
                  </Stack>
                </Stack>
              </Paper>
            ))}
          </Stack>

          {/* Îπà ÏÉÅÌÉú Î©îÏãúÏßÄ */}
          {materials.length === 0 && (
            <Box
              sx={{
                p: 2.5,
                mt: 2,
                borderRadius: 2,
                backgroundColor: '#f8f9fa',
                border: '1px solid #e9ecef'
              }}
            >
              <Typography
                variant="body2"
                sx={{
                  color: '#6c757d',
                  lineHeight: 1.6,
                  fontSize: '0.875rem',
                  textAlign: 'center'
                }}
              >
                üìÅ ÏïÑÏßÅ ÏóÖÎ°úÎìúÎêú ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.
                <br />
                ÏúÑÏùò ÏóÖÎ°úÎìú ÏòÅÏó≠ÏùÑ ÌÅ¥Î¶≠ÌïòÏó¨ ÌååÏùºÏùÑ ÏóÖÎ°úÎìúÌï¥Î≥¥ÏÑ∏Ïöî.
              </Typography>
            </Box>
          )}
        </Box>
      </Box>
    );
  }
);

MaterialTab.displayName = 'MaterialTab';

// ÏÇ¨Ïö©Ïûê Ïù¥Î†• Ïù∏ÌÑ∞ÌéòÏù¥Ïä§
interface UserHistory {
  id: string;
  registrationDate: string;
  userId?: string;
  userName: string;
  department: string;
  exclusiveId: string;
  startDate: string;
  endDate: string;
  reason: string;
  status: string; // 'active' | 'inactive' | 'ÏÇ¨Ïö©Ï§ë' | 'Ï§ëÏßÄ' | 'Î∞òÎÇ©' Îì±
  team?: string; // departmentÏôÄ Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌï¥ Ï∂îÍ∞Ä
}

// ÏÇ¨Ïö©ÏûêÏù¥Î†• ÌÉ≠ Ïª¥Ìè¨ÎÑåÌä∏
const UserHistoryTab = memo(({
  softwareId,
  mode,
  userHistories: initialUserHistories,
  onUserHistoriesChange
}: {
  softwareId: number;
  mode: 'add' | 'edit';
  userHistories: UserHistory[];
  onUserHistoriesChange: (histories: UserHistory[]) => void;
}) => {
  const { getUserHistories, convertToUserHistory } = useSupabaseSoftwareUser();

  // Î°úÏª¨ ÏÇ¨Ïö©ÏûêÏù¥Î†• ÏÉÅÌÉú
  const [userHistories, setUserHistories] = useState<UserHistory[]>(initialUserHistories);

  // DBÏóêÏÑú ÏÇ¨Ïö©ÏûêÏù¥Î†• Î°úÎìú (Ìé∏Ïßë Î™®ÎìúÏù∏ Í≤ΩÏö∞)
  useEffect(() => {
    const loadUserHistories = async () => {
      if (mode === 'edit' && softwareId) {
        try {
          const userData = await getUserHistories(softwareId);
          const convertedData = userData.map(convertToUserHistory);
          setUserHistories(convertedData);
          onUserHistoriesChange(convertedData);
        } catch (error) {
          console.warn('‚ö†Ô∏è ÏÇ¨Ïö©ÏûêÏù¥Î†• Î°úÎìú Ï§ë Ïò§Î•ò:', error);
          // ÏóêÎü¨Í∞Ä Î∞úÏÉùÌï¥ÎèÑ Îπà Î∞∞Ïó¥Î°ú Ï¥àÍ∏∞ÌôîÌïòÏó¨ UIÍ∞Ä Ï†ïÏÉÅ ÏûëÎèôÌïòÎèÑÎ°ù Ìï®
          setUserHistories([]);
          onUserHistoriesChange([]);
        }
      }
    };

    loadUserHistories();
  }, [mode, softwareId]);

  // ÏÇ¨Ïö©ÏûêÏù¥Î†• Î≥ÄÍ≤Ω Ïãú Î∂ÄÎ™® Ïª¥Ìè¨ÎÑåÌä∏Ïóê ÏïåÎ¶º
  useEffect(() => {
    onUserHistoriesChange(userHistories);
  }, [userHistories, onUserHistoriesChange]);

  // Îçî ÎßéÏùÄ ÏÉòÌîå Îç∞Ïù¥ÌÑ∞Î°ú ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò ÌÖåÏä§Ìä∏ (add Î™®ÎìúÏùº ÎïåÎßå ÏÇ¨Ïö©)
  const [sampleUserHistories] = useState<UserHistory[]>([
    {
      id: '1',
      registrationDate: '2024-01-15',
      userId: 'user1',
      userName: 'ÍπÄÏ≤†Ïàò',
      department: 'ITÌåÄ',
      exclusiveId: 'SW001-KCS',
      startDate: '2024-01-15',
      endDate: '2024-06-30',
      reason: 'Î∂ÄÏÑú Ïù¥Îèô',
      status: 'inactive'
    },
    {
      id: '2',
      registrationDate: '2024-07-01',
      userId: 'user2',
      userName: 'Ïù¥ÏòÅÌù¨',
      department: 'Í∞úÎ∞úÌåÄ',
      exclusiveId: 'SW001-LYH',
      startDate: '2024-07-01',
      endDate: '',
      reason: 'Ïã†Í∑ú Î∞∞Ï†ï',
      status: 'active'
    },
    {
      id: '3',
      registrationDate: '2024-08-01',
      userId: 'user3',
      userName: 'Î∞ïÎØºÏàò',
      department: 'ÎîîÏûêÏù∏ÌåÄ',
      exclusiveId: 'SW001-PMS',
      startDate: '2024-08-01',
      endDate: '',
      reason: 'Ïã†Í∑ú Î∞∞Ï†ï',
      status: 'active'
    },
    {
      id: '4',
      registrationDate: '2024-08-05',
      userId: 'user4',
      userName: 'ÏµúÏùÄÏßÄ',
      department: 'Í∏∞ÌöçÌåÄ',
      exclusiveId: 'SW001-CEJ',
      startDate: '2024-08-05',
      endDate: '',
      reason: 'Ïã†Í∑ú Î∞∞Ï†ï',
      status: 'active'
    },
    {
      id: '5',
      registrationDate: '2024-08-10',
      userId: 'user5',
      userName: 'Ï†ïÌòÑÏö∞',
      department: 'ÎßàÏºÄÌåÖÌåÄ',
      exclusiveId: 'SW001-JHW',
      startDate: '2024-08-10',
      endDate: '',
      reason: 'Ïã†Í∑ú Î∞∞Ï†ï',
      status: 'active'
    },
    {
      id: '6',
      registrationDate: '2024-08-15',
      userId: 'user6',
      userName: 'Í∞ïÏòàÎ¶∞',
      department: 'ITÌåÄ',
      exclusiveId: 'SW001-KYR',
      startDate: '2024-08-15',
      endDate: '',
      reason: 'Ïã†Í∑ú Î∞∞Ï†ï',
      status: 'active'
    },
    {
      id: '7',
      registrationDate: '2024-08-20',
      userId: 'user7',
      userName: 'ÏÜ°ÏßÄÌõà',
      department: 'Í∞úÎ∞úÌåÄ',
      exclusiveId: 'SW001-SJH',
      startDate: '2024-08-20',
      endDate: '',
      reason: 'Ïã†Í∑ú Î∞∞Ï†ï',
      status: 'active'
    },
    {
      id: '8',
      registrationDate: '2024-08-22',
      userId: 'user8',
      userName: 'ÍπÄÏÜåÏòÅ',
      department: 'ÎîîÏûêÏù∏ÌåÄ',
      exclusiveId: 'SW001-KSY',
      startDate: '2024-08-22',
      endDate: '',
      reason: 'Ïã†Í∑ú Î∞∞Ï†ï',
      status: 'active'
    },
    {
      id: '9',
      registrationDate: '2024-08-24',
      userId: 'user9',
      userName: 'Ïù¥ÎèôÌòÑ',
      department: 'Í∏∞ÌöçÌåÄ',
      exclusiveId: 'SW001-LDH',
      startDate: '2024-08-24',
      endDate: '',
      reason: 'Ïã†Í∑ú Î∞∞Ï†ï',
      status: 'active'
    }
  ]);

  const [selectedRows, setSelectedRows] = useState<string[]>([]);
  const [editingCell, setEditingCell] = useState<{ id: string; field: string } | null>(null);
  const [statusWarning, setStatusWarning] = useState<string>('');

  // ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò ÏÉÅÌÉú
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage] = useState(7);

  // ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò Í≥ÑÏÇ∞
  const totalPages = Math.ceil(userHistories.length / itemsPerPage);
  const startIndex = (currentPage - 1) * itemsPerPage;
  const endIndex = startIndex + itemsPerPage;
  const currentItems = userHistories.slice(startIndex, endIndex);

  // ÌéòÏù¥ÏßÄ Î≥ÄÍ≤Ω Ìï∏Îì§Îü¨ (MUI Pagination ÌòïÏãùÏóê ÎßûÍ≤å ÏàòÏ†ï)
  const handlePageChange = (event: React.ChangeEvent<unknown>, page: number) => {
    setCurrentPage(page);
  };

  const handleCellClick = (id: string, field: string) => {
    setEditingCell({ id, field });
  };

  const handleCellBlur = () => {
    setEditingCell(null);
  };

  const handleAddHistory = () => {
    const newHistory: UserHistory = {
      id: Date.now().toString(),
      registrationDate: new Date().toISOString().split('T')[0],
      userId: '',
      userName: '',
      department: '',
      exclusiveId: '',
      startDate: new Date().toISOString().split('T')[0],
      endDate: '',
      reason: '',
      status: 'active'
    };
    setUserHistories([newHistory, ...userHistories]);
  };

  const handleDeleteSelected = () => {
    setUserHistories(userHistories.filter((h) => !selectedRows.includes(h.id)));
    setSelectedRows([]);
  };

  const handleEditHistory = (id: string, field: keyof UserHistory, value: string) => {
    // ÏÜåÌîÑÌä∏Ïõ®Ïñ¥Îäî ÎèôÏãú ÏÇ¨Ïö©Ïù¥ Í∞ÄÎä•ÌïòÎØÄÎ°ú ÏÉÅÌÉú Í≤ÄÏ¶ù Ï†úÍ±∞
    setUserHistories(userHistories.map((h) => (h.id === id ? { ...h, [field]: value } : h)));
    setStatusWarning('');
  };

  const handleSelectRow = (id: string) => {
    if (selectedRows.includes(id)) {
      setSelectedRows(selectedRows.filter((rowId) => rowId !== id));
    } else {
      setSelectedRows([...selectedRows, id]);
    }
  };

  const handleSelectAll = (event: React.ChangeEvent<HTMLInputElement>) => {
    if (event.target.checked) {
      setSelectedRows(userHistories.map((h) => h.id));
    } else {
      setSelectedRows([]);
    }
  };

  const statusOptions = useMemo(() => ['ÏÇ¨Ïö©Ï§ë', 'Ï¢ÖÎ£å'], []);
  const statusColors: Record<string, string> = useMemo(() => ({
    ÏÇ¨Ïö©Ï§ë: 'success',
    Ï¢ÖÎ£å: 'default'
  }), []);

  // Ïª¨Îüº ÎÑàÎπÑ Î∞è ÎÜíÏù¥ Ï†ïÏùò (Ìé∏Ïßë/ÏùΩÍ∏∞ Î™®Îìú Í≥µÌÜµ)
  const columnWidths = useMemo(() => ({
    checkbox: 50,
    no: 60,
    registrationDate: 100,
    team: 100,
    userName: 120,
    exclusiveId: 120,
    reason: 150,
    status: 100,
    startDate: 100,
    endDate: 100
  }), []);

  const cellHeight = 56; // Í≥†Ï†ï ÏÖÄ ÎÜíÏù¥

  // Ìé∏Ïßë Í∞ÄÎä•Ìïú ÏÖÄ Î†åÎçîÎßÅ
  const renderEditableCell = (history: UserHistory, field: string, value: string, options?: string[]) => {
    const isEditing = editingCell?.id === history.id && editingCell?.field === field;
    const fieldWidth = columnWidths[field as keyof typeof columnWidths] || 100;

    if (isEditing) {
      if (options) {
        return (
          <Select
            value={value}
            onChange={(e) => {
              const newValue = e.target.value;
              if (field === 'status') {
                const newStatus = newValue === 'ÏÇ¨Ïö©Ï§ë' ? 'active' : 'inactive';
                handleEditHistory(history.id, 'status', newStatus);
              } else {
                handleEditHistory(history.id, field as keyof UserHistory, newValue);
              }
            }}
            onBlur={handleCellBlur}
            size="small"
            autoFocus
            sx={{
              width: fieldWidth - 16,
              minWidth: fieldWidth - 16,
              height: 40, // Í≥†Ï†ï ÎÜíÏù¥
              '& .MuiSelect-select': {
                padding: '8px 14px',
                fontSize: '12px',
                lineHeight: '1.4'
              }
            }}
          >
            {options.map((option) => (
              <MenuItem key={option} value={option}>
                {field === 'status' ? <Chip label={option} color={statusColors[option] as any} size="small" /> : option}
              </MenuItem>
            ))}
          </Select>
        );
      }

      if (field === 'startDate' || field === 'endDate') {
        return (
          <TextField
            type="date"
            value={value || ''}
            onChange={(e) => handleEditHistory(history.id, field as keyof UserHistory, e.target.value)}
            onBlur={handleCellBlur}
            size="small"
            autoFocus
            InputLabelProps={{
              shrink: true
            }}
            sx={{
              width: fieldWidth - 16,
              height: 40, // Í≥†Ï†ï ÎÜíÏù¥
              '& .MuiInputBase-root': {
                height: 40
              },
              '& .MuiInputBase-input': {
                fontSize: '12px',
                padding: '8px 14px'
              }
            }}
          />
        );
      }

      return (
        <TextField
          value={value}
          onChange={(e) => handleEditHistory(history.id, field as keyof UserHistory, e.target.value)}
          onBlur={handleCellBlur}
          size="small"
          autoFocus
          InputLabelProps={{ shrink: true }}
          sx={{
            width: fieldWidth - 16,
            height: 40, // Í≥†Ï†ï ÎÜíÏù¥
            '& .MuiInputBase-root': {
              height: 40
            },
            '& .MuiInputBase-input': {
              fontSize: '12px',
              padding: '8px 14px'
            }
          }}
        />
      );
    }

    // ÏùΩÍ∏∞ Î™®Îìú
    if (field === 'status') {
      return (
        <Box
          sx={{
            height: 40, // Í≥†Ï†ï ÎÜíÏù¥
            display: 'flex',
            alignItems: 'center',
            cursor: 'pointer'
          }}
        >
          <Chip
            label={value}
            color={statusColors[value] as any}
            size="small"
            sx={{
              '&:hover': { opacity: 0.8 },
              fontSize: '12px'
            }}
          />
        </Box>
      );
    }

    return (
      <Box
        sx={{
          height: 40, // Í≥†Ï†ï ÎÜíÏù¥
          display: 'flex',
          alignItems: 'center',
          cursor: 'pointer',
          '&:hover': { bgcolor: 'grey.50' },
          p: 0.5,
          borderRadius: 1
        }}
      >
        <Typography
          variant="body2"
          sx={{
            fontSize: '12px'
          }}
        >
          {value || '-'}
        </Typography>
      </Box>
    );
  };

  return (
    <Box sx={{ height: '650px', display: 'flex', flexDirection: 'column', p: 3 }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
        <Typography variant="h6" sx={{ fontSize: '16px', fontWeight: 600 }}>
          ÏÇ¨Ïö©Ïûê Ïù¥Î†• Í¥ÄÎ¶¨
        </Typography>
        <Box sx={{ display: 'flex', gap: 1 }}>
          <Button variant="outlined" color="error" onClick={handleDeleteSelected} disabled={selectedRows.length === 0} size="small">
            ÏÇ≠Ï†ú({selectedRows.length})
          </Button>
          <Button variant="contained" onClick={handleAddHistory} size="small" sx={{ fontSize: '12px' }}>
            Ï∂îÍ∞Ä
          </Button>
        </Box>
      </Box>

      <TableContainer
        sx={{
          flex: 1,
          overflowY: 'auto',
          overflowX: 'auto',
          '& .MuiTable-root': {
            minWidth: 800
          }
        }}
      >
        <Table size="small">
          <TableHead>
            <TableRow sx={{ backgroundColor: 'grey.50' }}>
              <TableCell padding="checkbox" sx={{ width: columnWidths.checkbox }}>
                <Checkbox
                  checked={selectedRows.length === userHistories.length && userHistories.length > 0}
                  onChange={handleSelectAll}
                  color="primary"
                  size="small"
                  sx={{
                    transform: 'scale(0.7)',
                    '&.Mui-checked': {
                      color: '#1976d2'
                    }
                  }}
                />
              </TableCell>
              <TableCell sx={{ width: columnWidths.no, fontWeight: 600 }}>NO</TableCell>
              <TableCell sx={{ width: columnWidths.registrationDate, fontWeight: 600 }}>Îì±Î°ùÏùº</TableCell>
              <TableCell sx={{ width: columnWidths.team, fontWeight: 600 }}>ÌåÄ</TableCell>
              <TableCell sx={{ width: columnWidths.userName, fontWeight: 600 }}>ÏÇ¨Ïö©Ïûê</TableCell>
              <TableCell sx={{ width: columnWidths.exclusiveId, fontWeight: 600 }}>Ï†ÑÏö©ÏïÑÏù¥Îîî</TableCell>
              <TableCell sx={{ width: columnWidths.reason, fontWeight: 600 }}>ÏÇ¨Ïú†</TableCell>
              <TableCell sx={{ width: columnWidths.status, fontWeight: 600 }}>ÏÇ¨Ïö©ÏÉÅÌÉú</TableCell>
              <TableCell sx={{ width: columnWidths.startDate, fontWeight: 600 }}>ÏãúÏûëÏùº</TableCell>
              <TableCell sx={{ width: columnWidths.endDate, fontWeight: 600 }}>Ï¢ÖÎ£åÏùº</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {currentItems.map((history, index) => (
              <TableRow
                key={`history_${history.id}_${index}`}
                hover
                sx={{
                  height: cellHeight,
                  '&:hover': { backgroundColor: 'action.hover' }
                }}
              >
                <TableCell padding="checkbox" sx={{ width: columnWidths.checkbox }}>
                  <Checkbox
                    checked={selectedRows.includes(history.id)}
                    onChange={() => handleSelectRow(history.id)}
                    color="primary"
                    size="small"
                    sx={{
                      transform: 'scale(0.7)',
                      '&.Mui-checked': {
                        color: '#1976d2'
                      }
                    }}
                  />
                </TableCell>
                <TableCell sx={{ width: columnWidths.no }}>{userHistories.length - startIndex - index}</TableCell>
                <TableCell sx={{ width: columnWidths.registrationDate }} onClick={() => handleCellClick(history.id, 'registrationDate')}>
                  {renderEditableCell(history, 'registrationDate', history.registrationDate)}
                </TableCell>
                <TableCell sx={{ width: columnWidths.team }} onClick={() => handleCellClick(history.id, 'department')}>
                  {renderEditableCell(history, 'department', history.department)}
                </TableCell>
                <TableCell sx={{ width: columnWidths.userName }} onClick={() => handleCellClick(history.id, 'userName')}>
                  {renderEditableCell(history, 'userName', history.userName)}
                </TableCell>
                <TableCell sx={{ width: columnWidths.exclusiveId }} onClick={() => handleCellClick(history.id, 'exclusiveId')}>
                  {renderEditableCell(history, 'exclusiveId', history.exclusiveId)}
                </TableCell>
                <TableCell sx={{ width: columnWidths.reason }} onClick={() => handleCellClick(history.id, 'reason')}>
                  {renderEditableCell(history, 'reason', history.reason)}
                </TableCell>
                <TableCell sx={{ width: columnWidths.status }} onClick={() => handleCellClick(history.id, 'status')}>
                  {renderEditableCell(history, 'status', history.status === 'active' ? 'ÏÇ¨Ïö©Ï§ë' : 'Ï¢ÖÎ£å', statusOptions)}
                </TableCell>
                <TableCell sx={{ width: columnWidths.startDate }} onClick={() => handleCellClick(history.id, 'startDate')}>
                  {renderEditableCell(history, 'startDate', history.startDate)}
                </TableCell>
                <TableCell sx={{ width: columnWidths.endDate }} onClick={() => handleCellClick(history.id, 'endDate')}>
                  {renderEditableCell(history, 'endDate', history.endDate)}
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>

      {/* ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò - ÌïòÎã® Í≥†Ï†ï */}
      <Box
        sx={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          mt: 'auto',
          pt: 2,
          px: 2,
          borderTop: '1px solid',
          borderColor: 'divider',
          backgroundColor: 'background.paper',
          position: 'sticky',
          bottom: 0
        }}
      >
        <Typography variant="body2" color="text.secondary">
          {userHistories.length > 0
            ? `${startIndex + 1}-${Math.min(endIndex, userHistories.length)} of ${userHistories.length}`
            : '0-0 of 0'}
        </Typography>
        {totalPages > 1 && (
          <Pagination
            count={totalPages}
            page={currentPage}
            onChange={handlePageChange}
            color="primary"
            size="small"
            showFirstButton
            showLastButton
            sx={{
              '& .MuiPaginationItem-root': {
                fontSize: '0.875rem',
                minWidth: '32px',
                height: '32px',
                borderRadius: '4px'
              },
              '& .MuiPaginationItem-page.Mui-selected': {
                backgroundColor: 'primary.main',
                color: 'white !important',
                borderRadius: '4px',
                fontWeight: 500,
                '&:hover': {
                  backgroundColor: 'primary.dark',
                  color: 'white !important'
                }
              },
              '& .MuiPaginationItem-page': {
                borderRadius: '4px',
                '&:hover': {
                  backgroundColor: 'grey.100'
                }
              }
            }}
          />
        )}
      </Box>

      {/* Í≤ΩÍ≥† Î©îÏãúÏßÄ */}
      {statusWarning && (
        <Alert
          severity="warning"
          sx={{
            mt: 2,
            mx: 3,
            mb: 2,
            animation: 'fadeIn 0.3s ease-in'
          }}
        >
          {statusWarning}
        </Alert>
      )}
    </Box>
  );
});

UserHistoryTab.displayName = 'UserHistoryTab';

// Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Ïù∏ÌÑ∞ÌéòÏù¥Ïä§
interface MaintenanceHistory {
  id: string;
  registrationDate: string;
  type: 'purchase' | 'maintenance' | 'upgrade' | 'renewal';
  content: string;
  vendor: string;
  amount: number;
  registrant: string;
  status: string;
  startDate: string;
  completionDate: string;
}

// Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• ÌÉ≠ Ïª¥Ìè¨ÎÑåÌä∏
const PurchaseMaintenanceTab = memo(({
  purchaseHistory,
  historyTypes,
  onAddPurchaseHistory,
  editingPurchaseHistoryId,
  editingPurchaseHistoryData,
  onEditPurchaseHistory,
  onSavePurchaseHistoryEdit,
  onCancelPurchaseHistoryEdit,
  onDeletePurchaseHistory,
  onEditPurchaseHistoryDataChange
}: {
  purchaseHistory: any[];
  historyTypes: string[];
  onAddPurchaseHistory: (item: any) => void;
  editingPurchaseHistoryId: number | null;
  editingPurchaseHistoryData: any;
  onEditPurchaseHistory: (id: number, data: any) => void;
  onSavePurchaseHistoryEdit: () => void;
  onCancelPurchaseHistoryEdit: () => void;
  onDeletePurchaseHistory: (id: number) => void;
  onEditPurchaseHistoryDataChange: (data: any) => void;
}) => {
  // ÏÑ§Î™ÖÏùÑ Í∏∞Î∞òÏúºÎ°ú Ïù¥Î†• ÌÉÄÏûÖ Í≤∞Ï†ï
  const getHistoryType = (description: string): 'purchase' | 'maintenance' | 'upgrade' | 'renewal' => {
    if (description.includes('Ïú†ÏßÄÎ≥¥Ïàò')) return 'maintenance';
    if (description.includes('ÏóÖÍ∑∏Î†àÏù¥Îìú')) return 'upgrade';
    if (description.includes('Í∞±Ïã†') || description.includes('Ïó∞Ïû•')) return 'renewal';
    return 'purchase';
  };

  // memoÏóêÏÑú ÏôÑÎ£åÏùº Ï∂îÏ∂úÌïòÎäî Ìï®Ïàò
  const extractCompletionDate = (memo: string): string => {
    if (!memo) return '';
    const match = memo.match(/ÏôÑÎ£åÏùº:\s*([^\|]*)/);
    return match ? match[1].trim() : '';
  };

  // DBÏóêÏÑú Î°úÎìúÎêú Íµ¨Îß§Ïù¥Î†•ÏùÑ MaintenanceHistory ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
  const dbHistories: MaintenanceHistory[] = purchaseHistory.map((item, index) => {
    const uniqueId = item.id ? item.id.toString() : `temp_${Date.now()}_${index}`;
    const completionDateFromMemo = extractCompletionDate(item.memo || '');

    return {
      id: uniqueId,
      registrationDate: item.registrationDate || item.purchaseDate || '',
      type: getHistoryType(item.description || ''),
      content: item.description || '',
      vendor: item.supplier || '',
      amount: parseFloat(item.price) || 0,
      registrant: 'ÏãúÏä§ÌÖú',
      status: item.status || 'ÏßÑÌñâÏ§ë',
      startDate: item.purchaseDate || '',
      completionDate: completionDateFromMemo || (item.status === 'ÏôÑÎ£å' ? item.purchaseDate || '' : '')
    };
  });

  console.log('üîç PurchaseMaintenanceTab - Îç∞Ïù¥ÌÑ∞ ÌôïÏù∏:');
  console.log('  - purchaseHistory.length:', purchaseHistory.length);
  console.log('  - dbHistories.length:', dbHistories.length);
  console.log('  - purchaseHistory Îç∞Ïù¥ÌÑ∞:', purchaseHistory);

  // Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î•º ÏÇ¨Ïö©ÌïòÎêò, DB Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ Îπà Î∞∞Ïó¥ ÏÇ¨Ïö©
  const maintenanceHistories: MaintenanceHistory[] = dbHistories.length > 0 ? dbHistories : [];

  console.log('  - ÏµúÏ¢Ö ÏÇ¨Ïö©Ìï† Îç∞Ïù¥ÌÑ∞:', maintenanceHistories.length + 'Í∞ú');

  // purchaseHistory Î≥ÄÍ≤ΩÏãú Î°úÍ∑∏ Ï∂úÎ†•
  React.useEffect(() => {
    console.log('üîÑ PurchaseMaintenanceTab - purchaseHistory Î≥ÄÍ≤ΩÎê®:', purchaseHistory.length + 'Í∞ú');
    console.log('   Î≥ÄÍ≤ΩÎêú Îç∞Ïù¥ÌÑ∞:', purchaseHistory);
    console.log('   Î≥ÄÌôòÎêú maintenanceHistories:', dbHistories.length + 'Í∞ú');
    console.log('   maintenanceHistories Îç∞Ïù¥ÌÑ∞:', dbHistories);
  }, [purchaseHistory]);

  // Îçî ÎßéÏùÄ ÏÉòÌîå Îç∞Ïù¥ÌÑ∞Î°ú ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò ÌÖåÏä§Ìä∏ (Ï∞∏Í≥†Ïö© - Îçî Ïù¥ÏÉÅ ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùå)
  const [fallbackHistories] = useState<MaintenanceHistory[]>([
    {
      id: '1',
      registrationDate: '2024-01-15',
      type: 'purchase',
      content: 'Microsoft Office 365 Business Premium ÎùºÏù¥ÏÑ†Ïä§',
      vendor: 'Microsoft',
      amount: 1200000,
      registrant: 'ÍπÄÏ≤†Ïàò',
      status: 'ÏôÑÎ£å',
      startDate: '2024-01-10',
      completionDate: '2024-01-15'
    },
    {
      id: '2',
      registrationDate: '2024-06-20',
      type: 'maintenance',
      content: 'Adobe Creative Suite Ïú†ÏßÄÎ≥¥Ïàò Ïó∞Ïû•',
      vendor: 'Adobe',
      amount: 800000,
      registrant: 'Ïù¥ÏòÅÌù¨',
      status: 'ÏôÑÎ£å',
      startDate: '2024-06-15',
      completionDate: '2024-06-20'
    },
    {
      id: '3',
      registrationDate: '2024-08-01',
      type: 'upgrade',
      content: 'Slack Business+ ÌîåÎûú ÏóÖÍ∑∏Î†àÏù¥Îìú',
      vendor: 'Slack',
      amount: 500000,
      registrant: 'Î∞ïÎØºÏàò',
      status: 'ÏôÑÎ£å',
      startDate: '2024-08-01',
      completionDate: '2024-08-01'
    },
    {
      id: '4',
      registrationDate: '2024-08-05',
      type: 'renewal',
      content: 'Zoom Pro ÎùºÏù¥ÏÑ†Ïä§ Í∞±Ïã†',
      vendor: 'Zoom',
      amount: 300000,
      registrant: 'ÏµúÏùÄÏßÄ',
      status: 'ÏôÑÎ£å',
      startDate: '2024-08-03',
      completionDate: '2024-08-05'
    },
    {
      id: '5',
      registrationDate: '2024-08-10',
      type: 'purchase',
      content: 'Figma Professional ÌåÄ ÎùºÏù¥ÏÑ†Ïä§',
      vendor: 'Figma',
      amount: 450000,
      registrant: 'Ï†ïÌòÑÏö∞',
      status: 'ÏôÑÎ£å',
      startDate: '2024-08-08',
      completionDate: '2024-08-10'
    },
    {
      id: '6',
      registrationDate: '2024-08-15',
      type: 'maintenance',
      content: 'Jira Software Ïú†ÏßÄÎ≥¥Ïàò',
      vendor: 'Atlassian',
      amount: 600000,
      registrant: 'Í∞ïÏòàÎ¶∞',
      status: 'ÏßÑÌñâÏ§ë',
      startDate: '2024-08-14',
      completionDate: ''
    },
    {
      id: '7',
      registrationDate: '2024-08-20',
      type: 'upgrade',
      content: 'GitHub Enterprise ÌîåÎûú ÏóÖÍ∑∏Î†àÏù¥Îìú',
      vendor: 'GitHub',
      amount: 900000,
      registrant: 'ÏÜ°ÏßÄÌõà',
      status: 'ÏôÑÎ£å',
      startDate: '2024-08-20',
      completionDate: '2024-08-20'
    },
    {
      id: '8',
      registrationDate: '2024-08-22',
      type: 'purchase',
      content: 'Notion Team ÏõåÌÅ¨Ïä§ÌéòÏù¥Ïä§',
      vendor: 'Notion',
      amount: 200000,
      registrant: 'ÍπÄÏÜåÏòÅ',
      status: 'ÏôÑÎ£å',
      startDate: '2024-08-20',
      completionDate: '2024-08-22'
    },
    {
      id: '9',
      registrationDate: '2024-08-24',
      type: 'renewal',
      content: 'Dropbox Business ÎùºÏù¥ÏÑ†Ïä§ Í∞±Ïã†',
      vendor: 'Dropbox',
      amount: 350000,
      registrant: 'Ïù¥ÎèôÌòÑ',
      status: 'ÏßÑÌñâÏ§ë',
      startDate: '2024-08-23',
      completionDate: ''
    }
  ]);

  const [selectedRows, setSelectedRows] = useState<string[]>([]);
  const [editingCell, setEditingCell] = useState<{ id: string; field: string } | null>(null);

  // ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò ÏÉÅÌÉú
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage] = useState(7);

  // Ïã†Í∑úÌñâ(ÏùåÏàò ID)ÏùÑ Îß® ÏúÑÎ°ú, Í∏∞Ï°¥ Ìñâ(ÏñëÏàò ID)ÏùÑ Í∑∏ ÏïÑÎûòÏóê Ï†ïÎ†¨
  const sortedMaintenanceHistories = [...maintenanceHistories].sort((a, b) => {
    // Ïã†Í∑úÌñâ(ÏùåÏàò ID)ÏùÑ Îß® ÏúÑÏóê Î∞∞Ïπò
    if (a.id < 0 && b.id >= 0) return -1;
    if (a.id >= 0 && b.id < 0) return 1;
    // Îëò Îã§ Ïã†Í∑úÌñâÏù¥Î©¥ ID Ïó≠Ïàú (Í∞ÄÏû• ÏµúÍ∑º Ï∂îÍ∞ÄÎêú Í≤ÉÏù¥ ÏúÑ)
    if (a.id < 0 && b.id < 0) return b.id - a.id;
    // Îëò Îã§ Í∏∞Ï°¥ ÌñâÏù¥Î©¥ ID Ïó≠Ïàú (ÏµúÏã†Ïù¥ ÏúÑ)
    return b.id - a.id;
  });

  // ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò Í≥ÑÏÇ∞
  const totalPages = Math.ceil(sortedMaintenanceHistories.length / itemsPerPage);
  const startIndex = (currentPage - 1) * itemsPerPage;
  const endIndex = startIndex + itemsPerPage;
  const currentItems = sortedMaintenanceHistories.slice(startIndex, endIndex);

  // ÌéòÏù¥ÏßÄ Î≥ÄÍ≤Ω Ìï∏Îì§Îü¨ (MUI Pagination ÌòïÏãùÏóê ÎßûÍ≤å ÏàòÏ†ï)
  const handlePageChange = (event: React.ChangeEvent<unknown>, page: number) => {
    setCurrentPage(page);
  };

  const handleCellClick = (id: string, field: string) => {
    setEditingCell({ id, field });
  };

  const handleCellBlur = () => {
    setEditingCell(null);
  };

  const handleAddHistory = () => {
    // ÏïàÏ†ÑÌïú Í≥†Ïú† ID ÏÉùÏÑ± (Í∏∞Ï°¥ IDÎì§Í≥º Ï§ëÎ≥µÎêòÏßÄ ÏïäÎèÑÎ°ù)
    const existingIds = purchaseHistory.map(item => item.id || 0);
    const maxId = existingIds.length > 0 ? Math.max(...existingIds) : 0;
    const newId = Math.max(maxId + 1, Date.now());

    const newPurchaseHistory = {
      id: newId,
      purchaseDate: new Date().toISOString().split('T')[0],
      supplier: '',
      price: '0',
      quantity: 1,
      contractNumber: '',
      description: '',
      status: 'ÏßÑÌñâÏ§ë',
      memo: '',
      registrationDate: new Date().toISOString().split('T')[0]
    };

    console.log('üîÑ ÏÉà Íµ¨Îß§Ïù¥Î†• Ï∂îÍ∞Ä:', newPurchaseHistory);
    console.log('   ÌòÑÏû¨ Ïù¥Î†• Ïàò:', purchaseHistory.length);

    onAddPurchaseHistory(newPurchaseHistory);

    // ÏÉà Ìï≠Î™© Ï∂îÍ∞Ä ÌõÑ Ï≤´ Î≤àÏß∏ ÌéòÏù¥ÏßÄÎ°ú Ïù¥Îèô
    setCurrentPage(1);
  };

  const handleDeleteSelected = () => {
    selectedRows.forEach(id => {
      const numericId = parseInt(id);
      if (!isNaN(numericId)) {
        onDeletePurchaseHistory(numericId);
      }
    });
    setSelectedRows([]);
  };

  const handleEditHistory = (id: string, field: keyof MaintenanceHistory, value: string | number) => {
    // Ìé∏ÏßëÎêú ÎÇ¥Ïö©ÏùÑ purchaseHistory ÌòïÏãùÏúºÎ°ú Î≥ÄÌôòÌïòÏó¨ Î∂ÄÎ™® Ïª¥Ìè¨ÎÑåÌä∏Ïóê Ï†ÑÎã¨
    const purchaseHistoryItem = purchaseHistory.find(item => item.id?.toString() === id);
    if (purchaseHistoryItem) {
      const updatedItem = { ...purchaseHistoryItem };

      // MaintenanceHistory ÌïÑÎìúÎ•º PurchaseHistory ÌïÑÎìúÎ°ú Îß§Ìïë
      switch (field) {
        case 'content':
          updatedItem.description = value as string;
          break;
        case 'vendor':
          updatedItem.supplier = value as string;
          break;
        case 'amount':
          updatedItem.price = value.toString();
          break;
        case 'startDate':
          updatedItem.purchaseDate = value as string;
          break;
        case 'status':
          updatedItem.status = value as string;
          break;
        case 'registrationDate':
          updatedItem.registrationDate = value as string;
          break;
        case 'completionDate':
          // completionDateÎäî memo ÌïÑÎìúÏóê Ï†ÄÏû•ÌïòÍ±∞ÎÇò Î≥ÑÎèÑ Ï≤òÎ¶¨
          updatedItem.memo = `ÏôÑÎ£åÏùº: ${value}${updatedItem.memo ? ' | ' + updatedItem.memo.replace(/ÏôÑÎ£åÏùº: [^\|]*(\|)?/g, '').trim() : ''}`;
          break;
      }

      // Î∂ÄÎ™® Ïª¥Ìè¨ÎÑåÌä∏Ïùò purchaseHistory ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
      const numericId = parseInt(id);
      if (!isNaN(numericId)) {
        onEditPurchaseHistory(numericId, updatedItem);
      }
    }
  };

  const handleSelectRow = (id: string) => {
    if (selectedRows.includes(id)) {
      setSelectedRows(selectedRows.filter((rowId) => rowId !== id));
    } else {
      setSelectedRows([...selectedRows, id]);
    }
  };

  const handleSelectAll = (event: React.ChangeEvent<HTMLInputElement>) => {
    if (event.target.checked) {
      setSelectedRows(maintenanceHistories.map((h) => h.id));
    } else {
      setSelectedRows([]);
    }
  };

  const getTypeColor = (type: string) => {
    switch (type) {
      case 'purchase':
        return { backgroundColor: '#E3F2FD', color: '#000000' }; // ÌååÏä§ÌÖî Î∏îÎ£®
      case 'maintenance':
        return { backgroundColor: '#E8F5E8', color: '#000000' }; // ÌååÏä§ÌÖî Í∑∏Î¶∞
      case 'upgrade':
        return { backgroundColor: '#FFF3E0', color: '#000000' }; // ÌååÏä§ÌÖî Ïò§Î†åÏßÄ
      case 'renewal':
        return { backgroundColor: '#F3E5F5', color: '#000000' }; // ÌååÏä§ÌÖî ÌçºÌîå
      default:
        return { backgroundColor: '#F5F5F5', color: '#000000' }; // Ïó∞Ìïú Í∑∏Î†àÏù¥
    }
  };

  const getTypeLabel = (type: string) => {
    switch (type) {
      case 'purchase':
        return 'Íµ¨Îß§';
      case 'maintenance':
        return 'Ïú†ÏßÄÎ≥¥Ïàò';
      case 'upgrade':
        return 'ÏóÖÍ∑∏Î†àÏù¥Îìú';
      case 'renewal':
        return 'Í∞±Ïã†';
      default:
        return 'Í∏∞ÌÉÄ';
    }
  };

  // GROUP017 ÎßàÏä§ÌÑ∞ÏΩîÎìúÏóêÏÑú Í∞ÄÏ†∏Ïò® Ïù¥Î†•Ïú†Ìòï ÏÇ¨Ïö© (fallbackÏúºÎ°ú Í∏∞Î≥∏Í∞í Ï†úÍ≥µ)
  const typeOptions = useMemo(() =>
    historyTypes.length > 0 ? historyTypes : ['Íµ¨Îß§', 'Ïú†ÏßÄÎ≥¥Ïàò', 'ÏóÖÍ∑∏Î†àÏù¥Îìú', 'Í∞±Ïã†'],
    [historyTypes]
  );
  const statusOptions = useMemo(() => ['ÏßÑÌñâÏ§ë', 'ÏôÑÎ£å', 'ÎßåÎ£å', 'Ìï¥ÏßÄ'], []);
  const statusColors: Record<string, string> = useMemo(() => ({
    ÏßÑÌñâÏ§ë: 'primary',
    ÏôÑÎ£å: 'success',
    ÎßåÎ£å: 'warning',
    Ìï¥ÏßÄ: 'error'
  }), []);

  // Ïª¨Îüº ÎÑàÎπÑ Î∞è ÎÜíÏù¥ Ï†ïÏùò (Îì±Î°ùÏûê, ÏÉÅÌÉú Ïª¨Îüº Ï†úÍ±∞)
  const columnWidths = useMemo(() => ({
    checkbox: 50,
    no: 60,
    type: 120,
    content: 300,
    vendor: 160,
    amount: 130,
    startDate: 110,
    completionDate: 110
  }), []);

  const cellHeight = 56;

  // ÎÇ†Ïßú ÌëúÏãú ÌòïÏãù Î≥ÄÌôò (YYYY-MM-DD -> YYYY.MM.DD)
  const formatDisplayDate = (dateStr: string): string => {
    if (!dateStr) return '';
    // YYYY-MM-DD ÌòïÏãùÏùÑ YYYY.MM.DDÎ°ú Î≥ÄÌôò
    return dateStr.replace(/-/g, '.');
  };

  // Ìé∏Ïßë Í∞ÄÎä•Ìïú ÏÖÄ Î†åÎçîÎßÅ
  const renderEditableCell = (history: MaintenanceHistory, field: string, value: string | number, options?: string[]) => {
    const isEditing = editingCell?.id === history.id && editingCell?.field === field;
    const fieldWidth = columnWidths[field as keyof typeof columnWidths] || 100;

    if (isEditing) {
      if (options) {
        return (
          <Select
            value={value}
            onChange={(e) => {
              const newValue = e.target.value;
              if (field === 'type') {
                const typeMapping: Record<string, string> = {
                  Íµ¨Îß§: 'purchase',
                  Ïú†ÏßÄÎ≥¥Ïàò: 'maintenance',
                  ÏóÖÍ∑∏Î†àÏù¥Îìú: 'upgrade',
                  Í∞±Ïã†: 'renewal'
                };
                handleEditHistory(history.id, 'type', typeMapping[newValue] || newValue);
              } else {
                handleEditHistory(history.id, field as keyof MaintenanceHistory, newValue);
              }
            }}
            onBlur={handleCellBlur}
            size="small"
            sx={{ width: '100%', minWidth: fieldWidth }}
            autoFocus
          >
            {options.map((option) => (
              <MenuItem key={option} value={option}>
                {option}
              </MenuItem>
            ))}
          </Select>
        );
      } else if (field === 'startDate' || field === 'completionDate') {
        // ÎÇ†Ïßú ÌïÑÎìúÎäî date type input ÏÇ¨Ïö©
        return (
          <TextField
            type="date"
            value={value || ''}
            onChange={(e) => handleEditHistory(history.id, field as keyof MaintenanceHistory, e.target.value)}
            onBlur={handleCellBlur}
            size="small"
            sx={{
              width: '100%',
              minWidth: fieldWidth,
              '& input': {
                fontSize: '13px',
                padding: '8px 12px'
              }
            }}
            InputLabelProps={{
              shrink: true,
            }}
            autoFocus
          />
        );
      } else {
        return (
          <TextField
            value={value}
            onChange={(e) => handleEditHistory(history.id, field as keyof MaintenanceHistory, e.target.value)}
            onBlur={handleCellBlur}
            size="small"
            sx={{ width: '100%', minWidth: fieldWidth }}
            autoFocus
          />
        );
      }
    }

    return (
      <Box
        sx={{
          width: '100%',
          minWidth: fieldWidth,
          padding: '8px 12px',
          cursor: 'text',
          '&:hover': { backgroundColor: 'action.hover' }
        }}
      >
        {field === 'type' ? (
          <Chip
            label={getTypeLabel(value as string)}
            size="small"
            sx={{
              ...getTypeColor(value as string),
              fontSize: '12px',
              fontWeight: 500,
              borderRadius: '12px',
              height: '24px',
              minWidth: '60px'
            }}
          />
        ) : field === 'status' ? (
          <Chip
            label={value}
            size="small"
            color={statusColors[value as string] as any}
            sx={{
              fontSize: '12px',
              fontWeight: 500,
              borderRadius: '12px',
              height: '24px',
              minWidth: '60px'
            }}
          />
        ) : field === 'amount' ? (
          <Typography variant="body2" sx={{ fontSize: '13px' }}>
            {typeof value === 'number' ? `${value.toLocaleString()}Ïõê` : value || '-'}
          </Typography>
        ) : field === 'startDate' || field === 'completionDate' ? (
          <Typography variant="body2" sx={{ fontSize: '13px', color: value ? 'text.primary' : 'text.secondary' }}>
            {value ? formatDisplayDate(value as string) : '-'}
          </Typography>
        ) : (
          <Typography variant="body2" sx={{ fontSize: '13px' }}>
            {value || '-'}
          </Typography>
        )}
      </Box>
    );
  };

  return (
    <Box sx={{ height: '650px', display: 'flex', flexDirection: 'column', p: 3 }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
        <Typography variant="h6" sx={{ fontSize: '16px', fontWeight: 600 }}>
          Íµ¨Îß§/Ïú†ÏßÄÎ≥¥Ïàò Ïù¥Î†•
        </Typography>
        <Box sx={{ display: 'flex', gap: 1 }}>
          <Button variant="outlined" color="error" onClick={handleDeleteSelected} disabled={selectedRows.length === 0} size="small">
            ÏÇ≠Ï†ú({selectedRows.length})
          </Button>
          <Button variant="contained" onClick={handleAddHistory} size="small" sx={{ fontSize: '12px' }}>
            Ï∂îÍ∞Ä
          </Button>
        </Box>
      </Box>

      <TableContainer
        sx={{
          flex: 1,
          overflowY: 'auto',
          overflowX: 'hidden',
          '& .MuiTable-root': {
            minWidth: 'auto'
          }
        }}
      >
        <Table size="small">
          <TableHead>
            <TableRow sx={{ backgroundColor: 'grey.50' }}>
              <TableCell padding="checkbox" sx={{ width: columnWidths.checkbox }}>
                <Checkbox
                  checked={selectedRows.length === maintenanceHistories.length && maintenanceHistories.length > 0}
                  onChange={handleSelectAll}
                  color="primary"
                  size="small"
                  sx={{
                    transform: 'scale(0.7)',
                    '&.Mui-checked': {
                      color: '#1976d2'
                    }
                  }}
                />
              </TableCell>
              <TableCell sx={{ width: columnWidths.no, fontWeight: 600 }}>NO</TableCell>
              <TableCell sx={{ width: columnWidths.type, fontWeight: 600 }}>Ïú†Ìòï</TableCell>
              <TableCell sx={{ width: columnWidths.content, fontWeight: 600 }}>ÎÇ¥Ïö©</TableCell>
              <TableCell sx={{ width: columnWidths.vendor, fontWeight: 600 }}>ÏóÖÏ≤¥</TableCell>
              <TableCell sx={{ width: columnWidths.amount, fontWeight: 600 }}>Í∏àÏï°</TableCell>
              <TableCell sx={{ width: columnWidths.startDate, fontWeight: 600 }}>ÏãúÏûëÏùº</TableCell>
              <TableCell sx={{ width: columnWidths.completionDate, fontWeight: 600 }}>ÏôÑÎ£åÏùº</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {currentItems.map((history, index) => (
              <TableRow
                key={`history_${history.id}_${index}`}
                hover
                sx={{
                  height: cellHeight,
                  '&:hover': { backgroundColor: 'action.hover' }
                }}
              >
                <TableCell padding="checkbox" sx={{ width: columnWidths.checkbox }}>
                  <Checkbox
                    checked={selectedRows.includes(history.id)}
                    onChange={() => handleSelectRow(history.id)}
                    color="primary"
                    size="small"
                    sx={{
                      transform: 'scale(0.7)',
                      '&.Mui-checked': {
                        color: '#1976d2'
                      }
                    }}
                  />
                </TableCell>
                <TableCell sx={{ width: columnWidths.no }}>{sortedMaintenanceHistories.length - startIndex - index}</TableCell>
                <TableCell sx={{ width: columnWidths.type }} onClick={() => handleCellClick(history.id, 'type')}>
                  {renderEditableCell(history, 'type', history.type, typeOptions)}
                </TableCell>
                <TableCell sx={{ width: columnWidths.content }} onClick={() => handleCellClick(history.id, 'content')}>
                  {renderEditableCell(history, 'content', history.content)}
                </TableCell>
                <TableCell sx={{ width: columnWidths.vendor }} onClick={() => handleCellClick(history.id, 'vendor')}>
                  {renderEditableCell(history, 'vendor', history.vendor)}
                </TableCell>
                <TableCell sx={{ width: columnWidths.amount }} onClick={() => handleCellClick(history.id, 'amount')}>
                  {renderEditableCell(history, 'amount', history.amount)}
                </TableCell>
                <TableCell sx={{ width: columnWidths.startDate }} onClick={() => handleCellClick(history.id, 'startDate')}>
                  {renderEditableCell(history, 'startDate', history.startDate)}
                </TableCell>
                <TableCell sx={{ width: columnWidths.completionDate }} onClick={() => handleCellClick(history.id, 'completionDate')}>
                  {renderEditableCell(history, 'completionDate', history.completionDate)}
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>

      {/* ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò - ÌïòÎã® Í≥†Ï†ï */}
      <Box
        sx={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          mt: 'auto',
          pt: 2,
          px: 2,
          borderTop: '1px solid',
          borderColor: 'divider',
          backgroundColor: 'background.paper',
          position: 'sticky',
          bottom: 0
        }}
      >
        <Typography variant="body2" color="text.secondary">
          {maintenanceHistories.length > 0
            ? `${startIndex + 1}-${Math.min(endIndex, maintenanceHistories.length)} of ${maintenanceHistories.length}`
            : '0-0 of 0'}
        </Typography>
        {totalPages > 1 && (
          <Pagination
            count={totalPages}
            page={currentPage}
            onChange={handlePageChange}
            color="primary"
            size="small"
            showFirstButton
            showLastButton
            sx={{
              '& .MuiPaginationItem-root': {
                fontSize: '0.875rem',
                minWidth: '32px',
                height: '32px',
                borderRadius: '4px'
              },
              '& .MuiPaginationItem-page.Mui-selected': {
                backgroundColor: 'primary.main',
                color: 'white !important',
                borderRadius: '4px',
                fontWeight: 500,
                '&:hover': {
                  backgroundColor: 'primary.dark',
                  color: 'white !important'
                }
              },
              '& .MuiPaginationItem-page': {
                borderRadius: '4px',
                '&:hover': {
                  backgroundColor: 'grey.100'
                }
              }
            }}
          />
        )}
      </Box>
    </Box>
  );
});

PurchaseMaintenanceTab.displayName = 'PurchaseMaintenanceTab';

// Î©îÏù∏ SoftwareEditDialog Ïª¥Ìè¨ÎÑåÌä∏
interface SoftwareEditDialogProps {
  open: boolean;
  onClose: () => void;
  task: TaskTableData | null;
  onSave: (task: TaskTableData) => void;
  assignees: string[];
  assigneeAvatars: Record<string, string>;
  statusOptions: SoftwareStatus[];
  statusColors: Record<SoftwareStatus, any>;
}

const SoftwareEditDialog = memo(
  ({ open, onClose, task, onSave, assignees, assigneeAvatars, statusOptions, statusColors }: SoftwareEditDialogProps) => {
    // ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ
    // const { renderCount, logStats } = usePerformanceMonitor('TaskEditDialog');

    // Supabase ÌõÖ ÏÇ¨Ïö©
    const { createSoftware, updateSoftware } = useSupabaseSoftware();

    // ÏÑ∏ÏÖò Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
    const { data: session } = useSession();

    // GROUP015 ÏÜåÌîÑÌä∏Ïõ®Ïñ¥Î∂ÑÎ•ò ÌõÖ ÏÇ¨Ïö©
    const { softwareCategories, loading: categoriesLoading, error: categoriesError } = useGroup015();
    const { historyTypes, loading: historyTypesLoading, error: historyTypesError } = useGroup017();

    // Users ÌõÖ ÏÇ¨Ïö©
    const { users, loading: usersLoading, error: usersError } = useSupabaseUsers();

    // ÌòÑÏû¨ Î°úÍ∑∏Ïù∏Ìïú ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥
    const currentUser = React.useMemo(() => {
      if (!session?.user?.email || users.length === 0) return null;
      return users.find((u) => u.email === session.user.email);
    }, [session, users]);

    // GROUP002 ÏÉÅÌÉú ÌõÖ ÏÇ¨Ïö©
    const { statusOptions: masterStatusOptions, loading: statusLoading, error: statusError } = useGroup002();

    // GROUP016 ÎùºÏù¥ÏÑºÏä§ Ïú†Ìòï ÌõÖ ÏÇ¨Ïö©
    const { licenseTypes: masterLicenseTypes, loading: licenseLoading, error: licenseError } = useGroup016();

    // ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ ÏÇ¨Ïö©ÏûêÏù¥Î†• ÌõÖ ÏÇ¨Ïö©
    const { saveUserHistories, getUserHistories } = useSupabaseSoftwareUser();
    // ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• ÌõÖ ÏÇ¨Ïö©
    const { savePurchaseHistories, getPurchaseHistories } = useSupabaseSoftwareHistory();

    // ÌîºÎìúÎ∞± ÌõÖ
    const {
      feedbacks,
      loading: feedbackLoading,
      error: feedbackError,
      addFeedback,
      updateFeedback,
      deleteFeedback
    } = useSupabaseFeedback(PAGE_IDENTIFIERS.SOFTWARE, task?.id?.toString());

    const [editTab, setEditTab] = useState(0);
    const [draggedItemId, setDraggedItemId] = useState<number | null>(null);
    const [softwareState, dispatch] = useReducer(editSoftwareReducer, {
      softwareName: '',
      description: '',
      softwareCategory: '',
      spec: '',
      status: 'ÎåÄÍ∏∞',
      startDate: '',
      completedDate: '',
      currentUser: '',
      assignee: '',
      team: '',
      solutionProvider: '',
      userCount: 0,
      licenseType: '',
      licenseKey: '',
      registrationDate: '',
      code: ''
    });

    // ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ Î∂ÑÎ•ò ÏòµÏÖò - GROUP015ÏóêÏÑú ÎèôÏ†ÅÏúºÎ°ú Î°úÎìúÎê® (softwareCategories Î≥ÄÏàòÎäî useGroup015 ÌõÖÏóêÏÑú Ï†úÍ≥µ)

    // ÎùºÏù¥ÏÑºÏä§ Ïú†Ìòï ÏòµÏÖò (Î©îÎ™®Ïù¥Ï†úÏù¥ÏÖò)
    const licenseTypes = useMemo(() => [
      'ÏÉÅÏö© ÎùºÏù¥ÏÑºÏä§', 'Ïò§ÌîàÏÜåÏä§', 'ÌîÑÎ¶¨Ïõ®Ïñ¥', 'ÏÖ∞Ïñ¥Ïõ®Ïñ¥',
      'ÏÇ¨Ïù¥Ìä∏ ÎùºÏù¥ÏÑºÏä§', 'Î≥ºÎ•® ÎùºÏù¥ÏÑºÏä§', 'Íµ¨ÎèÖÌòï', 'ÏûÑÎåÄÌòï'
    ], []);

    // ÏΩîÎìú ÏûêÎèô ÏÉùÏÑ± Ìï®Ïàò (IT-SW-YY-NNN ÌòïÏãù)
    const generateSoftwareCode = useCallback(async () => {
      const currentYear = new Date().getFullYear();
      const currentYearStr = currentYear.toString().slice(-2); // Ïó∞ÎèÑ Îí§ 2ÏûêÎ¶¨

      try {
        // SupabaseÏóêÏÑú ÌòÑÏû¨ Ïó∞ÎèÑÏùò ÏµúÎåÄ ÏùºÎ†®Î≤àÌò∏ Ï°∞Ìöå
        const { data, error } = await supabase
          .from('it_software_data')
          .select('code')
          .like('code', `IT-SW-${currentYearStr}-%`)
          .order('code', { ascending: false })
          .limit(1);

        let nextSequence = 1;

        if (data && data.length > 0 && data[0].code) {
          // Í∏∞Ï°¥ ÏΩîÎìúÏóêÏÑú ÏùºÎ†®Î≤àÌò∏ Ï∂îÏ∂ú (IT-SW-25-001 -> 001)
          const lastCode = data[0].code;
          const sequencePart = lastCode.split('-')[3];
          if (sequencePart) {
            nextSequence = parseInt(sequencePart) + 1;
          }
        }

        // ÏùºÎ†®Î≤àÌò∏Î•º 3ÏûêÎ¶¨Î°ú Ìè¨Îß∑ (001, 002, ...)
        const formattedSequence = nextSequence.toString().padStart(3, '0');

        return `IT-SW-${currentYearStr}-${formattedSequence}`;

      } catch (error) {
        console.error('‚ùå ÏΩîÎìú ÏÉùÏÑ± Ï§ë Ïò§Î•ò:', error);
        // Ïò§Î•ò Ïãú ÏûÑÏãú ÏΩîÎìú ÏÉùÏÑ±
        const sequence = String(Date.now()).slice(-3);
        return `IT-SW-${currentYearStr}-${sequence}`;
      }
    }, []);

    // ÌòÑÏû¨ ÎÇ†Ïßú ÏÉùÏÑ± Ìï®Ïàò
    const getCurrentDate = useCallback(() => {
      const today = new Date();
      return today.toISOString().split('T')[0]; // YYYY-MM-DD ÌòïÏãù
    }, []);

    // Software Î≥ÄÍ≤Ω Ïãú ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
    React.useEffect(() => {
      if (task) {
        dispatch({ type: 'SET_SOFTWARE', software: task });
      } else if (open) {
        // ÏÉà Software ÏÉùÏÑ± Ïãú ÏûêÎèôÏúºÎ°ú ÏΩîÎìúÏôÄ Îì±Î°ùÏùº ÏÑ§Ï†ï
        const initializeNewSoftware = async () => {
          try {
            console.log('üÜï ÏÉà ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ ÏΩîÎìú ÏÉùÏÑ± ÏãúÏûë...');
            const newCode = await generateSoftwareCode();
            const newRegistrationDate = getCurrentDate();
            console.log('‚úÖ ÏÉùÏÑ±Îêú ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ ÏΩîÎìú:', newCode);
            dispatch({ type: 'INIT_NEW_SOFTWARE', code: newCode, registrationDate: newRegistrationDate });
          } catch (error) {
            console.error('‚ùå ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ ÏΩîÎìú ÏÉùÏÑ± Ïã§Ìå®:', error);
            // Ïã§Ìå® Ïãú ÏûÑÏãú ÏΩîÎìú ÏÇ¨Ïö©
            const currentYear = new Date().getFullYear().toString().slice(-2);
            const tempCode = `IT-SW-${currentYear}-TMP`;
            const newRegistrationDate = getCurrentDate();
            dispatch({ type: 'INIT_NEW_SOFTWARE', code: tempCode, registrationDate: newRegistrationDate });
          }
        };

        initializeNewSoftware();
      }
    }, [task, open]);

    // ÏÉà ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ ÏÉùÏÑ± Ïãú ÌåÄÍ≥º Îã¥ÎãπÏûê ÏûêÎèô ÏÑ§Ï†ï
    React.useEffect(() => {
      if (!task && open && currentUser) {
        // ÌåÄÍ≥º Îã¥ÎãπÏûêÍ∞Ä ÎπÑÏñ¥ÏûàÏùÑ ÎïåÎßå ÏÑ§Ï†ï
        if (!softwareState.team && currentUser.department) {
          dispatch({ type: 'SET_FIELD', field: 'team', value: currentUser.department });
        }
        if (!softwareState.assignee && currentUser.user_name) {
          dispatch({ type: 'SET_FIELD', field: 'assignee', value: currentUser.user_name });
        }
      }
    }, [task, open, currentUser, softwareState.team, softwareState.assignee]);

    // ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ Î°úÍ∑∏ Ï†úÍ±∞ (ÌîÑÎ°úÎçïÏÖò Ï§ÄÎπÑ)
    // useEffect(() => {
    //   if (process.env.NODE_ENV === 'development' && renderCount > 1) {
    //     console.log(`üîÑ TaskEditDialog Î†åÎçîÎßÅ ÌöüÏàò: ${renderCount}`);
    //     if (renderCount % 10 === 0) {
    //       const stats = logStats();
    //       console.log('üìä TaskEditDialog ÏÑ±Îä• ÌÜµÍ≥Ñ:', stats);
    //     }
    //   }
    // }, [renderCount, logStats]);

    // Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏ ÏÉÅÌÉú (Í≥ÑÏ∏µ Íµ¨Ï°∞ ÏßÄÏõê)
    const [checklistItems, setChecklistItems] = useState<
      Array<{
        id: number;
        text: string;
        checked: boolean;
        parentId?: number;
        level: number;
        expanded: boolean;
        status?: string;
        dueDate?: string;
        progressRate?: number;
        assignee?: string;
      }>
    >([]);
    const [newChecklistText, setNewChecklistText] = useState('');
    const [editingChecklistId, setEditingChecklistId] = useState<number | null>(null);
    const [editingChecklistText, setEditingChecklistText] = useState('');

    // ÏΩîÎ©òÌä∏ ÏÉÅÌÉú - feedbacksÏóêÏÑú Î≥ÄÌôò
    const comments = useMemo(() => {
      return feedbacks.map((feedback) => {
        // user_nameÏúºÎ°ú ÏÇ¨Ïö©Ïûê Ï∞æÍ∏∞
        const feedbackUser = users.find((u) => u.user_name === feedback.user_name);

        return {
          id: feedback.id,
          author: feedback.user_name,
          content: feedback.description,
          timestamp: new Date(feedback.created_at).toLocaleString('ko-KR'),
          avatar: feedback.user_profile_image || feedbackUser?.profile_image_url || undefined,
          department: feedback.user_department || feedback.team || feedbackUser?.department || '',
          position: feedback.user_position || feedbackUser?.position || '',
          role: feedback.metadata?.role || feedbackUser?.role || ''
        };
      });
    }, [feedbacks, users]);

    const [newComment, setNewComment] = useState('');
    const [editingCommentId, setEditingCommentId] = useState<string | null>(null);
    const [editingCommentText, setEditingCommentText] = useState('');

    // ÏûêÎ£å ÏÉÅÌÉú
    const [materials, setMaterials] = useState<
      Array<{
        id: number;
        name: string;
        type: string;
        size: string;
        file?: File;
        uploadDate?: string;
      }>
    >([]);
    const [editingMaterialId, setEditingMaterialId] = useState<number | null>(null);
    const [editingMaterialText, setEditingMaterialText] = useState('');

    // ÏÇ¨Ïö©ÏûêÏù¥Î†• ÏÉÅÌÉú (DB Ïó∞Îèô)
    const [currentUserHistories, setCurrentUserHistories] = useState<UserHistory[]>([]);

    // Í∏∞Ï°¥ ÏÇ¨Ïö©ÏûêÏù¥Î†• ÏÉÅÌÉú (Ìò∏ÌôòÏÑ± Ïú†ÏßÄ)
    const [userHistory, setUserHistory] = useState<
      Array<{
        id: number;
        userName: string;
        department: string;
        startDate: string;
        endDate: string;
        status: string;
        memo: string;
        registrationDate: string;
      }>
    >([]);
    const [editingUserHistoryId, setEditingUserHistoryId] = useState<number | null>(null);
    const [editingUserHistoryData, setEditingUserHistoryData] = useState<any>({});

    // Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• ÏÉÅÌÉú
    const [purchaseHistory, setPurchaseHistory] = useState<
      Array<{
        id: number;
        type: string;
        vendor: string;
        amount: string;
        contractDate: string;
        startDate: string;
        endDate: string;
        status: string;
        memo: string;
        registrationDate: string;
      }>
    >([]);
    const [editingPurchaseHistoryId, setEditingPurchaseHistoryId] = useState<number | null>(null);
    const [editingPurchaseHistoryData, setEditingPurchaseHistoryData] = useState<any>({});

    // ÏóêÎü¨ ÏÉÅÌÉú
    const [validationError, setValidationError] = useState<string>('');

    // ÏµúÏ†ÅÌôîÎêú Ìï∏Îì§Îü¨Îì§
    const handleFieldChange = useCallback((field: keyof EditSoftwareState, value: string | number) => {
      dispatch({ type: 'SET_FIELD', field, value });
    }, []);

    const handleTabChange = useCallback((event: React.SyntheticEvent, newValue: number) => {
      setEditTab(newValue);
    }, []);

    const handleSave = useCallback(async () => {
      // Ï†ÄÏû• ÏßÅÏ†ÑÏóê ÌòÑÏû¨ ÏûÖÎ†• Í∞íÎì§ÏùÑ softwareStateÏóê Í∞ïÏ†ú Î∞òÏòÅ
      const getCurrentInputValues = () => {
        if ((window as any).getOverviewTabCurrentValues) {
          return (window as any).getOverviewTabCurrentValues();
        }
        return { softwareName: softwareState.softwareName, description: softwareState.description };
      };

      const currentValues = getCurrentInputValues();

      // ÌïÑÏàò ÏûÖÎ†• Í≤ÄÏ¶ù
      if (!currentValues.softwareName.trim()) {
        setValidationError('ÏÜåÌîÑÌä∏Ïõ®Ïñ¥Î™ÖÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
        return;
      }

      if (!softwareState.assignee.trim()) {
        setValidationError('Îã¥ÎãπÏûêÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
        return;
      }

      if (!softwareState.softwareCategory || !softwareState.softwareCategory.trim()) {
        setValidationError('ÏÜåÌîÑÌä∏Ïõ®Ïñ¥Î∂ÑÎ•òÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
        return;
      }

      if (!softwareState.solutionProvider || !softwareState.solutionProvider.trim()) {
        setValidationError('ÏÜîÎ£®ÏÖòÏóÖÏ≤¥Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
        return;
      }

      if (!softwareState.licenseType || !softwareState.licenseType.trim()) {
        setValidationError('ÎùºÏù¥ÏÑºÏä§Ïú†ÌòïÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
        return;
      }

      // ÏóêÎü¨ Ï¥àÍ∏∞Ìôî
      setValidationError('');

      try {
        console.log('üíæ ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• ÏãúÏûë...');

        // SupabaseÏóê Ï†ÄÏû•Ìï† Îç∞Ïù¥ÌÑ∞ Ï§ÄÎπÑ
        const softwareData: Partial<SoftwareData> = {
          software_name: currentValues.softwareName?.trim() || '',
          work_content: currentValues.softwareName?.trim() || '',
          description: currentValues.description?.trim() || '',
          software_category: softwareState.softwareCategory?.trim() || '',
          spec: softwareState.spec?.trim() || '',
          status: softwareState.status || 'ÎåÄÍ∏∞',
          assignee: softwareState.assignee?.trim() || '',
          current_users: softwareState.currentUser?.trim() || '',
          solution_provider: softwareState.solutionProvider?.trim() || '',
          user_count: Number(softwareState.userCount) || 0,
          license_type: softwareState.licenseType?.trim() || '',
          license_key: softwareState.licenseKey?.trim() || '',
          start_date: softwareState.startDate ?
            (softwareState.startDate.includes('T') ? softwareState.startDate.split('T')[0] : softwareState.startDate) :
            new Date().toISOString().split('T')[0],
          completed_date: softwareState.completedDate ?
            (softwareState.completedDate.includes('T') ? softwareState.completedDate.split('T')[0] : softwareState.completedDate) :
            null,
          code: softwareState.code?.trim() || '',
          team: softwareState.team?.trim() || '',
          department: 'IT'
        };

        let savedData;

        if (!task || !task.id) {
          // ÏÉà Software ÏÉùÏÑ±
          console.log('üÜï ÏÉà ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ ÏÉùÏÑ±:', softwareData);
          savedData = await createSoftware(softwareData);
        } else {
          // Í∏∞Ï°¥ Software ÏàòÏ†ï
          if (!task.id || task.id <= 0) {
            throw new Error('Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ IDÏûÖÎãàÎã§.');
          }

          console.log('üîÑ ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ ÏàòÏ†ï:', { id: task.id, data: softwareData });
          savedData = await updateSoftware(task.id, softwareData);
        }

        console.log('‚úÖ Supabase Ï†ÄÏû• ÏÑ±Í≥µ:', savedData);

        // ÏÇ¨Ïö©ÏûêÏù¥Î†• Ï†ÄÏû• (data_relation.md Ìå®ÌÑ¥ Ï†ÅÏö©)
        console.log('üîç ÏÇ¨Ïö©ÏûêÏù¥Î†• Ï†ÄÏû• Ï≤¥ÌÅ¨:');
        console.log('  - currentUserHistories.length:', currentUserHistories.length);
        console.log('  - currentUserHistories:', JSON.stringify(currentUserHistories, null, 2));
        console.log('  - savedData:', savedData);
        console.log('  - savedData?.id:', savedData?.id);
        console.log('  - typeof savedData?.id:', typeof savedData?.id);

        if (currentUserHistories.length > 0) {
          if (!savedData?.id) {
            console.error('‚ùå ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ IDÍ∞Ä ÏóÜÏñ¥ÏÑú ÏÇ¨Ïö©ÏûêÏù¥Î†•ÏùÑ Ï†ÄÏû•Ìï† Ïàò ÏóÜÏäµÎãàÎã§.');
            console.error('  savedData Ï†ÑÏ≤¥:', JSON.stringify(savedData, null, 2));
          } else {
            console.log('üíæ ÏÇ¨Ïö©ÏûêÏù¥Î†• Ï†ÄÏû• ÏãúÏûë...', {
              softwareId: savedData.id,
              userCount: currentUserHistories.length,
              users: currentUserHistories
            });

            try {
              const userHistorySaveResult = await saveUserHistories(savedData.id, currentUserHistories);

              if (userHistorySaveResult) {
                console.log('‚úÖ ÏÇ¨Ïö©ÏûêÏù¥Î†• Ï†ÄÏû• ÏÑ±Í≥µ');
              } else {
                console.warn('‚ö†Ô∏è ÏÇ¨Ïö©ÏûêÏù¥Î†• Ï†ÄÏû• Ïã§Ìå® - ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ Îç∞Ïù¥ÌÑ∞Îäî Ï†ÄÏû•Îê®');
              }
            } catch (saveError) {
              console.error('‚ùå ÏÇ¨Ïö©ÏûêÏù¥Î†• Ï†ÄÏû• Ï§ë ÏòàÏô∏ Î∞úÏÉù:', saveError);
            }
          }
        } else {
          console.log('‚ÑπÔ∏è Ï†ÄÏû•Ìï† ÏÇ¨Ïö©ÏûêÏù¥Î†•Ïù¥ ÏóÜÏäµÎãàÎã§.');
        }

        // Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Ï†ÄÏû• (data_relation.md Ìå®ÌÑ¥)
        console.log('üîç Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Ï†ÄÏû• Ï≤¥ÌÅ¨:');
        console.log('  - purchaseHistory.length:', purchaseHistory.length);
        console.log('  - savedData?.id:', savedData?.id);

        if (purchaseHistory.length > 0) {
          if (!savedData?.id) {
            console.error('‚ùå ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ IDÍ∞Ä ÏóÜÏñ¥ÏÑú Íµ¨Îß§Ïù¥Î†•ÏùÑ Ï†ÄÏû•Ìï† Ïàò ÏóÜÏäµÎãàÎã§.');
          } else {
            console.log('üíæ Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Ï†ÄÏû• ÏãúÏûë...', {
              softwareId: savedData.id,
              historyCount: purchaseHistory.length,
              histories: purchaseHistory
            });

            try {
              const purchaseHistorySaveResult = await savePurchaseHistories(savedData.id, purchaseHistory);

              if (purchaseHistorySaveResult) {
                console.log('‚úÖ Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Ï†ÄÏû• ÏÑ±Í≥µ');
              } else {
                console.warn('‚ö†Ô∏è Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Ï†ÄÏû• Ïã§Ìå® - ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ Îç∞Ïù¥ÌÑ∞Îäî Ï†ÄÏû•Îê®');
              }
            } catch (saveError) {
              console.error('‚ùå Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Ï†ÄÏû• Ï§ë ÏòàÏô∏ Î∞úÏÉù:', saveError);
            }
          }
        } else {
          console.log('‚ÑπÔ∏è Ï†ÄÏû•Ìï† Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†•Ïù¥ ÏóÜÏäµÎãàÎã§.');
        }

        // TaskTableData ÌòïÏãùÏúºÎ°ú Î≥ÄÌôòÌïòÏó¨ Î∂ÄÎ™® Ïª¥Ìè¨ÎÑåÌä∏Ïóê Ï†ÑÎã¨
        const resultTask: TaskTableData = {
          id: savedData.id || task?.id || Date.now(),
          no: savedData.no || Date.now(),
          workContent: currentValues.softwareName,
          assignee: softwareState.assignee,
          status: softwareState.status as any,
          code: softwareState.code,
          registrationDate: savedData.registration_date || softwareState.registrationDate,
          startDate: softwareState.startDate || new Date().toISOString().split('T')[0],
          completedDate: softwareState.completedDate,
          description: currentValues.description,
          softwareName: currentValues.softwareName,
          softwareCategory: softwareState.softwareCategory,
          spec: softwareState.spec,
          currentUser: softwareState.currentUser,
          solutionProvider: softwareState.solutionProvider,
          userCount: softwareState.userCount,
          licenseType: softwareState.licenseType,
          licenseKey: softwareState.licenseKey,
          attachments: [],
          team: 'Í∞úÎ∞úÌåÄ' as any,
          department: 'IT' as any
        };

        onSave(resultTask);
        onClose();

      } catch (error: any) {
        console.error('‚ùå ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ Ï†ÄÏû• Ïã§Ìå®:', error);
        setValidationError(error.message || 'Ï†ÄÏû• Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
      }
    }, [task, softwareState, onSave, onClose, createSoftware, updateSoftware]);

    const handleClose = useCallback(() => {
      setEditTab(0);
      dispatch({ type: 'RESET' });
      setChecklistItems([]);
      setMaterials([]);
      setUserHistory([]);
      setPurchaseHistory([]);
      setPurchaseHistoryLoaded(false); // Íµ¨Îß§Ïù¥Î†• Î°úÎìú ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
      setNewComment('');
      setNewChecklistText('');
      setValidationError(''); // ÏóêÎü¨ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
      onClose();
    }, [onClose]);

    // Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏ Ìï∏Îì§Îü¨Îì§
    const handleAddChecklistItem = useCallback(() => {
      if (!newChecklistText.trim()) return;

      const newItem = {
        id: Date.now(),
        text: newChecklistText.trim(),
        checked: false,
        level: 0,
        expanded: true,
        status: 'Í≥ÑÌöçÏ§ë',
        dueDate: '',
        progressRate: 0,
        assignee: 'ÍπÄÏ≤†Ïàò' // Í∏∞Î≥∏ Îã¥ÎãπÏûê
      };

      setChecklistItems((prev) => [...prev, newItem]);
      setNewChecklistText('');
    }, [newChecklistText]);

    const handleEditChecklistItem = useCallback((id: number, text: string) => {
      setEditingChecklistId(id);
      setEditingChecklistText(text);
    }, []);

    const handleSaveEditChecklistItem = useCallback(() => {
      if (!editingChecklistText.trim() || editingChecklistId === null) return;

      setChecklistItems((prev) =>
        prev.map((item) => (item.id === editingChecklistId ? { ...item, text: editingChecklistText.trim() } : item))
      );

      setEditingChecklistId(null);
      setEditingChecklistText('');
    }, [editingChecklistText, editingChecklistId]);

    const handleCancelEditChecklistItem = useCallback(() => {
      setEditingChecklistId(null);
      setEditingChecklistText('');
    }, []);

    const handleDeleteChecklistItem = useCallback((id: number) => {
      setChecklistItems((prev) => {
        // ÏÇ≠Ï†úÌï† Ìï≠Î™©Í≥º Í∑∏ ÌïòÏúÑ Ìï≠Î™©Îì§ÏùÑ Î™®Îëê Ï∞æÍ∏∞
        const findAllChildren = (parentId: number): number[] => {
          const children = prev.filter((item) => item.parentId === parentId).map((item) => item.id);
          const allChildren = [...children];
          children.forEach((childId) => {
            allChildren.push(...findAllChildren(childId));
          });
          return allChildren;
        };

        const toDelete = [id, ...findAllChildren(id)];
        return prev.filter((item) => !toDelete.includes(item.id));
      });
    }, []);

    // ÎìúÎûòÍ∑∏ Ïï§ ÎìúÎ°≠ Ìï∏Îì§Îü¨Îì§
    const handleDragStart = useCallback((e: React.DragEvent, itemId: number) => {
      e.dataTransfer.setData('text/plain', itemId.toString());
      e.dataTransfer.effectAllowed = 'move';
      setDraggedItemId(itemId);
    }, []);

    const handleDragOver = useCallback((e: React.DragEvent) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
    }, []);

    const handleDragEnd = useCallback(() => {
      setDraggedItemId(null);
    }, []);

    const handleDrop = useCallback((e: React.DragEvent, targetId: number) => {
      e.preventDefault();
      const draggedId = parseInt(e.dataTransfer.getData('text/plain'));

      if (draggedId === targetId) return; // ÏûêÍ∏∞ ÏûêÏã†ÏóêÍ≤åÎäî ÎìúÎ°≠ Î∂àÍ∞Ä

      setChecklistItems((prev) => {
        // ÏàúÌôò Ï∞∏Ï°∞ Î∞©ÏßÄ: ÎìúÎûòÍ∑∏Îêú Ìï≠Î™©Ïù¥ ÌÉÄÍ≤üÏùò ÏÉÅÏúÑÏù∏ÏßÄ ÌôïÏù∏
        const isParentOf = (parentId: number, childId: number): boolean => {
          const child = prev.find((item) => item.id === childId);
          if (!child || !child.parentId) return false;
          if (child.parentId === parentId) return true;
          return isParentOf(parentId, child.parentId);
        };

        if (isParentOf(draggedId, targetId)) return prev; // ÏàúÌôò Ï∞∏Ï°∞ Î∞©ÏßÄ

        const target = prev.find((item) => item.id === targetId);
        if (!target) return prev;

        return prev.map((item) => {
          if (item.id === draggedId) {
            return {
              ...item,
              parentId: targetId,
              level: target.level + 1
            };
          }
          return item;
        });
      });

      // ÌÉÄÍ≤ü Ìï≠Î™©ÏùÑ ÏûêÎèôÏúºÎ°ú ÌéºÏπòÍ∏∞
      setChecklistItems((prev) => prev.map((item) => (item.id === targetId ? { ...item, expanded: true } : item)));

      // ÎìúÎûòÍ∑∏ ÏôÑÎ£å ÌõÑ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
      setDraggedItemId(null);
    }, []);

    // Ï†ëÍ∏∞/ÌéºÏπòÍ∏∞ Ìï∏Îì§Îü¨
    const handleToggleExpanded = useCallback((id: number) => {
      setChecklistItems((prev) => prev.map((item) => (item.id === id ? { ...item, expanded: !item.expanded } : item)));
    }, []);

    const handleToggleChecklistItem = useCallback((index: number) => {
      setChecklistItems((prev) => prev.map((item, i) => (i === index ? { ...item, checked: !item.checked } : item)));
    }, []);

    // Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏ ÏÉÅÌÉú Î≥ÄÍ≤Ω Ìï∏Îì§Îü¨
    const handleChecklistStatusChange = useCallback((id: number, status: string) => {
      setChecklistItems((prev) =>
        prev.map((item) =>
          item.id === id
            ? {
                ...item,
                status,
                progressRate: status === 'ÏôÑÎ£å' ? 100 : status === 'Ï∑®ÏÜå' ? 0 : item.progressRate
              }
            : item
        )
      );
    }, []);

    // Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏ ÏôÑÎ£åÏùº Î≥ÄÍ≤Ω Ìï∏Îì§Îü¨
    const handleChecklistDueDateChange = useCallback((id: number, dueDate: string) => {
      setChecklistItems((prev) => prev.map((item) => (item.id === id ? { ...item, dueDate } : item)));
    }, []);

    // Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏ ÏßÑÏ≤ôÏú® Î≥ÄÍ≤Ω Ìï∏Îì§Îü¨
    const handleChecklistProgressRateChange = useCallback((id: number, progressRate: number) => {
      setChecklistItems((prev) => prev.map((item) => (item.id === id ? { ...item, progressRate } : item)));
    }, []);

    // ÏΩîÎ©òÌä∏ Ìï∏Îì§Îü¨Îì§
    const handleAddComment = useCallback(async () => {
      if (!newComment.trim() || !task?.id) return;

      const currentUserName = currentUser?.user_name || 'ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê';
      const currentTeam = currentUser?.department || '';
      const currentPosition = currentUser?.position || '';
      const currentProfileImage = currentUser?.profile_image_url || '';
      const currentRole = currentUser?.role || '';

      await addFeedback({
        page: PAGE_IDENTIFIERS.SOFTWARE,
        record_id: task.id.toString(),
        action_type: 'Í∏∞Î°ù',
        description: newComment,
        user_name: currentUserName,
        team: currentTeam,
        user_department: currentTeam,
        user_position: currentPosition,
        user_profile_image: currentProfileImage,
        metadata: { role: currentRole }
      });

      setNewComment('');
    }, [newComment, task?.id, addFeedback, currentUser]);

    const handleEditComment = useCallback((commentId: string, content: string) => {
      setEditingCommentId(commentId);
      setEditingCommentText(content);
    }, []);

    const handleSaveEditComment = useCallback(async () => {
      if (!editingCommentText.trim() || !editingCommentId) return;

      await updateFeedback(editingCommentId, {
        description: editingCommentText
      });

      setEditingCommentId(null);
      setEditingCommentText('');
    }, [editingCommentText, editingCommentId, updateFeedback]);

    const handleCancelEditComment = useCallback(() => {
      setEditingCommentId(null);
      setEditingCommentText('');
    }, []);

    const handleDeleteComment = useCallback(async (commentId: string) => {
      await deleteFeedback(commentId);
    }, [deleteFeedback]);

    // ÏûêÎ£å Ìï∏Îì§Îü¨Îì§
    const handleAddMaterial = useCallback((material: any) => {
      setMaterials((prev) => [...prev, material]);
    }, []);

    const handleEditMaterial = useCallback((materialId: number, name: string) => {
      setEditingMaterialId(materialId);
      setEditingMaterialText(name);
    }, []);

    const handleSaveEditMaterial = useCallback(() => {
      if (!editingMaterialText.trim() || !editingMaterialId) return;

      setMaterials((prev) =>
        prev.map((material) => (material.id === editingMaterialId ? { ...material, name: editingMaterialText.trim() } : material))
      );

      setEditingMaterialId(null);
      setEditingMaterialText('');
    }, [editingMaterialText, editingMaterialId]);

    const handleCancelEditMaterial = useCallback(() => {
      setEditingMaterialId(null);
      setEditingMaterialText('');
    }, []);

    const handleDeleteMaterial = useCallback((materialId: number) => {
      setMaterials((prev) => prev.filter((material) => material.id !== materialId));
    }, []);

    const handleDownloadMaterial = useCallback((material: any) => {
      if (material.file) {
        // Ïã§Ï†ú ÌååÏùº Îã§Ïö¥Î°úÎìú
        const url = URL.createObjectURL(material.file);
        const link = document.createElement('a');
        link.href = url;
        link.download = material.name;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      } else {
        // ÌååÏùºÏù¥ ÏóÜÎäî Í≤ΩÏö∞ ÏïåÎ¶º
        alert('Îã§Ïö¥Î°úÎìúÌï† ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.');
      }
    }, []);

    // ÏÇ¨Ïö©ÏûêÏù¥Î†• Ìï∏Îì§Îü¨Îì§
    const handleAddUserHistory = useCallback((userHistoryItem: any) => {
      setUserHistory((prev) => [...prev, userHistoryItem]);
    }, []);

    const handleEditUserHistory = useCallback((id: number, data: any) => {
      setEditingUserHistoryId(id);
      setEditingUserHistoryData(data);
    }, []);

    const handleSaveEditUserHistory = useCallback(() => {
      if (!editingUserHistoryData || editingUserHistoryId === null) return;

      setUserHistory((prev) => prev.map((item) => (item.id === editingUserHistoryId ? { ...item, ...editingUserHistoryData } : item)));

      setEditingUserHistoryId(null);
      setEditingUserHistoryData({});
    }, [editingUserHistoryData, editingUserHistoryId]);

    const handleCancelEditUserHistory = useCallback(() => {
      setEditingUserHistoryId(null);
      setEditingUserHistoryData({});
    }, []);

    const handleDeleteUserHistory = useCallback((id: number) => {
      setUserHistory((prev) => prev.filter((item) => item.id !== id));
    }, []);

    const handleEditUserHistoryDataChange = useCallback((data: any) => {
      setEditingUserHistoryData(data);
    }, []);

    // Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Ìï∏Îì§Îü¨Îì§
    const handleAddPurchaseHistory = useCallback((purchaseHistoryItem: any) => {
      console.log('üìù Î©îÏù∏ Ïª¥Ìè¨ÎÑåÌä∏ - Íµ¨Îß§Ïù¥Î†• Ï∂îÍ∞Ä:', purchaseHistoryItem);
      console.log('   Ï∂îÍ∞ÄÌïòÎ†§Îäî ÏïÑÏù¥ÌÖú ID:', purchaseHistoryItem.id);
      setPurchaseHistory((prev) => {
        console.log('   Ïù¥Ï†Ñ Ïù¥Î†•:', prev.length + 'Í∞ú', prev);
        // ID Ï§ëÎ≥µ Ï≤¥ÌÅ¨
        const existingIds = prev.map(item => item.id);
        console.log('   Í∏∞Ï°¥ IDÎì§:', existingIds);

        if (existingIds.includes(purchaseHistoryItem.id)) {
          console.warn('‚ö†Ô∏è Ï§ëÎ≥µ ID Í∞êÏßÄ! ID:', purchaseHistoryItem.id);
          return prev; // Ï§ëÎ≥µÏù¥Î©¥ Ï∂îÍ∞ÄÌïòÏßÄ ÏïäÏùå
        }

        const updated = [...prev, purchaseHistoryItem];
        console.log('   ÏóÖÎç∞Ïù¥Ìä∏Îêú Ïù¥Î†•:', updated.length + 'Í∞ú', updated);
        return updated;
      });
    }, []);

    const handleEditPurchaseHistory = useCallback((id: number, data: any) => {
      // ÏßÅÏ†ë purchaseHistory ÏÉÅÌÉúÎ•º ÏóÖÎç∞Ïù¥Ìä∏
      setPurchaseHistory((prev) =>
        prev.map((item) => (item.id === id ? { ...item, ...data } : item))
      );
    }, []);

    const handleSaveEditPurchaseHistory = useCallback(() => {
      if (!editingPurchaseHistoryData || editingPurchaseHistoryId === null) return;

      setPurchaseHistory((prev) =>
        prev.map((item) => (item.id === editingPurchaseHistoryId ? { ...item, ...editingPurchaseHistoryData } : item))
      );

      setEditingPurchaseHistoryId(null);
      setEditingPurchaseHistoryData({});
    }, [editingPurchaseHistoryData, editingPurchaseHistoryId]);

    const handleCancelEditPurchaseHistory = useCallback(() => {
      setEditingPurchaseHistoryId(null);
      setEditingPurchaseHistoryData({});
    }, []);

    const handleDeletePurchaseHistory = useCallback((id: number) => {
      setPurchaseHistory((prev) => prev.filter((item) => item.id !== id));
    }, []);

    const handleEditPurchaseHistoryDataChange = useCallback((data: any) => {
      setEditingPurchaseHistoryData(data);
    }, []);

    // ÏÇ¨Ïö©ÏûêÏù¥Î†• Î≥ÄÍ≤Ω Ìï∏Îì§Îü¨
    const handleUserHistoriesChange = useCallback((histories: UserHistory[]) => {
      setCurrentUserHistories(histories);
    }, []);

    // Ìé∏Ïßë Î™®ÎìúÏùº Îïå Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Î°úÎìú (Ìïú Î≤àÎßå Ïã§Ìñâ)
    const [purchaseHistoryLoaded, setPurchaseHistoryLoaded] = useState(false);

    // taskÍ∞Ä Î≥ÄÍ≤ΩÎê† ÎïåÎßàÎã§ Íµ¨Îß§Ïù¥Î†• Î°úÎìú ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
    useEffect(() => {
      setPurchaseHistoryLoaded(false);
      setPurchaseHistory([]);
    }, [task?.id]);

    // Íµ¨Îß§Ïù¥Î†• Î°úÎìú
    useEffect(() => {
      if (task && task.id && task.id > 0 && !purchaseHistoryLoaded) {
        const loadPurchaseHistories = async () => {
          console.log('üìñ Ìé∏Ïßë Î™®Îìú - Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Î°úÎìú Ï§ë...', task.id);
          setPurchaseHistoryLoaded(true);
          try {
            const histories = await getPurchaseHistories(task.id);
            if (histories && histories.length > 0) {
              console.log('‚úÖ Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Î°úÎìú ÏÑ±Í≥µ:', histories.length + 'Í∞ú');
              setPurchaseHistory(histories);
            } else {
              console.log('‚ÑπÔ∏è Ï†ÄÏû•Îêú Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†•Ïù¥ ÏóÜÏäµÎãàÎã§.');
              setPurchaseHistory([]);
            }
          } catch (error) {
            console.warn('‚ö†Ô∏è Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Î°úÎìú Ï§ë Ïò§Î•ò:', error);
            setPurchaseHistory([]);
          }
        };

        loadPurchaseHistories();
      }
    }, [task?.id, purchaseHistoryLoaded, getPurchaseHistories]);

    // Î©îÎ™®Ïù¥Ï†úÏù¥ÏÖòÎêú ÌÉ≠ Ïª¥Ìè¨ÎÑåÌä∏ props
    const overviewTabProps = useMemo(
      () => ({
        softwareState,
        onFieldChange: handleFieldChange,
        users,
        usersLoading,
        usersError,
        softwareCategories,
        licenseTypes,
        statusOptions,
        statusColors,
        categoriesLoading,
        categoriesError,
        statusLoading,
        statusError,
        masterStatusOptions,
        licenseLoading,
        licenseError,
        masterLicenseTypes
      }),
      [softwareState, users, usersLoading, usersError, categoriesLoading, categoriesError, statusLoading, statusError, licenseLoading, licenseError]
    );

    const userHistoryTabProps = useMemo(
      () => ({
        softwareId: task?.id || 0,
        mode: task ? 'edit' as const : 'add' as const,
        userHistories: currentUserHistories,
        onUserHistoriesChange: handleUserHistoriesChange
      }),
      [task, currentUserHistories, handleUserHistoriesChange]
    );

    const recordTabProps = useMemo(
      () => ({
        comments,
        newComment,
        onNewCommentChange: setNewComment,
        onAddComment: handleAddComment,
        editingCommentId,
        editingCommentText,
        onEditComment: handleEditComment,
        onSaveEditComment: handleSaveEditComment,
        onCancelEditComment: handleCancelEditComment,
        onDeleteComment: handleDeleteComment,
        onEditCommentTextChange: setEditingCommentText,
        currentUserName: currentUser?.user_name,
        currentUserAvatar: currentUser?.profile_image_url,
        currentUserRole: currentUser?.role,
        currentUserDepartment: currentUser?.department
      }),
      [
        comments,
        newComment,
        editingCommentId,
        editingCommentText,
        handleAddComment,
        handleEditComment,
        handleSaveEditComment,
        handleCancelEditComment,
        handleDeleteComment,
        currentUser
      ]
    );

    const materialTabProps = useMemo(
      () => ({
        materials,
        onAddMaterial: handleAddMaterial,
        editingMaterialId,
        editingMaterialText,
        onEditMaterial: handleEditMaterial,
        onSaveEditMaterial: handleSaveEditMaterial,
        onCancelEditMaterial: handleCancelEditMaterial,
        onDeleteMaterial: handleDeleteMaterial,
        onEditMaterialTextChange: setEditingMaterialText,
        onDownloadMaterial: handleDownloadMaterial
      }),
      [
        materials,
        editingMaterialId,
        editingMaterialText,
        handleAddMaterial,
        handleEditMaterial,
        handleSaveEditMaterial,
        handleCancelEditMaterial,
        handleDeleteMaterial,
        handleDownloadMaterial
      ]
    );

    const purchaseMaintenanceTabProps = useMemo(
      () => ({
        purchaseHistory,
        historyTypes,
        onAddPurchaseHistory: handleAddPurchaseHistory,
        editingPurchaseHistoryId,
        editingPurchaseHistoryData,
        onEditPurchaseHistory: handleEditPurchaseHistory,
        onSaveEditPurchaseHistory: handleSaveEditPurchaseHistory,
        onCancelEditPurchaseHistory: handleCancelEditPurchaseHistory,
        onDeletePurchaseHistory: handleDeletePurchaseHistory,
        onEditPurchaseHistoryDataChange: handleEditPurchaseHistoryDataChange
      }),
      [
        purchaseHistory,
        historyTypes,
        editingPurchaseHistoryId,
        editingPurchaseHistoryData,
        handleAddPurchaseHistory,
        handleEditPurchaseHistory,
        handleSaveEditPurchaseHistory,
        handleCancelEditPurchaseHistory,
        handleDeletePurchaseHistory,
        handleEditPurchaseHistoryDataChange
      ]
    );

    return (
      <Dialog
        open={open}
        onClose={handleClose}
        maxWidth="lg"
        fullWidth
        PaperProps={{
          sx: {
            height: '840px',
            maxHeight: '840px',
            overflow: 'hidden'
          }
        }}
      >
        <DialogTitle sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', pr: 2, pt: 2 }}>
          <Box>
            <Typography variant="h6" component="div" sx={{ fontSize: '14px', color: 'rgba(0, 0, 0, 0.75)', fontWeight: 500 }}>
              ÏÜåÌîÑÌä∏Ïõ®Ïñ¥Í¥ÄÎ¶¨ Ìé∏Ïßë
            </Typography>
            {task && (
              <Typography variant="body2" sx={{ fontSize: '12px', color: '#666666', fontWeight: 500 }}>
                {(task as any).softwareName || task.workContent} ({task.code})
              </Typography>
            )}
          </Box>

          {/* Ï∑®ÏÜå, Ï†ÄÏû• Î≤ÑÌäºÏùÑ Ïò§Î•∏Ï™Ω ÏÉÅÎã®ÏúºÎ°ú Ïù¥Îèô */}
          <Box sx={{ display: 'flex', gap: 1, mt: 0.5 }}>
            <Button onClick={handleClose} variant="outlined" size="small" sx={{ minWidth: '60px' }}>
              Ï∑®ÏÜå
            </Button>
            <Button onClick={handleSave} variant="contained" size="small" sx={{ minWidth: '60px' }}>
              Ï†ÄÏû•
            </Button>
          </Box>
        </DialogTitle>

        <Box sx={{ borderBottom: 1, borderColor: 'divider', px: 2, backgroundColor: 'background.paper' }}>
          <Tabs value={editTab} onChange={handleTabChange}>
            <Tab label="Í∞úÏöî" />
            <Tab label="ÏÇ¨Ïö©ÏûêÏù¥Î†•" />
            <Tab label="Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†•" />
            <Tab label="Í∏∞Î°ù" />
            <Tab label="ÏûêÎ£å" />
          </Tabs>
        </Box>

        <DialogContent sx={{ p: 0, overflow: 'hidden' }}>
          {editTab === 0 && <OverviewTab {...overviewTabProps} />}
          {editTab === 1 && <UserHistoryTab {...userHistoryTabProps} />}
          {editTab === 2 && <PurchaseMaintenanceTab {...purchaseMaintenanceTabProps} />}
          {editTab === 3 && <RecordTab {...recordTabProps} />}
          {editTab === 4 && <MaterialTab {...materialTabProps} />}
        </DialogContent>

        {/* ÏóêÎü¨ Î©îÏãúÏßÄ ÌëúÏãú */}
        {validationError && (
          <Box sx={{ px: 2, pb: 2 }}>
            <Alert severity="error" sx={{ mt: 1 }}>
              {validationError}
            </Alert>
          </Box>
        )}
      </Dialog>
    );
  }
);

SoftwareEditDialog.displayName = 'SoftwareEditDialog';

export default SoftwareEditDialog;
