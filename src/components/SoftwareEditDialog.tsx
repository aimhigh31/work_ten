import React, { useState, useCallback, useMemo, useReducer, memo, useEffect, useRef } from 'react';
import { createClient } from '@supabase/supabase-js';
import { useSession } from 'next-auth/react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Typography,
  Box,
  Tabs,
  Tab,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Stack,
  Avatar,
  Chip,
  Grid,
  Checkbox,
  Paper,
  IconButton,
  ToggleButtonGroup,
  ToggleButton,
  SvgIcon,
  Alert,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Pagination
} from '@mui/material';
import { TaskTableData, TaskStatus, SoftwareStatus } from '../types/software';
import { useOptimizedInput } from '../hooks/useDebounce';
// import { usePerformanceMonitor } from '../utils/performance';

// Supabase hook
import { useSupabaseSoftware, SoftwareData } from '../hooks/useSupabaseSoftware';

// Supabase ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÑ§Ï†ï
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
const supabase = createClient(supabaseUrl, supabaseKey);

// GROUP015 hook
import { useGroup015 } from '../hooks/useGroup015';

// GROUP017 hook
import { useGroup017 } from '../hooks/useGroup017';

// GROUP002 hook
import { useGroup002 } from '../hooks/useGroup002';

// GROUP016 hook
import { useGroup016 } from '../hooks/useGroup016';

// Users hook
import { useSupabaseUsers } from '../hooks/useSupabaseUsers';

// Software User hook
import { useSupabaseSoftwareUser, UserHistory } from '../hooks/useSupabaseSoftwareUser';
// Software History hook
import { useSupabaseSoftwareHistory, PurchaseHistory } from '../hooks/useSupabaseSoftwareHistory';
// Feedback hook
import { useSupabaseFeedback } from '../hooks/useSupabaseFeedback';
import { PAGE_IDENTIFIERS } from '../types/feedback';
import { useSupabaseFiles } from '../hooks/useSupabaseFiles';
import { FileData } from '../types/files';

// Icons
import { TableDocument, Category, Element } from '@wandersonalwes/iconsax-react';

// ÏÉÅÌÉú Í¥ÄÎ¶¨Î•º ÏúÑÌïú reducer
interface EditSoftwareState {
  softwareName: string;
  description: string;
  softwareCategory: string;
  spec: string;
  status: TaskStatus;
  startDate: string;
  completedDate: string;
  currentUser: string;
  assignee: string;
  team: string;
  solutionProvider: string;
  userCount: number;
  licenseType: string;
  licenseKey: string;
  registrationDate: string;
  code: string;
}

type EditSoftwareAction =
  | { type: 'SET_FIELD'; field: keyof EditSoftwareState; value: string | number }
  | { type: 'SET_SOFTWARE'; software: TaskTableData }
  | { type: 'RESET' }
  | { type: 'INIT_NEW_SOFTWARE'; code: string; registrationDate: string };

const editSoftwareReducer = (state: EditSoftwareState, action: EditSoftwareAction): EditSoftwareState => {
  switch (action.type) {
    case 'SET_FIELD':
      return { ...state, [action.field]: action.value };
    case 'SET_SOFTWARE':
      const result = {
        softwareName: (action.software as any).softwareName || action.software.workContent || '',
        description: (action.software as any).description || '',
        softwareCategory: (action.software as any).softwareCategory || '',
        spec: (action.software as any).spec || '',
        status: action.software.status as TaskStatus,
        startDate: action.software.startDate || '',
        completedDate: action.software.completedDate || '',
        currentUser: (action.software as any).currentUser || '',
        assignee: action.software.assignee,
        team: (action.software as any).team || '',
        solutionProvider: (action.software as any).solutionProvider || '',
        userCount: (action.software as any).userCount || 0,
        licenseType: (action.software as any).licenseType || '',
        licenseKey: (action.software as any).licenseKey || '',
        registrationDate: action.software.registrationDate || '',
        code: action.software.code
      };

      console.log('üîÑ SET_SOFTWARE Ïï°ÏÖò Ïã§Ìñâ:', {
        taskId: action.software.id,
        softwareName: result.softwareName,
        code: result.code,
        status: result.status,
        assignee: result.assignee,
        currentUser: result.currentUser,
        rawData: action.software
      });

      return result;
    case 'INIT_NEW_SOFTWARE':
      return {
        softwareName: '',
        description: '',
        softwareCategory: '',
        spec: '',
        status: 'ÎåÄÍ∏∞',
        startDate: '',
        completedDate: '',
        currentUser: '',
        assignee: '',
        team: '',
        solutionProvider: '',
        userCount: 0,
        licenseType: '',
        licenseKey: '',
        registrationDate: action.registrationDate,
        code: action.code
      };
    case 'RESET':
      return {
        softwareName: '',
        description: '',
        softwareCategory: '',
        spec: '',
        status: 'ÎåÄÍ∏∞',
        startDate: '',
        completedDate: '',
        currentUser: '',
        assignee: '',
        team: '',
        solutionProvider: '',
        userCount: 0,
        licenseType: '',
        licenseKey: '',
        registrationDate: '',
        code: ''
      };
    default:
      return state;
  }
};

// Í∏∞Î°ù ÌÉ≠ Ïª¥Ìè¨ÎÑåÌä∏
const RecordTab = memo(
  ({
    comments,
    newComment,
    onNewCommentChange,
    onAddComment,
    editingCommentId,
    editingCommentText,
    onEditComment,
    onSaveEditComment,
    onCancelEditComment,
    onDeleteComment,
    onEditCommentTextChange,
    currentUserName,
    currentUserAvatar,
    currentUserRole,
    currentUserDepartment
  }: {
    comments: Array<{
      id: string;
      author: string;
      content: string;
      timestamp: string;
      avatar?: string;
      department?: string;
      position?: string;
      role?: string;
    }>;
    newComment: string;
    onNewCommentChange: (value: string) => void;
    onAddComment: () => void;
    editingCommentId: string | null;
    editingCommentText: string;
    onEditComment: (id: string, content: string) => void;
    onSaveEditComment: () => void;
    onCancelEditComment: () => void;
    onDeleteComment: (id: string) => void;
    onEditCommentTextChange: (value: string) => void;
    currentUserName?: string;
    currentUserAvatar?: string;
    currentUserRole?: string;
    currentUserDepartment?: string;
  }) => {
    const [page, setPage] = useState(1);
    const itemsPerPage = 5;

    const handleCommentKeyPress = useCallback(
      (e: React.KeyboardEvent) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          onAddComment();
        }
      },
      [onAddComment]
    );

    const handlePageChange = useCallback((event: React.ChangeEvent<unknown>, value: number) => {
      setPage(value);
    }, []);

    // ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò Í≥ÑÏÇ∞
    const totalPages = Math.ceil(comments.length / itemsPerPage);
    const startIndex = (page - 1) * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    const paginatedComments = comments.slice(startIndex, endIndex);

    return (
      <Box sx={{ height: '720px', display: 'flex', flexDirection: 'column', px: 5, pt: 3, position: 'relative', overflow: 'hidden' }}>
        {/* ÏÉà Í∏∞Î°ù Îì±Î°ù - Ï¢åÏö∞ Î∞∞Ïπò */}
        <Box sx={{ display: 'flex', gap: 2, alignItems: 'flex-start', mb: 3 }}>
          <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 0.5 }}>
            <Avatar src={currentUserAvatar} sx={{ width: 35, height: 35 }}>
              {currentUserName?.charAt(0) || 'U'}
            </Avatar>
            <Box sx={{ display: 'flex', gap: 0.5, alignItems: 'center' }}>
              <Typography variant="caption" sx={{ fontWeight: 600, fontSize: '11px' }}>
                {currentUserName || 'ÏÇ¨Ïö©Ïûê'}
              </Typography>
              {currentUserRole && (
                <Typography variant="caption" sx={{ color: 'text.secondary', fontSize: '10px' }}>
                  {currentUserRole}
                </Typography>
              )}
            </Box>
            {currentUserDepartment && (
              <Typography variant="caption" sx={{ color: 'text.secondary', fontSize: '10px' }}>
                {currentUserDepartment}
              </Typography>
            )}
          </Box>
          <TextField
            multiline
            rows={3}
            placeholder="ÏÉà Í∏∞Î°ùÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî..."
            value={newComment}
            onChange={(e) => onNewCommentChange(e.target.value)}
            onKeyPress={handleCommentKeyPress}
            variant="outlined"
            size="small"
            InputLabelProps={{ shrink: true }}
            sx={{ flex: 1, maxWidth: '95%' }}
          />
          <Button
            variant="contained"
            onClick={onAddComment}
            disabled={!newComment.trim()}
            sx={{ minWidth: '80px', height: '40px', mt: 0.5 }}
          >
            Îì±Î°ù
          </Button>
        </Box>

        {/* Í∏∞Î°ù Ìï≠Î™©Îì§ */}
        <Box
          sx={{
            flex: 1,
            maxHeight: '500px',
            overflowY: 'auto',
            minHeight: 0,
            pb: 0,
            '&::-webkit-scrollbar': {
              width: '8px'
            },
            '&::-webkit-scrollbar-track': {
              background: 'transparent'
            },
            '&::-webkit-scrollbar-thumb': {
              background: '#c1c1c1',
              borderRadius: '4px',
              '&:hover': {
                background: '#a8a8a8'
              }
            }
          }}
        >
          <Stack spacing={2} sx={{ px: 3 }}>
            {paginatedComments.map((comment) => (
              <Paper
                key={`comment-${comment.id}`}
                variant="outlined"
                sx={{
                  p: 2,
                  borderRadius: 2,
                  border: '1px solid',
                  borderColor: 'grey.300',
                  backgroundColor: 'background.paper',
                  transition: 'all 0.2s ease-in-out',
                  '&:hover': {
                    borderColor: 'primary.light',
                    boxShadow: 1
                  }
                }}
              >
                <Stack direction="row" spacing={2} alignItems="flex-start">
                  {/* ÏÇ¨Ïö©Ïûê ÏïÑÎ∞îÌÉÄ */}
                  <Avatar src={comment.avatar} sx={{ width: 30, height: 30 }}>
                    {comment.author.charAt(0)}
                  </Avatar>

                  {/* Í∏∞Î°ù ÎÇ¥Ïö© ÏòÅÏó≠ */}
                  <Box sx={{ flexGrow: 1 }}>
                    {/* ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Î∞è ÏãúÍ∞Ñ */}
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
                      <Typography variant="subtitle2" sx={{ fontWeight: 600, fontSize: '13px' }}>
                        {comment.author}
                      </Typography>
                      {comment.role && (
                        <Typography variant="caption" sx={{ color: 'text.secondary', fontSize: '11px' }}>
                          {comment.role}
                        </Typography>
                      )}
                      {comment.department && (
                        <Typography variant="caption" sx={{ color: 'text.secondary', fontSize: '11px' }}>
                          ‚Ä¢ {comment.department}
                        </Typography>
                      )}
                      <Typography variant="caption" color="text.secondary" sx={{ fontSize: '11px', ml: 'auto' }}>
                        {comment.timestamp}
                      </Typography>
                    </Box>

                    {/* Í∏∞Î°ù ÎÇ¥Ïö© */}
                    {editingCommentId === comment.id ? (
                      <TextField
                        fullWidth
                        multiline
                        rows={3}
                        value={editingCommentText}
                        onChange={(e) => onEditCommentTextChange(e.target.value)}
                        onKeyPress={(e) => {
                          if (e.key === 'Enter' && e.ctrlKey) onSaveEditComment();
                          if (e.key === 'Escape') onCancelEditComment();
                        }}
                        variant="outlined"
                        size="small"
                        autoFocus
                        InputLabelProps={{ shrink: true }}
                      />
                    ) : (
                      <Typography
                        variant="body2"
                        sx={{
                          whiteSpace: 'pre-wrap',
                          cursor: 'pointer',
                          '&:hover': {
                            backgroundColor: 'action.hover',
                            borderRadius: 1,
                            px: 1
                          }
                        }}
                        onClick={() => onEditComment(comment.id, comment.content)}
                      >
                        {comment.content}
                      </Typography>
                    )}
                  </Box>

                  {/* Ïï°ÏÖò Î≤ÑÌäºÎì§ */}
                  <Stack direction="row" spacing={1}>
                    {editingCommentId === comment.id ? (
                      <>
                        <IconButton size="small" onClick={onSaveEditComment} color="success" sx={{ p: 0.5 }} title="Ï†ÄÏû• (Ctrl+Enter)">
                          <Typography fontSize="14px">‚úì</Typography>
                        </IconButton>
                        <IconButton size="small" onClick={onCancelEditComment} color="error" sx={{ p: 0.5 }} title="Ï∑®ÏÜå (Escape)">
                          <Typography fontSize="14px">‚úï</Typography>
                        </IconButton>
                      </>
                    ) : (
                      <>
                        <IconButton
                          size="small"
                          onClick={() => onEditComment(comment.id, comment.content)}
                          color="primary"
                          sx={{ p: 0.5 }}
                          title="ÏàòÏ†ï"
                        >
                          <Typography fontSize="14px">‚úèÔ∏è</Typography>
                        </IconButton>
                        <IconButton size="small" onClick={() => onDeleteComment(comment.id)} color="error" sx={{ p: 0.5 }} title="ÏÇ≠Ï†ú">
                          <Typography fontSize="14px">üóëÔ∏è</Typography>
                        </IconButton>
                      </>
                    )}
                  </Stack>
                </Stack>
              </Paper>
            ))}
          </Stack>

          {/* Îπà ÏÉÅÌÉú Î©îÏãúÏßÄ */}
          {comments.length === 0 && (
            <Paper
              variant="outlined"
              sx={{
                p: 4,
                textAlign: 'center',
                borderStyle: 'dashed',
                borderColor: 'grey.300',
                backgroundColor: 'grey.50',
                mt: 2
              }}
            >
              <Typography variant="body2" color="text.secondary">
                üìù ÏïÑÏßÅ Í∏∞Î°ùÏù¥ ÏóÜÏäµÎãàÎã§.
                <br />
                ÏúÑÏùò ÏûÖÎ†• ÌïÑÎìúÏóêÏÑú ÏÉà Í∏∞Î°ùÏùÑ Îì±Î°ùÌï¥Î≥¥ÏÑ∏Ïöî.
              </Typography>
            </Paper>
          )}
        </Box>

        {/* ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò - ÌïòÎã® Í≥†Ï†ï */}
        <Box
          sx={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            mt: 'auto',
            pt: 3,
            pb: 3,
            px: 4,
            borderTop: '1px solid',
            borderColor: 'divider',
            backgroundColor: 'background.paper',
            position: 'absolute',
            bottom: '0px',
            left: '40px',
            right: '40px'
          }}
        >
          <Typography variant="body2" color="text.secondary">
            {comments.length > 0 ? `${startIndex + 1}-${Math.min(endIndex, comments.length)} of ${comments.length}` : '0-0 of 0'}
          </Typography>
          {comments.length > 0 && (
            <Pagination
              count={totalPages}
              page={page}
              onChange={handlePageChange}
              color="primary"
              size="small"
              showFirstButton
              showLastButton
              sx={{
                '& .MuiPaginationItem-root': {
                  fontSize: '0.875rem',
                  minWidth: '32px',
                  height: '32px',
                  borderRadius: '4px'
                },
                '& .MuiPaginationItem-page.Mui-selected': {
                  backgroundColor: 'primary.main',
                  color: 'white !important',
                  borderRadius: '4px',
                  fontWeight: 500,
                  '&:hover': {
                    backgroundColor: 'primary.dark',
                    color: 'white !important'
                  }
                },
                '& .MuiPaginationItem-page': {
                  borderRadius: '4px',
                  '&:hover': {
                    backgroundColor: 'grey.100'
                  }
                }
              }}
            />
          )}
        </Box>
      </Box>
    );
  }
);

RecordTab.displayName = 'RecordTab';

// Í∞úÏöî ÌÉ≠ Ïª¥Ìè¨ÎÑåÌä∏
const OverviewTab = memo(
  ({
    softwareState,
    onFieldChange,
    users,
    usersLoading,
    usersError,
    statusOptions,
    statusColors,
    softwareCategories,
    licenseTypes,
    categoriesLoading,
    categoriesError,
    statusLoading,
    statusError,
    masterStatusOptions,
    licenseLoading,
    licenseError,
    masterLicenseTypes
  }: {
    softwareState: EditSoftwareState;
    onFieldChange: (field: keyof EditSoftwareState, value: string | number) => void;
    users: any[];
    usersLoading: boolean;
    usersError: string | null;
    statusOptions: SoftwareStatus[];
    statusColors: Record<SoftwareStatus, any>;
    softwareCategories: string[];
    licenseTypes: string[];
    categoriesLoading: boolean;
    categoriesError: string | null;
    statusLoading: boolean;
    statusError: string | null;
    masterStatusOptions: string[];
    licenseLoading: boolean;
    licenseError: string | null;
    masterLicenseTypes: string[];
  }) => {
    // TextField ÏßÅÏ†ë Ï∞∏Ï°∞Î•º ÏúÑÌïú ref
    const workContentRef = useRef<HTMLInputElement>(null);
    const descriptionRef = useRef<HTMLTextAreaElement>(null);

    // Supabase ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÉùÏÑ±
    const supabaseClient = React.useMemo(() => {
      return createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
      );
    }, []);

    // DBÏóêÏÑú ÏßÅÏ†ë Í∞ÄÏ†∏Ïò® ÎßàÏä§ÌÑ∞ÏΩîÎìú Î™©Î°ù state
    const [softwareCategoriesFromDB, setSoftwareCategoriesFromDB] = useState<Array<{ subcode: string; subcode_name: string }>>([]);
    const [licenseTypesFromDB, setLicenseTypesFromDB] = useState<Array<{ subcode: string; subcode_name: string }>>([]);
    const [statusTypesFromDB, setStatusTypesFromDB] = useState<Array<{ subcode: string; subcode_name: string }>>([]);

    // DialogÍ∞Ä Ïó¥Î¶¥ Îïå DBÏóêÏÑú ÏßÅÏ†ë Ï°∞Ìöå
    useEffect(() => {
      const fetchMasterCodeData = async () => {
        // GROUP015 ÏÜåÌîÑÌä∏Ïõ®Ïñ¥Î∂ÑÎ•ò Ï°∞Ìöå
        const { data: group015Data } = await supabaseClient
          .from('admin_mastercode_data')
          .select('subcode, subcode_name, subcode_order')
          .eq('codetype', 'subcode')
          .eq('group_code', 'GROUP015')
          .eq('is_active', true)
          .order('subcode_order', { ascending: true });
        setSoftwareCategoriesFromDB(group015Data || []);

        // GROUP016 ÎùºÏù¥ÏÑºÏä§Ïú†Ìòï Ï°∞Ìöå
        const { data: group016Data } = await supabaseClient
          .from('admin_mastercode_data')
          .select('subcode, subcode_name, subcode_order')
          .eq('codetype', 'subcode')
          .eq('group_code', 'GROUP016')
          .eq('is_active', true)
          .order('subcode_order', { ascending: true });
        setLicenseTypesFromDB(group016Data || []);

        // GROUP002 ÏÉÅÌÉú Ï°∞Ìöå
        const { data: group002Data } = await supabaseClient
          .from('admin_mastercode_data')
          .select('subcode, subcode_name, subcode_order')
          .eq('codetype', 'subcode')
          .eq('group_code', 'GROUP002')
          .eq('is_active', true)
          .order('subcode_order', { ascending: true });
        setStatusTypesFromDB(group002Data || []);
      };

      fetchMasterCodeData();
    }, [supabaseClient]);

    // ÌÖçÏä§Ìä∏ ÌïÑÎìúÏö© ÏµúÏ†ÅÌôîÎêú ÏûÖÎ†• Í¥ÄÎ¶¨
    const softwareNameInput = useOptimizedInput(softwareState.softwareName, 150);
    const descriptionInput = useOptimizedInput(softwareState.description, 200);

    // Î¨¥Ìïú Î£®ÌîÑ Î∞©ÏßÄÎ•º ÏúÑÌïú ref
    const isUpdatingRef = useRef(false);

    // debounced Í∞íÏù¥ Î≥ÄÍ≤ΩÎê† ÎïåÎßàÎã§ ÏÉÅÏúÑ Ïª¥Ìè¨ÎÑåÌä∏Ïóê ÏïåÎ¶º (onFieldChange ÏùòÏ°¥ÏÑ± Ï†úÍ±∞Î°ú ÏµúÏ†ÅÌôî)
    useEffect(() => {
      if (!isUpdatingRef.current && softwareNameInput.debouncedValue !== softwareState.softwareName) {
        onFieldChange('softwareName', softwareNameInput.debouncedValue);
      }
    }, [softwareNameInput.debouncedValue, softwareState.softwareName]); // onFieldChange Ï†úÍ±∞

    useEffect(() => {
      if (!isUpdatingRef.current && descriptionInput.debouncedValue !== softwareState.description) {
        onFieldChange('description', descriptionInput.debouncedValue);
      }
    }, [descriptionInput.debouncedValue, softwareState.description]); // onFieldChange Ï†úÍ±∞

    // Ïô∏Î∂ÄÏóêÏÑú ÏÉÅÌÉúÍ∞Ä Î≥ÄÍ≤ΩÎê† Îïå ÏûÖÎ†• Í∞í ÎèôÍ∏∞Ìôî (reset Ìï®Ïàò ÏùòÏ°¥ÏÑ± Ï†úÍ±∞Î°ú ÏµúÏ†ÅÌôî)
    useEffect(() => {
      if (softwareState.softwareName !== softwareNameInput.inputValue && softwareState.softwareName !== softwareNameInput.debouncedValue) {
        isUpdatingRef.current = true;
        softwareNameInput.reset(softwareState.softwareName);
        setTimeout(() => {
          isUpdatingRef.current = false;
        }, 0);
      }
    }, [softwareState.softwareName, softwareNameInput.inputValue, softwareNameInput.debouncedValue]); // reset Ï†úÍ±∞

    useEffect(() => {
      if (softwareState.description !== descriptionInput.inputValue && softwareState.description !== descriptionInput.debouncedValue) {
        isUpdatingRef.current = true;
        descriptionInput.reset(softwareState.description);
        setTimeout(() => {
          isUpdatingRef.current = false;
        }, 0);
      }
    }, [softwareState.description, descriptionInput.inputValue, descriptionInput.debouncedValue]); // reset Ï†úÍ±∞

    const handleFieldChange = useCallback(
      (field: keyof EditSoftwareState) =>
        (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement> | { target: { value: string | number } }) => {
          const value = e.target.value;
          if (field === 'userCount') {
            onFieldChange(field, Number(value));
          } else {
            onFieldChange(field, String(value));
          }
        },
      [onFieldChange]
    );

    // ÌòÑÏû¨ ÏûÖÎ†• Í∞íÎì§ÏùÑ Î∞òÌôòÌïòÎäî Ìï®Ïàò (ÏùòÏ°¥ÏÑ± Î∞∞Ïó¥ Ï†úÍ±∞Î°ú ÏµúÏ†ÅÌôî)
    const getCurrentValues = useCallback(() => {
      return {
        softwareName: workContentRef.current?.value || softwareNameInput.inputValue,
        description: descriptionRef.current?.value || descriptionInput.inputValue
      };
    }, []); // ÏùòÏ°¥ÏÑ± Î∞∞Ïó¥ Ï†úÍ±∞ - refÎ•º ÌÜµÌï¥ ÏµúÏã† Í∞í Ï†ëÍ∑º

    // Ïª¥Ìè¨ÎÑåÌä∏Í∞Ä ÎßàÏö¥Ìä∏Îê† Îïå getCurrentValues Ìï®ÏàòÎ•º Ï†ÑÏó≠ÏóêÏÑú Ï†ëÍ∑º Í∞ÄÎä•ÌïòÎèÑÎ°ù ÏÑ§Ï†ï
    useEffect(() => {
      (window as any).getOverviewTabCurrentValues = getCurrentValues;
      return () => {
        delete (window as any).getOverviewTabCurrentValues;
      };
    }, []); // ÏùòÏ°¥ÏÑ± Î∞∞Ïó¥ÏóêÏÑú getCurrentValues Ï†úÍ±∞

    return (
      <Box sx={{ height: '650px', overflowY: 'auto', pr: 1, px: 3, py: 3 }}>
        <Stack spacing={3}>
          {/* ÏÜåÌîÑÌä∏Ïõ®Ïñ¥Î™Ö - Ï†ÑÏ≤¥ ÎÑàÎπÑ */}
          <TextField
            fullWidth
            label={
              <span>
                ÏÜåÌîÑÌä∏Ïõ®Ïñ¥Î™Ö <span style={{ color: 'red' }}>*</span>
              </span>
            }
            value={softwareNameInput.inputValue}
            onChange={(e) => softwareNameInput.handleChange(e.target.value)}
            variant="outlined"
            inputRef={workContentRef}
            InputLabelProps={{ shrink: true }}
          />

          {/* ÏÑ§Î™Ö - Ï†ÑÏ≤¥ ÎÑàÎπÑ */}
          <TextField
            fullWidth
            label="ÏÑ§Î™Ö"
            multiline
            rows={4}
            value={descriptionInput.inputValue}
            onChange={(e) => descriptionInput.handleChange(e.target.value)}
            variant="outlined"
            InputLabelProps={{ shrink: true }}
            inputRef={descriptionRef}
          />

          {/* ÏÜåÌîÑÌä∏Ïõ®Ïñ¥Î∂ÑÎ•ò, Ïä§Ìéô, ÏÉÅÌÉú - 3Îì±Î∂Ñ Î∞∞Ïπò */}
          <Stack direction="row" spacing={2}>
            <FormControl fullWidth>
              <InputLabel shrink>
                <span>
                  ÏÜåÌîÑÌä∏Ïõ®Ïñ¥Î∂ÑÎ•ò <span style={{ color: 'red' }}>*</span>
                </span>
              </InputLabel>
              <Select
                value={softwareState.softwareCategory}
                label="ÏÜåÌîÑÌä∏Ïõ®Ïñ¥Î∂ÑÎ•ò"
                onChange={handleFieldChange('softwareCategory')}
                displayEmpty
                notched
                renderValue={(selected) => {
                  if (!selected) return 'ÏÑ†ÌÉù';
                  const item = softwareCategoriesFromDB.find(c => c.subcode === selected);
                  return item ? item.subcode_name : selected;
                }}
              >
                <MenuItem value="">ÏÑ†ÌÉù</MenuItem>
                {softwareCategoriesFromDB.map((option) => (
                  <MenuItem key={option.subcode} value={option.subcode}>
                    {option.subcode_name}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>

            <TextField
              fullWidth
              label="Ïä§Ìéô"
              value={softwareState.spec}
              onChange={handleFieldChange('spec')}
              variant="outlined"
              InputLabelProps={{ shrink: true }}
            />

            <FormControl fullWidth>
              <InputLabel shrink>ÏÉÅÌÉú</InputLabel>
              <Select
                value={softwareState.status}
                label="ÏÉÅÌÉú"
                onChange={handleFieldChange('status')}
                notched
                renderValue={(selected) => {
                  const item = statusTypesFromDB.find(s => s.subcode === selected);
                  return item ? item.subcode_name : selected;
                }}
              >
                {statusTypesFromDB.map((option) => {
                  const getStatusColor = (statusName: string) => {
                    switch (statusName) {
                      case 'ÎåÄÍ∏∞':
                        return { bgcolor: '#F5F5F5', color: '#757575' };
                      case 'ÏßÑÌñâ':
                      case 'ÏßÑÌñâÏ§ë':
                        return { bgcolor: '#E3F2FD', color: '#1976D2' };
                      case 'ÏÇ¨Ïö©Ï§ë':
                      case 'ÏôÑÎ£å':
                        return { bgcolor: '#E8F5E9', color: '#388E3C' };
                      case 'ÌôÄÎî©':
                        return { bgcolor: '#FFEBEE', color: '#D32F2F' };
                      default:
                        return { bgcolor: '#F5F5F5', color: '#757575' };
                    }
                  };

                  return (
                    <MenuItem key={option.subcode} value={option.subcode}>
                      <Chip
                        label={option.subcode_name}
                        size="small"
                        sx={{
                          backgroundColor: getStatusColor(option.subcode_name).bgcolor,
                          color: getStatusColor(option.subcode_name).color,
                          fontSize: '13px',
                          fontWeight: 400
                        }}
                      />
                    </MenuItem>
                  );
                })}
              </Select>
            </FormControl>
          </Stack>

          {/* ÏÜîÎ£®ÏÖòÏóÖÏ≤¥ - ÏÇ¨Ïö©ÏûêÏàò - ÏÇ¨Ïö©Ïûê - 3Îì±Î∂Ñ Î∞∞Ïπò */}
          <Stack direction="row" spacing={2}>
            <TextField
              fullWidth
              label={
                <span>
                  ÏÜîÎ£®ÏÖòÏóÖÏ≤¥ <span style={{ color: 'red' }}>*</span>
                </span>
              }
              value={softwareState.solutionProvider}
              onChange={handleFieldChange('solutionProvider')}
              variant="outlined"
              InputLabelProps={{ shrink: true }}
            />

            <TextField
              fullWidth
              label="ÏÇ¨Ïö©ÏûêÏàò"
              type="number"
              value={softwareState.userCount}
              onChange={handleFieldChange('userCount')}
              variant="outlined"
              InputLabelProps={{ shrink: true }}
              inputProps={{ min: 0 }}
            />

            <TextField
              fullWidth
              label="ÏÇ¨Ïö©Ïûê"
              value={softwareState.currentUser}
              onChange={handleFieldChange('currentUser')}
              variant="outlined"
              InputLabelProps={{ shrink: true }}
            />
          </Stack>

          {/* ÎùºÏù¥ÏÑºÏä§Ïú†ÌòïÍ≥º ÎùºÏù¥ÏÑºÏä§ÌÇ§ - Ï¢åÏö∞ Î∞∞Ïπò */}
          <Stack direction="row" spacing={2}>
            <FormControl fullWidth>
              <InputLabel shrink>
                <span>
                  ÎùºÏù¥ÏÑºÏä§Ïú†Ìòï <span style={{ color: 'red' }}>*</span>
                </span>
              </InputLabel>
              <Select
                value={softwareState.licenseType}
                label="ÎùºÏù¥ÏÑºÏä§Ïú†Ìòï"
                onChange={handleFieldChange('licenseType')}
                displayEmpty
                notched
                renderValue={(selected) => {
                  if (!selected) return 'ÏÑ†ÌÉù';
                  const item = licenseTypesFromDB.find(l => l.subcode === selected);
                  return item ? item.subcode_name : selected;
                }}
              >
                <MenuItem value="">ÏÑ†ÌÉù</MenuItem>
                {licenseTypesFromDB.map((option) => (
                  <MenuItem key={option.subcode} value={option.subcode}>
                    {option.subcode_name}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>

            <TextField
              fullWidth
              label="ÎùºÏù¥ÏÑºÏä§ÌÇ§"
              value={softwareState.licenseKey}
              onChange={handleFieldChange('licenseKey')}
              variant="outlined"
              InputLabelProps={{ shrink: true }}
            />
          </Stack>

          {/* ÏãúÏûëÏùºÍ≥º ÏôÑÎ£åÏùº - Ï¢åÏö∞ Î∞∞Ïπò */}
          <Stack direction="row" spacing={2}>
            <TextField
              fullWidth
              label="ÏãúÏûëÏùº"
              type="date"
              value={softwareState.startDate}
              onChange={handleFieldChange('startDate')}
              variant="outlined"
              InputLabelProps={{ shrink: true }}
            />

            <TextField
              fullWidth
              label="ÏôÑÎ£åÏùº"
              type="date"
              value={softwareState.completedDate}
              onChange={handleFieldChange('completedDate')}
              variant="outlined"
              InputLabelProps={{ shrink: true }}
            />
          </Stack>

          {/* ÌåÄÍ≥º Îã¥ÎãπÏûê - Ï¢åÏö∞ Î∞∞Ïπò */}
          <Stack direction="row" spacing={2}>
            <TextField
              fullWidth
              label="ÌåÄ"
              value={softwareState.team || 'ÌåÄ ÎØ∏ÏßÄÏ†ï'}
              variant="outlined"
              InputLabelProps={{ shrink: true }}
              InputProps={{
                readOnly: true
              }}
              sx={{
                '& .MuiOutlinedInput-root': {
                  backgroundColor: '#f5f5f5',
                  '& fieldset': {
                    borderColor: '#e0e0e0'
                  },
                  '&:hover fieldset': {
                    borderColor: '#e0e0e0'
                  },
                  '&.Mui-focused fieldset': {
                    borderColor: '#e0e0e0'
                  }
                },
                '& .MuiInputBase-input': {
                  color: '#666666'
                }
              }}
            />

            <TextField
              fullWidth
              label="Îã¥ÎãπÏûê"
              value={softwareState.assignee || 'Îã¥ÎãπÏûê ÎØ∏ÏßÄÏ†ï'}
              variant="outlined"
              InputLabelProps={{ shrink: true }}
              InputProps={{
                readOnly: true,
                startAdornment: softwareState.assignee ? (
                  <Avatar
                    src={(() => {
                      const user = users.find((u) => u.user_name === softwareState.assignee);
                      return user?.avatar_url || user?.profile_image_url;
                    })()}
                    alt={softwareState.assignee}
                    sx={{ width: 24, height: 24, mr: -0.5 }}
                  >
                    {softwareState.assignee?.charAt(0)}
                  </Avatar>
                ) : null
              }}
              sx={{
                '& .MuiOutlinedInput-root': {
                  backgroundColor: '#f5f5f5',
                  '& fieldset': {
                    borderColor: '#e0e0e0'
                  },
                  '&:hover fieldset': {
                    borderColor: '#e0e0e0'
                  },
                  '&.Mui-focused fieldset': {
                    borderColor: '#e0e0e0'
                  }
                },
                '& .MuiInputBase-input': {
                  color: '#666666'
                }
              }}
            />
          </Stack>

          {/* Îì±Î°ùÏùºÍ≥º ÏΩîÎìú - Ï¢åÏö∞ Î∞∞Ïπò */}
          <Stack direction="row" spacing={2}>
            <TextField
              fullWidth
              label="Îì±Î°ùÏùº"
              type="date"
              value={softwareState.registrationDate}
              InputLabelProps={{ shrink: true }}
              variant="outlined"
              InputProps={{
                readOnly: true
              }}
              sx={{
                '& .MuiOutlinedInput-root': {
                  backgroundColor: '#f5f5f5',
                  '& fieldset': {
                    borderColor: '#e0e0e0'
                  },
                  '&:hover fieldset': {
                    borderColor: '#e0e0e0'
                  },
                  '&.Mui-focused fieldset': {
                    borderColor: '#e0e0e0'
                  }
                },
                '& .MuiInputBase-input': {
                  color: '#666666'
                }
              }}
            />

            <TextField
              fullWidth
              label="ÏΩîÎìú"
              value={softwareState.code}
              InputLabelProps={{ shrink: true }}
              variant="outlined"
              InputProps={{
                readOnly: true
              }}
              sx={{
                '& .MuiOutlinedInput-root': {
                  backgroundColor: '#f5f5f5',
                  '& fieldset': {
                    borderColor: '#e0e0e0'
                  },
                  '&:hover fieldset': {
                    borderColor: '#e0e0e0'
                  },
                  '&.Mui-focused fieldset': {
                    borderColor: '#e0e0e0'
                  }
                },
                '& .MuiInputBase-input': {
                  color: '#666666'
                }
              }}
            />
          </Stack>
        </Stack>
      </Box>
    );
  }
);

OverviewTab.displayName = 'OverviewTab';

// Î™®ÎçòÌïú Ï†ëÍ∏∞/ÌéºÏπòÍ∏∞ ÏïÑÏù¥ÏΩò Ïª¥Ìè¨ÎÑåÌä∏
const ExpandIcon = ({ expanded }: { expanded: boolean }) => (
  <SvgIcon
    sx={{
      transition: 'transform 0.2s ease-in-out, color 0.2s ease-in-out',
      transform: expanded ? 'rotate(0deg)' : 'rotate(-90deg)',
      fontSize: '14px',
      '&:hover': {
        transform: expanded ? 'rotate(0deg) scale(1.1)' : 'rotate(-90deg) scale(1.1)',
        color: 'primary.main'
      }
    }}
  >
    <path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" />
  </SvgIcon>
);

// ÏûêÎ£å ÌÉ≠ Ïª¥Ìè¨ÎÑåÌä∏ - DB Í∏∞Î∞ò (Î≥¥ÏïàÍµêÏú°Í¥ÄÎ¶¨ÏôÄ ÎèôÏùº Ìå®ÌÑ¥)
const MaterialTab = memo(({ recordId, currentUser, canEditOwn = true, canEditOthers = true }: { recordId?: number | string; currentUser?: any; canEditOwn?: boolean; canEditOthers?: boolean }) => {
  // ÌååÏùº Í¥ÄÎ¶¨ ÌõÖ
  const {
    files,
    loading: filesLoading,
    uploadFile,
    updateFile,
    deleteFile,
    isUploading,
    isDeleting
  } = useSupabaseFiles(PAGE_IDENTIFIERS.SOFTWARE, recordId);

  const [editingMaterialId, setEditingMaterialId] = useState<string | null>(null);
  const [editingMaterialText, setEditingMaterialText] = useState('');

  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileUpload = useCallback(
    async (event: React.ChangeEvent<HTMLInputElement>) => {
      const uploadedFiles = event.target.files;
      if (!uploadedFiles || uploadedFiles.length === 0) return;

      // recordIdÍ∞Ä ÏóÜÏúºÎ©¥ ÏóÖÎ°úÎìú Î∂àÍ∞Ä
      if (!recordId) {
        alert('ÌååÏùºÏùÑ ÏóÖÎ°úÎìúÌïòÎ†§Î©¥ Î®ºÏ†Ä ÏÜåÌîÑÌä∏Ïõ®Ïñ¥Î•º Ï†ÄÏû•Ìï¥Ï£ºÏÑ∏Ïöî.');
        return;
      }

      // Í∞Å ÌååÏùºÏùÑ ÏàúÏ∞®Ï†ÅÏúºÎ°ú ÏóÖÎ°úÎìú
      for (const file of Array.from(uploadedFiles)) {
        const result = await uploadFile(file, {
          page: PAGE_IDENTIFIERS.SOFTWARE,
          record_id: String(recordId),
          // user_idÎäî UUID ÌÉÄÏûÖÏù¥ÎØÄÎ°ú Ïà´ÏûêÌòï IDÎäî Ï†ÑÎã¨ÌïòÏßÄ ÏïäÏùå
          user_id: undefined,
          user_name: currentUser?.user_name || 'Ïïå Ïàò ÏóÜÏùå',
          team: currentUser?.department
        });

        if (!result.success) {
          alert(`ÌååÏùº ÏóÖÎ°úÎìú Ïã§Ìå®: ${result.error}`);
        }
      }

      // ÌååÏùº ÏûÖÎ†• Ï¥àÍ∏∞Ìôî
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    },
    [recordId, uploadFile, currentUser]
  );

  const formatFileSize = (bytes: number): string => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  };

  const getFileIcon = (type: string): string => {
    if (type.startsWith('image/')) return 'üñºÔ∏è';
    if (type.startsWith('video/')) return 'üé•';
    if (type.startsWith('audio/')) return 'üéµ';
    if (type.includes('pdf')) return 'üìÑ';
    if (type.includes('word') || type.includes('document')) return 'üìù';
    if (type.includes('excel') || type.includes('spreadsheet')) return 'üìä';
    if (type.includes('powerpoint') || type.includes('presentation')) return 'üìã';
    if (type.includes('zip') || type.includes('rar') || type.includes('archive')) return 'üì¶';
    return 'üìÑ';
  };

  const handleUploadClick = useCallback(() => {
    fileInputRef.current?.click();
  }, []);

  const handleEditMaterial = useCallback((materialId: string, currentName: string) => {
    setEditingMaterialId(materialId);
    setEditingMaterialText(currentName);
  }, []);

  const handleSaveEditMaterial = useCallback(async () => {
    if (editingMaterialId && editingMaterialText.trim()) {
      const result = await updateFile(editingMaterialId, {
        file_name: editingMaterialText.trim()
      });

      if (result.success) {
        setEditingMaterialId(null);
        setEditingMaterialText('');
      } else {
        alert(`ÌååÏùºÎ™Ö ÏàòÏ†ï Ïã§Ìå®: ${result.error}`);
      }
    }
  }, [editingMaterialId, editingMaterialText, updateFile]);

  const handleCancelEditMaterial = useCallback(() => {
    setEditingMaterialId(null);
    setEditingMaterialText('');
  }, []);

  const handleDeleteMaterial = useCallback(
    async (materialId: string) => {
      if (!confirm('ÌååÏùºÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) return;

      const result = await deleteFile(materialId);
      if (!result.success) {
        alert(`ÌååÏùº ÏÇ≠Ï†ú Ïã§Ìå®: ${result.error}`);
      }
    },
    [deleteFile]
  );

  const handleDownloadMaterial = useCallback((fileData: FileData) => {
    // file_urlÎ°ú Îã§Ïö¥Î°úÎìú
    const link = document.createElement('a');
    link.href = fileData.file_url;
    link.download = fileData.file_name;
    link.target = '_blank';
    link.click();
  }, []);

  return (
    <Box sx={{ height: '650px', px: '5%' }}>
      {/* ÌååÏùº ÏóÖÎ°úÎìú ÏòÅÏó≠ */}
      <Box sx={{ mb: 3, pt: 2 }}>
        <input type="file" ref={fileInputRef} onChange={handleFileUpload} multiple style={{ display: 'none' }} accept="*/*" />

        {/* ÏóÖÎ°úÎìú Î≤ÑÌäºÍ≥º ÎìúÎûòÍ∑∏ Ïï§ ÎìúÎ°≠ ÏòÅÏó≠ */}
        <Paper
          variant="outlined"
          sx={{
            p: 3,
            textAlign: 'center',
            borderStyle: 'dashed',
            borderColor: (canEditOwn || canEditOthers) ? 'primary.main' : 'grey.300',
            backgroundColor: (canEditOwn || canEditOthers) ? 'primary.50' : 'grey.100',
            cursor: (canEditOwn || canEditOthers) ? 'pointer' : 'not-allowed',
            transition: 'all 0.2s ease-in-out',
            '&:hover': (canEditOwn || canEditOthers) ? {
              borderColor: 'primary.dark',
              backgroundColor: 'primary.100'
            } : {}
          }}
          onClick={(canEditOwn || canEditOthers) ? handleUploadClick : undefined}
        >
          <Stack spacing={2} alignItems="center">
            <Typography fontSize="48px">üìÅ</Typography>
            <Typography variant="h6" color={(canEditOwn || canEditOthers) ? 'primary.main' : 'grey.500'}>
              ÌååÏùºÏùÑ ÏóÖÎ°úÎìúÌïòÏÑ∏Ïöî
            </Typography>
            <Typography variant="body2" color="text.secondary">
              ÌÅ¥Î¶≠ÌïòÍ±∞ÎÇò ÌååÏùºÏùÑ Ïó¨Í∏∞Î°ú ÎìúÎûòÍ∑∏ÌïòÏÑ∏Ïöî
            </Typography>
            <Button
              variant="contained"
              size="small"
              startIcon={<Typography>üì§</Typography>}
              disabled={!(canEditOwn || canEditOthers)}
              sx={{
                '&.Mui-disabled': {
                  backgroundColor: 'grey.300',
                  color: 'grey.500'
                }
              }}
            >
              ÌååÏùº ÏÑ†ÌÉù
            </Button>
          </Stack>
        </Paper>
      </Box>

      {/* ÏûêÎ£å Ìï≠Î™©Îì§ */}
      <Box sx={{ flex: 1, overflowY: 'auto', minHeight: 0 }}>
        {filesLoading && (
          <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
            <Typography>ÌååÏùº Î™©Î°ùÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ë...</Typography>
          </Box>
        )}
        <Stack spacing={2}>
          {files.map((fileData) => (
            <Paper
              key={`material-${fileData.id}`}
              variant="outlined"
              sx={{
                p: 2,
                borderRadius: 2,
                border: '1px solid',
                borderColor: 'grey.300',
                backgroundColor: 'background.paper',
                transition: 'all 0.2s ease-in-out',
                '&:hover': {
                  borderColor: 'primary.light',
                  boxShadow: 1
                }
              }}
            >
              <Stack direction="row" spacing={2} alignItems="center">
                {/* ÌååÏùº ÏïÑÏù¥ÏΩò */}
                <Box
                  sx={{
                    width: 48,
                    height: 48,
                    borderRadius: 1,
                    backgroundColor: 'primary.50',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center'
                  }}
                >
                  <Typography fontSize="24px">{getFileIcon(fileData.file_type || '')}</Typography>
                </Box>

                {/* ÌååÏùº Ï†ïÎ≥¥ ÏòÅÏó≠ */}
                <Box sx={{ flexGrow: 1 }}>
                  {editingMaterialId === fileData.id ? (
                    <TextField
                      fullWidth
                      value={editingMaterialText}
                      onChange={(e) => setEditingMaterialText(e.target.value)}
                      onKeyPress={(e) => {
                        if (e.key === 'Enter') handleSaveEditMaterial();
                        if (e.key === 'Escape') handleCancelEditMaterial();
                      }}
                      variant="outlined"
                      size="small"
                      autoFocus
                      InputLabelProps={{ shrink: true }}
                    />
                  ) : (
                    <Typography
                      variant="body1"
                      sx={{
                        fontWeight: 500,
                        cursor: 'pointer',
                        '&:hover': {
                          backgroundColor: 'action.hover',
                          borderRadius: 1,
                          px: 1
                        }
                      }}
                      onClick={() => handleEditMaterial(fileData.id, fileData.file_name)}
                    >
                      {fileData.file_name}
                    </Typography>
                  )}
                  <Typography variant="caption" color="text.secondary">
                    {fileData.file_type} ‚Ä¢ {fileData.file_size ? formatFileSize(fileData.file_size) : 'Ïïå Ïàò ÏóÜÏùå'}
                    {fileData.created_at && ` ‚Ä¢ ${new Date(fileData.created_at).toLocaleDateString()}`}
                  </Typography>
                </Box>

                {/* Ïï°ÏÖò Î≤ÑÌäºÎì§ */}
                <Stack direction="row" spacing={1}>
                  {editingMaterialId === fileData.id ? (
                    <>
                      <IconButton size="small" onClick={handleSaveEditMaterial} color="success" sx={{ p: 0.5 }} title="Ï†ÄÏû•">
                        <Typography fontSize="14px">‚úì</Typography>
                      </IconButton>
                      <IconButton size="small" onClick={handleCancelEditMaterial} color="error" sx={{ p: 0.5 }} title="Ï∑®ÏÜå">
                        <Typography fontSize="14px">‚úï</Typography>
                      </IconButton>
                    </>
                  ) : (
                    <>
                      <IconButton
                        size="small"
                        onClick={() => handleDownloadMaterial(fileData)}
                        color="primary"
                        sx={{ p: 0.5 }}
                        title="Îã§Ïö¥Î°úÎìú"
                      >
                        <Typography fontSize="14px">‚¨áÔ∏è</Typography>
                      </IconButton>
                      <IconButton
                        size="small"
                        onClick={() => handleEditMaterial(fileData.id, fileData.file_name)}
                        color="primary"
                        sx={{
                          p: 0.5,
                          '&.Mui-disabled': {
                            color: 'grey.300'
                          }
                        }}
                        title="ÏàòÏ†ï"
                        disabled={!(canEditOwn || canEditOthers)}
                      >
                        <Typography fontSize="14px">‚úèÔ∏è</Typography>
                      </IconButton>
                      <IconButton
                        size="small"
                        onClick={() => handleDeleteMaterial(fileData.id)}
                        color="error"
                        sx={{
                          p: 0.5,
                          '&.Mui-disabled': {
                            color: 'grey.300'
                          }
                        }}
                        title="ÏÇ≠Ï†ú"
                        disabled={isDeleting || !(canEditOwn || canEditOthers)}
                      >
                        <Typography fontSize="14px">üóëÔ∏è</Typography>
                      </IconButton>
                    </>
                  )}
                </Stack>
              </Stack>
            </Paper>
          ))}

          {!filesLoading && files.length === 0 && (
            <Box
              sx={{
                p: 2.5,
                mt: 2,
                borderRadius: 2,
                backgroundColor: '#f8f9fa',
                border: '1px solid #e9ecef'
              }}
            >
              <Typography
                variant="body2"
                sx={{
                  color: '#6c757d',
                  lineHeight: 1.6,
                  fontSize: '0.875rem',
                  textAlign: 'center'
                }}
              >
                üìÅ ÏïÑÏßÅ ÏóÖÎ°úÎìúÎêú ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.
                <br />
                ÏúÑÏùò ÏóÖÎ°úÎìú ÏòÅÏó≠ÏùÑ ÌÅ¥Î¶≠ÌïòÏó¨ ÌååÏùºÏùÑ ÏóÖÎ°úÎìúÌï¥Î≥¥ÏÑ∏Ïöî.
              </Typography>
            </Box>
          )}
        </Stack>
      </Box>
    </Box>
  );
});

MaterialTab.displayName = 'MaterialTab';

// ÏÇ¨Ïö©Ïûê Ïù¥Î†• Ïù∏ÌÑ∞ÌéòÏù¥Ïä§
interface UserHistory {
  id: string;
  registrationDate: string;
  userId?: string;
  userName: string;
  department: string;
  exclusiveId: string;
  startDate: string;
  endDate: string;
  reason: string;
  status: string; // 'active' | 'inactive' | 'ÏÇ¨Ïö©Ï§ë' | 'Ï§ëÏßÄ' | 'Î∞òÎÇ©' Îì±
  team?: string; // departmentÏôÄ Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌï¥ Ï∂îÍ∞Ä
}

// ÏÇ¨Ïö©ÏûêÏù¥Î†• ÌÉ≠ Ïª¥Ìè¨ÎÑåÌä∏
const UserHistoryTab = memo(
  ({
    softwareId,
    mode,
    userHistories: initialUserHistories,
    onUserHistoriesChange,
    canEditOwn = true,
    canEditOthers = true
  }: {
    softwareId: number;
    mode: 'add' | 'edit';
    userHistories: UserHistory[];
    onUserHistoriesChange: (histories: UserHistory[]) => void;
    canEditOwn?: boolean;
    canEditOthers?: boolean;
  }) => {
    const { getUserHistories, convertToUserHistory } = useSupabaseSoftwareUser();

    // Î°úÏª¨ ÏÇ¨Ïö©ÏûêÏù¥Î†• ÏÉÅÌÉú
    const [userHistories, setUserHistories] = useState<UserHistory[]>(initialUserHistories);

    // DBÏóêÏÑú ÏßÅÏ†ë Ï°∞ÌöåÌïú ÎßàÏä§ÌÑ∞ÏΩîÎìú Îç∞Ïù¥ÌÑ∞
    const [statusFromDB, setStatusFromDB] = useState<Array<{ subcode: string; subcode_name: string }>>([]);

    // DBÏóêÏÑú ÏÇ¨Ïö©ÏûêÏù¥Î†• Î°úÎìú (Ìé∏Ïßë Î™®ÎìúÏù∏ Í≤ΩÏö∞)
    useEffect(() => {
      const loadUserHistories = async () => {
        if (mode === 'edit' && softwareId) {
          try {
            const userData = await getUserHistories(softwareId);
            const convertedData = userData.map(convertToUserHistory);
            setUserHistories(convertedData);
            onUserHistoriesChange(convertedData);
          } catch (error) {
            console.warn('‚ö†Ô∏è ÏÇ¨Ïö©ÏûêÏù¥Î†• Î°úÎìú Ï§ë Ïò§Î•ò:', error);
            // ÏóêÎü¨Í∞Ä Î∞úÏÉùÌï¥ÎèÑ Îπà Î∞∞Ïó¥Î°ú Ï¥àÍ∏∞ÌôîÌïòÏó¨ UIÍ∞Ä Ï†ïÏÉÅ ÏûëÎèôÌïòÎèÑÎ°ù Ìï®
            setUserHistories([]);
            onUserHistoriesChange([]);
          }
        }
      };

      loadUserHistories();
    }, [mode, softwareId]);

    // GROUP044 ÏÉÅÌÉú Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå (DialogÍ∞Ä Ïó¥Î¶¥ ÎïåÎßàÎã§)
    useEffect(() => {
      const fetchStatusData = async () => {
        try {
          const { data: group044Data } = await supabase
            .from('admin_mastercode_data')
            .select('subcode, subcode_name, subcode_order')
            .eq('codetype', 'subcode')
            .eq('group_code', 'GROUP044')
            .eq('is_active', true)
            .order('subcode_order', { ascending: true });

          if (group044Data) {
            setStatusFromDB(group044Data);
            console.log('‚úÖ [UserHistoryTab] GROUP044 ÏÉÅÌÉú DB Ï°∞Ìöå ÏôÑÎ£å:', group044Data.length, 'Í∞ú');
          }
        } catch (error) {
          console.error('‚ùå [UserHistoryTab] GROUP044 Ï°∞Ìöå Ïã§Ìå®:', error);
        }
      };

      fetchStatusData();
    }, []);

    // ÏÇ¨Ïö©ÏûêÏù¥Î†• Î≥ÄÍ≤Ω Ïãú Î∂ÄÎ™® Ïª¥Ìè¨ÎÑåÌä∏Ïóê ÏïåÎ¶º
    useEffect(() => {
      onUserHistoriesChange(userHistories);
    }, [userHistories, onUserHistoriesChange]);

    // Îçî ÎßéÏùÄ ÏÉòÌîå Îç∞Ïù¥ÌÑ∞Î°ú ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò ÌÖåÏä§Ìä∏ (add Î™®ÎìúÏùº ÎïåÎßå ÏÇ¨Ïö©)
    const [sampleUserHistories] = useState<UserHistory[]>([
      {
        id: '1',
        registrationDate: '2024-01-15',
        userId: 'user1',
        userName: 'ÍπÄÏ≤†Ïàò',
        department: 'ITÌåÄ',
        exclusiveId: 'SW001-KCS',
        startDate: '2024-01-15',
        endDate: '2024-06-30',
        reason: 'Î∂ÄÏÑú Ïù¥Îèô',
        status: 'inactive'
      },
      {
        id: '2',
        registrationDate: '2024-07-01',
        userId: 'user2',
        userName: 'Ïù¥ÏòÅÌù¨',
        department: 'Í∞úÎ∞úÌåÄ',
        exclusiveId: 'SW001-LYH',
        startDate: '2024-07-01',
        endDate: '',
        reason: 'Ïã†Í∑ú Î∞∞Ï†ï',
        status: 'active'
      },
      {
        id: '3',
        registrationDate: '2024-08-01',
        userId: 'user3',
        userName: 'Î∞ïÎØºÏàò',
        department: 'ÎîîÏûêÏù∏ÌåÄ',
        exclusiveId: 'SW001-PMS',
        startDate: '2024-08-01',
        endDate: '',
        reason: 'Ïã†Í∑ú Î∞∞Ï†ï',
        status: 'active'
      },
      {
        id: '4',
        registrationDate: '2024-08-05',
        userId: 'user4',
        userName: 'ÏµúÏùÄÏßÄ',
        department: 'Í∏∞ÌöçÌåÄ',
        exclusiveId: 'SW001-CEJ',
        startDate: '2024-08-05',
        endDate: '',
        reason: 'Ïã†Í∑ú Î∞∞Ï†ï',
        status: 'active'
      },
      {
        id: '5',
        registrationDate: '2024-08-10',
        userId: 'user5',
        userName: 'Ï†ïÌòÑÏö∞',
        department: 'ÎßàÏºÄÌåÖÌåÄ',
        exclusiveId: 'SW001-JHW',
        startDate: '2024-08-10',
        endDate: '',
        reason: 'Ïã†Í∑ú Î∞∞Ï†ï',
        status: 'active'
      },
      {
        id: '6',
        registrationDate: '2024-08-15',
        userId: 'user6',
        userName: 'Í∞ïÏòàÎ¶∞',
        department: 'ITÌåÄ',
        exclusiveId: 'SW001-KYR',
        startDate: '2024-08-15',
        endDate: '',
        reason: 'Ïã†Í∑ú Î∞∞Ï†ï',
        status: 'active'
      },
      {
        id: '7',
        registrationDate: '2024-08-20',
        userId: 'user7',
        userName: 'ÏÜ°ÏßÄÌõà',
        department: 'Í∞úÎ∞úÌåÄ',
        exclusiveId: 'SW001-SJH',
        startDate: '2024-08-20',
        endDate: '',
        reason: 'Ïã†Í∑ú Î∞∞Ï†ï',
        status: 'active'
      },
      {
        id: '8',
        registrationDate: '2024-08-22',
        userId: 'user8',
        userName: 'ÍπÄÏÜåÏòÅ',
        department: 'ÎîîÏûêÏù∏ÌåÄ',
        exclusiveId: 'SW001-KSY',
        startDate: '2024-08-22',
        endDate: '',
        reason: 'Ïã†Í∑ú Î∞∞Ï†ï',
        status: 'active'
      },
      {
        id: '9',
        registrationDate: '2024-08-24',
        userId: 'user9',
        userName: 'Ïù¥ÎèôÌòÑ',
        department: 'Í∏∞ÌöçÌåÄ',
        exclusiveId: 'SW001-LDH',
        startDate: '2024-08-24',
        endDate: '',
        reason: 'Ïã†Í∑ú Î∞∞Ï†ï',
        status: 'active'
      }
    ]);

    const [selectedRows, setSelectedRows] = useState<string[]>([]);
    const [editingCell, setEditingCell] = useState<{ id: string; field: string } | null>(null);
    const [statusWarning, setStatusWarning] = useState<string>('');

    // ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò ÏÉÅÌÉú
    const [currentPage, setCurrentPage] = useState(1);
    const [itemsPerPage] = useState(7);

    // ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò Í≥ÑÏÇ∞
    const totalPages = Math.ceil(userHistories.length / itemsPerPage);
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    const currentItems = userHistories.slice(startIndex, endIndex);

    // ÌéòÏù¥ÏßÄ Î≥ÄÍ≤Ω Ìï∏Îì§Îü¨ (MUI Pagination ÌòïÏãùÏóê ÎßûÍ≤å ÏàòÏ†ï)
    const handlePageChange = (event: React.ChangeEvent<unknown>, page: number) => {
      setCurrentPage(page);
    };

    const handleCellClick = (id: string, field: string) => {
      setEditingCell({ id, field });
    };

    const handleCellBlur = () => {
      setEditingCell(null);
    };

    const handleAddHistory = () => {
      // "ÎåÄÍ∏∞" ÏÉÅÌÉúÏùò subcode Ï∞æÍ∏∞
      const daegiStatus = statusFromDB.find((s) => s.subcode_name === 'ÎåÄÍ∏∞');
      const defaultStatus = daegiStatus ? daegiStatus.subcode : '';

      const newHistory: UserHistory = {
        id: Date.now().toString(),
        registrationDate: new Date().toISOString().split('T')[0],
        userId: '',
        userName: '',
        department: '',
        exclusiveId: '',
        startDate: new Date().toISOString().split('T')[0],
        endDate: '',
        reason: '',
        status: defaultStatus
      };
      setUserHistories([newHistory, ...userHistories]);
    };

    const handleDeleteSelected = () => {
      setUserHistories(userHistories.filter((h) => !selectedRows.includes(h.id)));
      setSelectedRows([]);
    };

    const handleEditHistory = (id: string, field: keyof UserHistory, value: string) => {
      // ÏÜåÌîÑÌä∏Ïõ®Ïñ¥Îäî ÎèôÏãú ÏÇ¨Ïö©Ïù¥ Í∞ÄÎä•ÌïòÎØÄÎ°ú ÏÉÅÌÉú Í≤ÄÏ¶ù Ï†úÍ±∞
      setUserHistories(userHistories.map((h) => (h.id === id ? { ...h, [field]: value } : h)));
      setStatusWarning('');
    };

    const handleSelectRow = (id: string) => {
      if (selectedRows.includes(id)) {
        setSelectedRows(selectedRows.filter((rowId) => rowId !== id));
      } else {
        setSelectedRows([...selectedRows, id]);
      }
    };

    const handleSelectAll = (event: React.ChangeEvent<HTMLInputElement>) => {
      if (event.target.checked) {
        setSelectedRows(userHistories.map((h) => h.id));
      } else {
        setSelectedRows([]);
      }
    };

    // DBÏóêÏÑú Í∞ÄÏ†∏Ïò® ÏÉÅÌÉú ÏòµÏÖò (subcode_name Î™©Î°ù, "ÎåÄÍ∏∞"Í∞Ä Î®ºÏ†Ä Ïò§ÎèÑÎ°ù Ï†ïÎ†¨)
    const statusOptions = useMemo(() => {
      const options = statusFromDB.map((s) => s.subcode_name);
      // "ÎåÄÍ∏∞"Î•º Îß® ÏïûÏúºÎ°ú Ïù¥Îèô
      const daegiIndex = options.indexOf('ÎåÄÍ∏∞');
      if (daegiIndex > 0) {
        options.splice(daegiIndex, 1);
        options.unshift('ÎåÄÍ∏∞');
      }
      return options;
    }, [statusFromDB]);

    // ÏÉÅÌÉúÎ≥Ñ ÏÉâÏÉÅ Îß§Ìïë (ÎèôÏ†Å ÏÉùÏÑ±)
    const statusColors: Record<string, { bgColor: string; color: string }> = useMemo(() => {
      const colors: Record<string, { bgColor: string; color: string }> = {};
      statusFromDB.forEach((s) => {
        switch (s.subcode_name) {
          case 'ÎåÄÍ∏∞':
            colors[s.subcode_name] = { bgColor: '#F5F5F5', color: '#757575' };
            break;
          case 'ÌôúÏÑ±':
          case 'ÏÇ¨Ïö©Ï§ë':
            colors[s.subcode_name] = { bgColor: '#E3F2FD', color: '#1976D2' };
            break;
          case 'ÎπÑÌôúÏÑ±':
          case 'Ï¢ÖÎ£å':
            colors[s.subcode_name] = { bgColor: '#fff8e1', color: '#f57c00' };
            break;
          case 'Ï∑®ÏÜå':
          case 'ÌôÄÎî©':
            colors[s.subcode_name] = { bgColor: '#FFEBEE', color: '#D32F2F' };
            break;
          default:
            colors[s.subcode_name] = { bgColor: '#F5F5F5', color: '#757575' };
        }
      });
      return colors;
    }, [statusFromDB]);

    // Ïª¨Îüº ÎÑàÎπÑ Î∞è ÎÜíÏù¥ Ï†ïÏùò (Ìé∏Ïßë/ÏùΩÍ∏∞ Î™®Îìú Í≥µÌÜµ)
    const columnWidths = useMemo(
      () => ({
        checkbox: 50,
        no: 60,
        registrationDate: 100,
        team: 100,
        userName: 120,
        exclusiveId: 120,
        reason: 150,
        status: 100,
        startDate: 100,
        endDate: 100
      }),
      []
    );

    const cellHeight = 56; // Í≥†Ï†ï ÏÖÄ ÎÜíÏù¥

    // Ìé∏Ïßë Í∞ÄÎä•Ìïú ÏÖÄ Î†åÎçîÎßÅ
    const renderEditableCell = (history: UserHistory, field: string, value: string, options?: string[]) => {
      const isEditing = editingCell?.id === history.id && editingCell?.field === field;
      const fieldWidth = columnWidths[field as keyof typeof columnWidths] || 100;

      if (isEditing) {
        if (options) {
          // Îπà Í∞íÏùº Í≤ΩÏö∞ "ÎåÄÍ∏∞"Î•º Í∏∞Î≥∏Í∞íÏúºÎ°ú ÏÑ§Ï†ï
          const displayValue = value || 'ÎåÄÍ∏∞';

          return (
            <Select
              value={displayValue}
              onChange={(e) => {
                const newValue = e.target.value;
                // subcode_nameÏùÑ subcodeÎ°ú Î≥ÄÌôòÌïòÏó¨ Ï†ÄÏû•
                if (field === 'status') {
                  const statusItem = statusFromDB.find((s) => s.subcode_name === newValue);
                  const subcodeValue = statusItem ? statusItem.subcode : newValue;
                  handleEditHistory(history.id, 'status', subcodeValue);
                } else {
                  handleEditHistory(history.id, field as keyof UserHistory, newValue);
                }
              }}
              onBlur={handleCellBlur}
              size="small"
              autoFocus
              sx={{
                width: fieldWidth - 16,
                minWidth: fieldWidth - 16,
                height: 40, // Í≥†Ï†ï ÎÜíÏù¥
                '& .MuiSelect-select': {
                  padding: '8px 14px',
                  fontSize: '12px',
                  lineHeight: '1.4'
                }
              }}
            >
              {options.map((option) => (
                <MenuItem key={option} value={option}>
                  {field === 'status' ? (
                    <Chip
                      label={option}
                      size="small"
                      sx={{
                        bgcolor: statusColors[option]?.bgColor || '#F5F5F5',
                        color: statusColors[option]?.color || '#757575',
                        fontWeight: 500,
                        border: 'none'
                      }}
                    />
                  ) : (
                    option
                  )}
                </MenuItem>
              ))}
            </Select>
          );
        }

        if (field === 'startDate' || field === 'endDate') {
          return (
            <TextField
              type="date"
              value={value || ''}
              onChange={(e) => handleEditHistory(history.id, field as keyof UserHistory, e.target.value)}
              onBlur={handleCellBlur}
              size="small"
              autoFocus
              InputLabelProps={{
                shrink: true
              }}
              sx={{
                width: fieldWidth - 16,
                height: 40, // Í≥†Ï†ï ÎÜíÏù¥
                '& .MuiInputBase-root': {
                  height: 40
                },
                '& .MuiInputBase-input': {
                  fontSize: '12px',
                  padding: '8px 14px'
                }
              }}
            />
          );
        }

        return (
          <TextField
            value={value}
            onChange={(e) => handleEditHistory(history.id, field as keyof UserHistory, e.target.value)}
            onBlur={handleCellBlur}
            size="small"
            autoFocus
            InputLabelProps={{ shrink: true }}
            sx={{
              width: fieldWidth - 16,
              height: 40, // Í≥†Ï†ï ÎÜíÏù¥
              '& .MuiInputBase-root': {
                height: 40
              },
              '& .MuiInputBase-input': {
                fontSize: '12px',
                padding: '8px 14px'
              }
            }}
          />
        );
      }

      // ÏùΩÍ∏∞ Î™®Îìú
      if (field === 'status') {
        // Îπà Í∞íÏùº Í≤ΩÏö∞ "ÎåÄÍ∏∞" ÌëúÏãú
        const displayValue = value || 'ÎåÄÍ∏∞';

        return (
          <Box
            sx={{
              height: 40, // Í≥†Ï†ï ÎÜíÏù¥
              display: 'flex',
              alignItems: 'center',
              cursor: 'pointer'
            }}
          >
            <Chip
              label={displayValue}
              size="small"
              sx={{
                bgcolor: statusColors[displayValue]?.bgColor || '#F5F5F5',
                color: statusColors[displayValue]?.color || '#757575',
                fontWeight: 500,
                border: 'none',
                '&:hover': { opacity: 0.8 },
                fontSize: '12px'
              }}
            />
          </Box>
        );
      }

      return (
        <Box
          sx={{
            height: 40, // Í≥†Ï†ï ÎÜíÏù¥
            display: 'flex',
            alignItems: 'center',
            cursor: 'pointer',
            '&:hover': { bgcolor: 'grey.50' },
            p: 0.5,
            borderRadius: 1
          }}
        >
          <Typography
            variant="body2"
            sx={{
              fontSize: '12px'
            }}
          >
            {value || '-'}
          </Typography>
        </Box>
      );
    };

    return (
      <Box sx={{ height: '650px', display: 'flex', flexDirection: 'column', p: 3 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Typography variant="h6" sx={{ fontSize: '16px', fontWeight: 600 }}>
            ÏÇ¨Ïö©Ïûê Ïù¥Î†• Í¥ÄÎ¶¨
          </Typography>
          <Box sx={{ display: 'flex', gap: 1 }}>
            <Button
              variant="outlined"
              color="error"
              onClick={handleDeleteSelected}
              disabled={selectedRows.length === 0 || !(canEditOwn || canEditOthers)}
              size="small"
              sx={{
                '&.Mui-disabled': {
                  borderColor: 'grey.300',
                  color: 'grey.500'
                }
              }}
            >
              ÏÇ≠Ï†ú({selectedRows.length})
            </Button>
            <Button
              variant="contained"
              onClick={handleAddHistory}
              disabled={!(canEditOwn || canEditOthers)}
              size="small"
              sx={{
                fontSize: '12px',
                '&.Mui-disabled': {
                  backgroundColor: 'grey.300',
                  color: 'grey.500'
                }
              }}
            >
              Ï∂îÍ∞Ä
            </Button>
          </Box>
        </Box>

        <TableContainer
          sx={{
            flex: 1,
            overflowY: 'auto',
            overflowX: 'auto',
            '& .MuiTable-root': {
              minWidth: 800
            }
          }}
        >
          <Table size="small">
            <TableHead>
              <TableRow sx={{ backgroundColor: 'grey.50' }}>
                <TableCell padding="checkbox" sx={{ width: columnWidths.checkbox }}>
                  <Checkbox
                    checked={selectedRows.length === userHistories.length && userHistories.length > 0}
                    onChange={handleSelectAll}
                    color="primary"
                    size="small"
                    sx={{
                      transform: 'scale(0.7)',
                      '&.Mui-checked': {
                        color: '#1976d2'
                      }
                    }}
                  />
                </TableCell>
                <TableCell sx={{ width: columnWidths.no, fontWeight: 600 }}>NO</TableCell>
                <TableCell sx={{ width: columnWidths.registrationDate, fontWeight: 600 }}>Îì±Î°ùÏùº</TableCell>
                <TableCell sx={{ width: columnWidths.team, fontWeight: 600 }}>ÌåÄ</TableCell>
                <TableCell sx={{ width: columnWidths.userName, fontWeight: 600 }}>ÏÇ¨Ïö©Ïûê</TableCell>
                <TableCell sx={{ width: columnWidths.exclusiveId, fontWeight: 600 }}>Ï†ÑÏö©ÏïÑÏù¥Îîî</TableCell>
                <TableCell sx={{ width: columnWidths.reason, fontWeight: 600 }}>ÏÇ¨Ïú†</TableCell>
                <TableCell sx={{ width: columnWidths.status, fontWeight: 600 }}>ÏÇ¨Ïö©ÏÉÅÌÉú</TableCell>
                <TableCell sx={{ width: columnWidths.startDate, fontWeight: 600 }}>ÏãúÏûëÏùº</TableCell>
                <TableCell sx={{ width: columnWidths.endDate, fontWeight: 600 }}>Ï¢ÖÎ£åÏùº</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {currentItems.map((history, index) => (
                <TableRow
                  key={`history_${history.id}_${index}`}
                  hover
                  sx={{
                    height: cellHeight,
                    '&:hover': { backgroundColor: 'action.hover' }
                  }}
                >
                  <TableCell padding="checkbox" sx={{ width: columnWidths.checkbox }}>
                    <Checkbox
                      checked={selectedRows.includes(history.id)}
                      onChange={() => handleSelectRow(history.id)}
                      color="primary"
                      size="small"
                      sx={{
                        transform: 'scale(0.7)',
                        '&.Mui-checked': {
                          color: '#1976d2'
                        }
                      }}
                    />
                  </TableCell>
                  <TableCell sx={{ width: columnWidths.no }}>{userHistories.length - startIndex - index}</TableCell>
                  <TableCell sx={{ width: columnWidths.registrationDate }} onClick={() => handleCellClick(history.id, 'registrationDate')}>
                    {renderEditableCell(history, 'registrationDate', history.registrationDate)}
                  </TableCell>
                  <TableCell sx={{ width: columnWidths.team }} onClick={() => handleCellClick(history.id, 'department')}>
                    {renderEditableCell(history, 'department', history.department)}
                  </TableCell>
                  <TableCell sx={{ width: columnWidths.userName }} onClick={() => handleCellClick(history.id, 'userName')}>
                    {renderEditableCell(history, 'userName', history.userName)}
                  </TableCell>
                  <TableCell sx={{ width: columnWidths.exclusiveId }} onClick={() => handleCellClick(history.id, 'exclusiveId')}>
                    {renderEditableCell(history, 'exclusiveId', history.exclusiveId)}
                  </TableCell>
                  <TableCell sx={{ width: columnWidths.reason }} onClick={() => handleCellClick(history.id, 'reason')}>
                    {renderEditableCell(history, 'reason', history.reason)}
                  </TableCell>
                  <TableCell sx={{ width: columnWidths.status }} onClick={() => handleCellClick(history.id, 'status')}>
                    {(() => {
                      // subcodeÎ•º subcode_nameÏúºÎ°ú Î≥ÄÌôò (Îπà Í∞íÏù¥Î©¥ "ÎåÄÍ∏∞")
                      let statusName = history.status ? statusFromDB.find((s) => s.subcode === history.status)?.subcode_name : '';
                      if (!statusName) {
                        statusName = 'ÎåÄÍ∏∞';
                      }
                      return renderEditableCell(history, 'status', statusName, statusOptions);
                    })()}
                  </TableCell>
                  <TableCell sx={{ width: columnWidths.startDate }} onClick={() => handleCellClick(history.id, 'startDate')}>
                    {renderEditableCell(history, 'startDate', history.startDate)}
                  </TableCell>
                  <TableCell sx={{ width: columnWidths.endDate }} onClick={() => handleCellClick(history.id, 'endDate')}>
                    {renderEditableCell(history, 'endDate', history.endDate)}
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>

        {/* ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò - ÌïòÎã® Í≥†Ï†ï */}
        <Box
          sx={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            mt: 'auto',
            pt: 2,
            px: 2,
            borderTop: '1px solid',
            borderColor: 'divider',
            backgroundColor: 'background.paper',
            position: 'sticky',
            bottom: 0
          }}
        >
          <Typography variant="body2" color="text.secondary">
            {userHistories.length > 0
              ? `${startIndex + 1}-${Math.min(endIndex, userHistories.length)} of ${userHistories.length}`
              : '0-0 of 0'}
          </Typography>
          {totalPages > 1 && (
            <Pagination
              count={totalPages}
              page={currentPage}
              onChange={handlePageChange}
              color="primary"
              size="small"
              showFirstButton
              showLastButton
              sx={{
                '& .MuiPaginationItem-root': {
                  fontSize: '0.875rem',
                  minWidth: '32px',
                  height: '32px',
                  borderRadius: '4px'
                },
                '& .MuiPaginationItem-page.Mui-selected': {
                  backgroundColor: 'primary.main',
                  color: 'white !important',
                  borderRadius: '4px',
                  fontWeight: 500,
                  '&:hover': {
                    backgroundColor: 'primary.dark',
                    color: 'white !important'
                  }
                },
                '& .MuiPaginationItem-page': {
                  borderRadius: '4px',
                  '&:hover': {
                    backgroundColor: 'grey.100'
                  }
                }
              }}
            />
          )}
        </Box>

        {/* Í≤ΩÍ≥† Î©îÏãúÏßÄ */}
        {statusWarning && (
          <Alert
            severity="warning"
            sx={{
              mt: 2,
              mx: 3,
              mb: 2,
              animation: 'fadeIn 0.3s ease-in'
            }}
          >
            {statusWarning}
          </Alert>
        )}
      </Box>
    );
  }
);

UserHistoryTab.displayName = 'UserHistoryTab';

// Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Ïù∏ÌÑ∞ÌéòÏù¥Ïä§
interface MaintenanceHistory {
  id: string;
  registrationDate: string;
  type: 'purchase' | 'maintenance' | 'upgrade' | 'renewal';
  content: string;
  vendor: string;
  amount: number;
  registrant: string;
  status: string;
  startDate: string;
  completionDate: string;
}

// Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• ÌÉ≠ Ïª¥Ìè¨ÎÑåÌä∏
const PurchaseMaintenanceTab = memo(
  ({
    purchaseHistory,
    historyTypes,
    onAddPurchaseHistory,
    editingPurchaseHistoryId,
    editingPurchaseHistoryData,
    onEditPurchaseHistory,
    onSavePurchaseHistoryEdit,
    onCancelPurchaseHistoryEdit,
    onDeletePurchaseHistory,
    onEditPurchaseHistoryDataChange,
    canEditOwn = true,
    canEditOthers = true
  }: {
    purchaseHistory: any[];
    historyTypes: string[];
    onAddPurchaseHistory: (item: any) => void;
    editingPurchaseHistoryId: number | null;
    editingPurchaseHistoryData: any;
    onEditPurchaseHistory: (id: number, data: any) => void;
    onSavePurchaseHistoryEdit: () => void;
    onCancelPurchaseHistoryEdit: () => void;
    onDeletePurchaseHistory: (id: number) => void;
    onEditPurchaseHistoryDataChange: (data: any) => void;
    canEditOwn?: boolean;
    canEditOthers?: boolean;
  }) => {
    // Supabase ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÉùÏÑ±
    const supabaseClient = React.useMemo(() => {
      return createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
      );
    }, []);

    // DBÏóêÏÑú ÏßÅÏ†ë Í∞ÄÏ†∏Ïò® Ïú†Ìòï Î™©Î°ù state
    const [historyTypesFromDB, setHistoryTypesFromDB] = useState<Array<{ subcode: string; subcode_name: string }>>([]);

    // DialogÍ∞Ä Ïó¥Î¶¥ Îïå DBÏóêÏÑú ÏßÅÏ†ë Ï°∞Ìöå
    useEffect(() => {
      const fetchMasterCodeData = async () => {
        // GROUP017 Ïú†Ìòï Ï°∞Ìöå
        const { data: group017Data } = await supabaseClient
          .from('admin_mastercode_data')
          .select('subcode, subcode_name, subcode_order')
          .eq('codetype', 'subcode')
          .eq('group_code', 'GROUP017')
          .eq('is_active', true)
          .order('subcode_order', { ascending: true });
        setHistoryTypesFromDB(group017Data || []);
      };

      fetchMasterCodeData();
    }, [supabaseClient]);

    // ÏÑ§Î™ÖÏùÑ Í∏∞Î∞òÏúºÎ°ú Ïù¥Î†• ÌÉÄÏûÖ Í≤∞Ï†ï
    const getHistoryType = (description: string): 'purchase' | 'maintenance' | 'upgrade' | 'renewal' => {
      if (description.includes('Ïú†ÏßÄÎ≥¥Ïàò')) return 'maintenance';
      if (description.includes('ÏóÖÍ∑∏Î†àÏù¥Îìú')) return 'upgrade';
      if (description.includes('Í∞±Ïã†') || description.includes('Ïó∞Ïû•')) return 'renewal';
      return 'purchase';
    };

    // memoÏóêÏÑú ÏôÑÎ£åÏùº Ï∂îÏ∂úÌïòÎäî Ìï®Ïàò
    const extractCompletionDate = (memo: string): string => {
      if (!memo) return '';
      const match = memo.match(/ÏôÑÎ£åÏùº:\s*([^\|]*)/);
      return match ? match[1].trim() : '';
    };

    // DBÏóêÏÑú Î°úÎìúÎêú Íµ¨Îß§Ïù¥Î†•ÏùÑ MaintenanceHistory ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
    const dbHistories: MaintenanceHistory[] = purchaseHistory.map((item, index) => {
      const uniqueId = item.id ? item.id.toString() : `temp_${Date.now()}_${index}`;
      const completionDateFromMemo = extractCompletionDate(item.memo || '');

      return {
        id: uniqueId,
        registrationDate: item.registrationDate || item.purchaseDate || '',
        type: getHistoryType(item.description || ''),
        content: item.description || '',
        vendor: item.supplier || '',
        amount: parseFloat(item.price) || 0,
        registrant: 'ÏãúÏä§ÌÖú',
        status: item.status || 'ÏßÑÌñâÏ§ë',
        startDate: item.purchaseDate || '',
        completionDate: completionDateFromMemo || (item.status === 'ÏôÑÎ£å' ? item.purchaseDate || '' : '')
      };
    });

    console.log('üîç PurchaseMaintenanceTab - Îç∞Ïù¥ÌÑ∞ ÌôïÏù∏:');
    console.log('  - purchaseHistory.length:', purchaseHistory.length);
    console.log('  - dbHistories.length:', dbHistories.length);
    console.log('  - purchaseHistory Îç∞Ïù¥ÌÑ∞:', purchaseHistory);

    // Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î•º ÏÇ¨Ïö©ÌïòÎêò, DB Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ Îπà Î∞∞Ïó¥ ÏÇ¨Ïö©
    const maintenanceHistories: MaintenanceHistory[] = dbHistories.length > 0 ? dbHistories : [];

    console.log('  - ÏµúÏ¢Ö ÏÇ¨Ïö©Ìï† Îç∞Ïù¥ÌÑ∞:', maintenanceHistories.length + 'Í∞ú');

    // purchaseHistory Î≥ÄÍ≤ΩÏãú Î°úÍ∑∏ Ï∂úÎ†•
    React.useEffect(() => {
      console.log('üîÑ PurchaseMaintenanceTab - purchaseHistory Î≥ÄÍ≤ΩÎê®:', purchaseHistory.length + 'Í∞ú');
      console.log('   Î≥ÄÍ≤ΩÎêú Îç∞Ïù¥ÌÑ∞:', purchaseHistory);
      console.log('   Î≥ÄÌôòÎêú maintenanceHistories:', dbHistories.length + 'Í∞ú');
      console.log('   maintenanceHistories Îç∞Ïù¥ÌÑ∞:', dbHistories);
    }, [purchaseHistory]);

    // Îçî ÎßéÏùÄ ÏÉòÌîå Îç∞Ïù¥ÌÑ∞Î°ú ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò ÌÖåÏä§Ìä∏ (Ï∞∏Í≥†Ïö© - Îçî Ïù¥ÏÉÅ ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùå)
    const [fallbackHistories] = useState<MaintenanceHistory[]>([
      {
        id: '1',
        registrationDate: '2024-01-15',
        type: 'purchase',
        content: 'Microsoft Office 365 Business Premium ÎùºÏù¥ÏÑ†Ïä§',
        vendor: 'Microsoft',
        amount: 1200000,
        registrant: 'ÍπÄÏ≤†Ïàò',
        status: 'ÏôÑÎ£å',
        startDate: '2024-01-10',
        completionDate: '2024-01-15'
      },
      {
        id: '2',
        registrationDate: '2024-06-20',
        type: 'maintenance',
        content: 'Adobe Creative Suite Ïú†ÏßÄÎ≥¥Ïàò Ïó∞Ïû•',
        vendor: 'Adobe',
        amount: 800000,
        registrant: 'Ïù¥ÏòÅÌù¨',
        status: 'ÏôÑÎ£å',
        startDate: '2024-06-15',
        completionDate: '2024-06-20'
      },
      {
        id: '3',
        registrationDate: '2024-08-01',
        type: 'upgrade',
        content: 'Slack Business+ ÌîåÎûú ÏóÖÍ∑∏Î†àÏù¥Îìú',
        vendor: 'Slack',
        amount: 500000,
        registrant: 'Î∞ïÎØºÏàò',
        status: 'ÏôÑÎ£å',
        startDate: '2024-08-01',
        completionDate: '2024-08-01'
      },
      {
        id: '4',
        registrationDate: '2024-08-05',
        type: 'renewal',
        content: 'Zoom Pro ÎùºÏù¥ÏÑ†Ïä§ Í∞±Ïã†',
        vendor: 'Zoom',
        amount: 300000,
        registrant: 'ÏµúÏùÄÏßÄ',
        status: 'ÏôÑÎ£å',
        startDate: '2024-08-03',
        completionDate: '2024-08-05'
      },
      {
        id: '5',
        registrationDate: '2024-08-10',
        type: 'purchase',
        content: 'Figma Professional ÌåÄ ÎùºÏù¥ÏÑ†Ïä§',
        vendor: 'Figma',
        amount: 450000,
        registrant: 'Ï†ïÌòÑÏö∞',
        status: 'ÏôÑÎ£å',
        startDate: '2024-08-08',
        completionDate: '2024-08-10'
      },
      {
        id: '6',
        registrationDate: '2024-08-15',
        type: 'maintenance',
        content: 'Jira Software Ïú†ÏßÄÎ≥¥Ïàò',
        vendor: 'Atlassian',
        amount: 600000,
        registrant: 'Í∞ïÏòàÎ¶∞',
        status: 'ÏßÑÌñâÏ§ë',
        startDate: '2024-08-14',
        completionDate: ''
      },
      {
        id: '7',
        registrationDate: '2024-08-20',
        type: 'upgrade',
        content: 'GitHub Enterprise ÌîåÎûú ÏóÖÍ∑∏Î†àÏù¥Îìú',
        vendor: 'GitHub',
        amount: 900000,
        registrant: 'ÏÜ°ÏßÄÌõà',
        status: 'ÏôÑÎ£å',
        startDate: '2024-08-20',
        completionDate: '2024-08-20'
      },
      {
        id: '8',
        registrationDate: '2024-08-22',
        type: 'purchase',
        content: 'Notion Team ÏõåÌÅ¨Ïä§ÌéòÏù¥Ïä§',
        vendor: 'Notion',
        amount: 200000,
        registrant: 'ÍπÄÏÜåÏòÅ',
        status: 'ÏôÑÎ£å',
        startDate: '2024-08-20',
        completionDate: '2024-08-22'
      },
      {
        id: '9',
        registrationDate: '2024-08-24',
        type: 'renewal',
        content: 'Dropbox Business ÎùºÏù¥ÏÑ†Ïä§ Í∞±Ïã†',
        vendor: 'Dropbox',
        amount: 350000,
        registrant: 'Ïù¥ÎèôÌòÑ',
        status: 'ÏßÑÌñâÏ§ë',
        startDate: '2024-08-23',
        completionDate: ''
      }
    ]);

    const [selectedRows, setSelectedRows] = useState<string[]>([]);
    const [editingCell, setEditingCell] = useState<{ id: string; field: string } | null>(null);

    // ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò ÏÉÅÌÉú
    const [currentPage, setCurrentPage] = useState(1);
    const [itemsPerPage] = useState(7);

    // Ïã†Í∑úÌñâ(ÏùåÏàò ID)ÏùÑ Îß® ÏúÑÎ°ú, Í∏∞Ï°¥ Ìñâ(ÏñëÏàò ID)ÏùÑ Í∑∏ ÏïÑÎûòÏóê Ï†ïÎ†¨
    const sortedMaintenanceHistories = [...maintenanceHistories].sort((a, b) => {
      // Ïã†Í∑úÌñâ(ÏùåÏàò ID)ÏùÑ Îß® ÏúÑÏóê Î∞∞Ïπò
      if (a.id < 0 && b.id >= 0) return -1;
      if (a.id >= 0 && b.id < 0) return 1;
      // Îëò Îã§ Ïã†Í∑úÌñâÏù¥Î©¥ ID Ïó≠Ïàú (Í∞ÄÏû• ÏµúÍ∑º Ï∂îÍ∞ÄÎêú Í≤ÉÏù¥ ÏúÑ)
      if (a.id < 0 && b.id < 0) return b.id - a.id;
      // Îëò Îã§ Í∏∞Ï°¥ ÌñâÏù¥Î©¥ ID Ïó≠Ïàú (ÏµúÏã†Ïù¥ ÏúÑ)
      return b.id - a.id;
    });

    // ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò Í≥ÑÏÇ∞
    const totalPages = Math.ceil(sortedMaintenanceHistories.length / itemsPerPage);
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    const currentItems = sortedMaintenanceHistories.slice(startIndex, endIndex);

    // ÌéòÏù¥ÏßÄ Î≥ÄÍ≤Ω Ìï∏Îì§Îü¨ (MUI Pagination ÌòïÏãùÏóê ÎßûÍ≤å ÏàòÏ†ï)
    const handlePageChange = (event: React.ChangeEvent<unknown>, page: number) => {
      setCurrentPage(page);
    };

    const handleCellClick = (id: string, field: string) => {
      setEditingCell({ id, field });
    };

    const handleCellBlur = () => {
      setEditingCell(null);
    };

    const handleAddHistory = () => {
      // ÏïàÏ†ÑÌïú Í≥†Ïú† ID ÏÉùÏÑ± (Í∏∞Ï°¥ IDÎì§Í≥º Ï§ëÎ≥µÎêòÏßÄ ÏïäÎèÑÎ°ù)
      const existingIds = purchaseHistory.map((item) => item.id || 0);
      const maxId = existingIds.length > 0 ? Math.max(...existingIds) : 0;
      const newId = Math.max(maxId + 1, Date.now());

      const newPurchaseHistory = {
        id: newId,
        purchaseDate: new Date().toISOString().split('T')[0],
        supplier: '',
        price: '0',
        quantity: 1,
        contractNumber: '',
        description: '',
        status: 'ÏßÑÌñâÏ§ë',
        memo: '',
        registrationDate: new Date().toISOString().split('T')[0]
      };

      console.log('üîÑ ÏÉà Íµ¨Îß§Ïù¥Î†• Ï∂îÍ∞Ä:', newPurchaseHistory);
      console.log('   ÌòÑÏû¨ Ïù¥Î†• Ïàò:', purchaseHistory.length);

      onAddPurchaseHistory(newPurchaseHistory);

      // ÏÉà Ìï≠Î™© Ï∂îÍ∞Ä ÌõÑ Ï≤´ Î≤àÏß∏ ÌéòÏù¥ÏßÄÎ°ú Ïù¥Îèô
      setCurrentPage(1);
    };

    const handleDeleteSelected = () => {
      selectedRows.forEach((id) => {
        const numericId = parseInt(id);
        if (!isNaN(numericId)) {
          onDeletePurchaseHistory(numericId);
        }
      });
      setSelectedRows([]);
    };

    const handleEditHistory = (id: string, field: keyof MaintenanceHistory, value: string | number) => {
      // Ìé∏ÏßëÎêú ÎÇ¥Ïö©ÏùÑ purchaseHistory ÌòïÏãùÏúºÎ°ú Î≥ÄÌôòÌïòÏó¨ Î∂ÄÎ™® Ïª¥Ìè¨ÎÑåÌä∏Ïóê Ï†ÑÎã¨
      const purchaseHistoryItem = purchaseHistory.find((item) => item.id?.toString() === id);
      if (purchaseHistoryItem) {
        const updatedItem = { ...purchaseHistoryItem };

        // MaintenanceHistory ÌïÑÎìúÎ•º PurchaseHistory ÌïÑÎìúÎ°ú Îß§Ìïë
        switch (field) {
          case 'content':
            updatedItem.description = value as string;
            break;
          case 'vendor':
            updatedItem.supplier = value as string;
            break;
          case 'amount':
            updatedItem.price = value.toString();
            break;
          case 'startDate':
            updatedItem.purchaseDate = value as string;
            break;
          case 'status':
            updatedItem.status = value as string;
            break;
          case 'registrationDate':
            updatedItem.registrationDate = value as string;
            break;
          case 'completionDate':
            // completionDateÎäî memo ÌïÑÎìúÏóê Ï†ÄÏû•ÌïòÍ±∞ÎÇò Î≥ÑÎèÑ Ï≤òÎ¶¨
            updatedItem.memo = `ÏôÑÎ£åÏùº: ${value}${updatedItem.memo ? ' | ' + updatedItem.memo.replace(/ÏôÑÎ£åÏùº: [^\|]*(\|)?/g, '').trim() : ''}`;
            break;
        }

        // Î∂ÄÎ™® Ïª¥Ìè¨ÎÑåÌä∏Ïùò purchaseHistory ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        const numericId = parseInt(id);
        if (!isNaN(numericId)) {
          onEditPurchaseHistory(numericId, updatedItem);
        }
      }
    };

    const handleSelectRow = (id: string) => {
      if (selectedRows.includes(id)) {
        setSelectedRows(selectedRows.filter((rowId) => rowId !== id));
      } else {
        setSelectedRows([...selectedRows, id]);
      }
    };

    const handleSelectAll = (event: React.ChangeEvent<HTMLInputElement>) => {
      if (event.target.checked) {
        setSelectedRows(maintenanceHistories.map((h) => h.id));
      } else {
        setSelectedRows([]);
      }
    };

    const getTypeColor = (type: string) => {
      switch (type) {
        case 'purchase':
          return { backgroundColor: '#E3F2FD', color: '#000000' }; // ÌååÏä§ÌÖî Î∏îÎ£®
        case 'maintenance':
          return { backgroundColor: '#E8F5E8', color: '#000000' }; // ÌååÏä§ÌÖî Í∑∏Î¶∞
        case 'upgrade':
          return { backgroundColor: '#FFF3E0', color: '#000000' }; // ÌååÏä§ÌÖî Ïò§Î†åÏßÄ
        case 'renewal':
          return { backgroundColor: '#F3E5F5', color: '#000000' }; // ÌååÏä§ÌÖî ÌçºÌîå
        default:
          return { backgroundColor: '#F5F5F5', color: '#000000' }; // Ïó∞Ìïú Í∑∏Î†àÏù¥
      }
    };

    const getTypeLabel = (type: string) => {
      switch (type) {
        case 'purchase':
          return 'Íµ¨Îß§';
        case 'maintenance':
          return 'Ïú†ÏßÄÎ≥¥Ïàò';
        case 'upgrade':
          return 'ÏóÖÍ∑∏Î†àÏù¥Îìú';
        case 'renewal':
          return 'Í∞±Ïã†';
        default:
          return 'Í∏∞ÌÉÄ';
      }
    };

    // GROUP017 ÎßàÏä§ÌÑ∞ÏΩîÎìúÏóêÏÑú Í∞ÄÏ†∏Ïò® Ïù¥Î†•Ïú†Ìòï ÏÇ¨Ïö© (fallbackÏúºÎ°ú Í∏∞Î≥∏Í∞í Ï†úÍ≥µ)
    const typeOptions = useMemo(
      () => (historyTypes.length > 0 ? historyTypes : ['Íµ¨Îß§', 'Ïú†ÏßÄÎ≥¥Ïàò', 'ÏóÖÍ∑∏Î†àÏù¥Îìú', 'Í∞±Ïã†']),
      [historyTypes]
    );
    const statusOptions = useMemo(() => ['ÏßÑÌñâÏ§ë', 'ÏôÑÎ£å', 'ÎßåÎ£å', 'Ìï¥ÏßÄ'], []);
    const statusColors: Record<string, string> = useMemo(
      () => ({
        ÏßÑÌñâÏ§ë: 'primary',
        ÏôÑÎ£å: 'success',
        ÎßåÎ£å: 'warning',
        Ìï¥ÏßÄ: 'error'
      }),
      []
    );

    // Ïª¨Îüº ÎÑàÎπÑ Î∞è ÎÜíÏù¥ Ï†ïÏùò (Îì±Î°ùÏûê, ÏÉÅÌÉú Ïª¨Îüº Ï†úÍ±∞)
    const columnWidths = useMemo(
      () => ({
        checkbox: 50,
        no: 60,
        type: 120,
        content: 300,
        vendor: 160,
        amount: 130,
        startDate: 110,
        completionDate: 110
      }),
      []
    );

    const cellHeight = 56;

    // ÎÇ†Ïßú ÌëúÏãú ÌòïÏãù Î≥ÄÌôò (YYYY-MM-DD -> YYYY.MM.DD)
    const formatDisplayDate = (dateStr: string): string => {
      if (!dateStr) return '';
      // YYYY-MM-DD ÌòïÏãùÏùÑ YYYY.MM.DDÎ°ú Î≥ÄÌôò
      return dateStr.replace(/-/g, '.');
    };

    // Ìé∏Ïßë Í∞ÄÎä•Ìïú ÏÖÄ Î†åÎçîÎßÅ
    const renderEditableCell = (history: MaintenanceHistory, field: string, value: string | number, options?: string[]) => {
      const isEditing = editingCell?.id === history.id && editingCell?.field === field;
      const fieldWidth = columnWidths[field as keyof typeof columnWidths] || 100;

      if (isEditing) {
        if (field === 'type') {
          // Ïú†Ìòï ÌïÑÎìúÎäî DBÏóêÏÑú Í∞ÄÏ†∏Ïò® Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©
          return (
            <Select
              value={value}
              onChange={(e) => {
                const newValue = e.target.value;
                handleEditHistory(history.id, 'type', newValue);
              }}
              onBlur={handleCellBlur}
              size="small"
              sx={{ width: '100%', minWidth: fieldWidth }}
              autoFocus
              renderValue={(selected) => {
                const item = historyTypesFromDB.find(t => t.subcode === selected);
                return item ? item.subcode_name : selected;
              }}
            >
              {historyTypesFromDB.map((option) => (
                <MenuItem key={option.subcode} value={option.subcode}>
                  {option.subcode_name}
                </MenuItem>
              ))}
            </Select>
          );
        } else if (options) {
          return (
            <Select
              value={value}
              onChange={(e) => {
                const newValue = e.target.value;
                handleEditHistory(history.id, field as keyof MaintenanceHistory, newValue);
              }}
              onBlur={handleCellBlur}
              size="small"
              sx={{ width: '100%', minWidth: fieldWidth }}
              autoFocus
            >
              {options.map((option) => (
                <MenuItem key={option} value={option}>
                  {option}
                </MenuItem>
              ))}
            </Select>
          );
        } else if (field === 'startDate' || field === 'completionDate') {
          // ÎÇ†Ïßú ÌïÑÎìúÎäî date type input ÏÇ¨Ïö©
          return (
            <TextField
              type="date"
              value={value || ''}
              onChange={(e) => handleEditHistory(history.id, field as keyof MaintenanceHistory, e.target.value)}
              onBlur={handleCellBlur}
              size="small"
              sx={{
                width: '100%',
                minWidth: fieldWidth,
                '& input': {
                  fontSize: '13px',
                  padding: '8px 12px'
                }
              }}
              InputLabelProps={{
                shrink: true
              }}
              autoFocus
            />
          );
        } else {
          return (
            <TextField
              value={value}
              onChange={(e) => handleEditHistory(history.id, field as keyof MaintenanceHistory, e.target.value)}
              onBlur={handleCellBlur}
              size="small"
              sx={{ width: '100%', minWidth: fieldWidth }}
              autoFocus
            />
          );
        }
      }

      return (
        <Box
          sx={{
            width: '100%',
            minWidth: fieldWidth,
            padding: '8px 12px',
            cursor: 'text',
            '&:hover': { backgroundColor: 'action.hover' }
          }}
        >
          {field === 'type' ? (
            <Chip
              label={getTypeLabel(value as string)}
              size="small"
              sx={{
                ...getTypeColor(value as string),
                fontSize: '12px',
                fontWeight: 500,
                borderRadius: '12px',
                height: '24px',
                minWidth: '60px'
              }}
            />
          ) : field === 'status' ? (
            <Chip
              label={value}
              size="small"
              color={statusColors[value as string] as any}
              sx={{
                fontSize: '12px',
                fontWeight: 500,
                borderRadius: '12px',
                height: '24px',
                minWidth: '60px'
              }}
            />
          ) : field === 'amount' ? (
            <Typography variant="body2" sx={{ fontSize: '13px' }}>
              {typeof value === 'number' ? `${value.toLocaleString()}Ïõê` : value || '-'}
            </Typography>
          ) : field === 'startDate' || field === 'completionDate' ? (
            <Typography variant="body2" sx={{ fontSize: '13px', color: value ? 'text.primary' : 'text.secondary' }}>
              {value ? formatDisplayDate(value as string) : '-'}
            </Typography>
          ) : (
            <Typography variant="body2" sx={{ fontSize: '13px' }}>
              {value || '-'}
            </Typography>
          )}
        </Box>
      );
    };

    return (
      <Box sx={{ height: '650px', display: 'flex', flexDirection: 'column', p: 3 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Typography variant="h6" sx={{ fontSize: '16px', fontWeight: 600 }}>
            Íµ¨Îß§/Ïú†ÏßÄÎ≥¥Ïàò Ïù¥Î†•
          </Typography>
          <Box sx={{ display: 'flex', gap: 1 }}>
            <Button
              variant="outlined"
              color="error"
              onClick={handleDeleteSelected}
              disabled={selectedRows.length === 0 || !(canEditOwn || canEditOthers)}
              size="small"
              sx={{
                '&.Mui-disabled': {
                  borderColor: 'grey.300',
                  color: 'grey.500'
                }
              }}
            >
              ÏÇ≠Ï†ú({selectedRows.length})
            </Button>
            <Button
              variant="contained"
              onClick={handleAddHistory}
              disabled={!(canEditOwn || canEditOthers)}
              size="small"
              sx={{
                fontSize: '12px',
                '&.Mui-disabled': {
                  backgroundColor: 'grey.300',
                  color: 'grey.500'
                }
              }}
            >
              Ï∂îÍ∞Ä
            </Button>
          </Box>
        </Box>

        <TableContainer
          sx={{
            flex: 1,
            overflowY: 'auto',
            overflowX: 'hidden',
            '& .MuiTable-root': {
              minWidth: 'auto'
            }
          }}
        >
          <Table size="small">
            <TableHead>
              <TableRow sx={{ backgroundColor: 'grey.50' }}>
                <TableCell padding="checkbox" sx={{ width: columnWidths.checkbox }}>
                  <Checkbox
                    checked={selectedRows.length === maintenanceHistories.length && maintenanceHistories.length > 0}
                    onChange={handleSelectAll}
                    color="primary"
                    size="small"
                    sx={{
                      transform: 'scale(0.7)',
                      '&.Mui-checked': {
                        color: '#1976d2'
                      }
                    }}
                  />
                </TableCell>
                <TableCell sx={{ width: columnWidths.no, fontWeight: 600 }}>NO</TableCell>
                <TableCell sx={{ width: columnWidths.type, fontWeight: 600 }}>Ïú†Ìòï</TableCell>
                <TableCell sx={{ width: columnWidths.content, fontWeight: 600 }}>ÎÇ¥Ïö©</TableCell>
                <TableCell sx={{ width: columnWidths.vendor, fontWeight: 600 }}>ÏóÖÏ≤¥</TableCell>
                <TableCell sx={{ width: columnWidths.amount, fontWeight: 600 }}>Í∏àÏï°</TableCell>
                <TableCell sx={{ width: columnWidths.startDate, fontWeight: 600 }}>ÏãúÏûëÏùº</TableCell>
                <TableCell sx={{ width: columnWidths.completionDate, fontWeight: 600 }}>ÏôÑÎ£åÏùº</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {currentItems.map((history, index) => (
                <TableRow
                  key={`history_${history.id}_${index}`}
                  hover
                  sx={{
                    height: cellHeight,
                    '&:hover': { backgroundColor: 'action.hover' }
                  }}
                >
                  <TableCell padding="checkbox" sx={{ width: columnWidths.checkbox }}>
                    <Checkbox
                      checked={selectedRows.includes(history.id)}
                      onChange={() => handleSelectRow(history.id)}
                      color="primary"
                      size="small"
                      sx={{
                        transform: 'scale(0.7)',
                        '&.Mui-checked': {
                          color: '#1976d2'
                        }
                      }}
                    />
                  </TableCell>
                  <TableCell sx={{ width: columnWidths.no }}>{sortedMaintenanceHistories.length - startIndex - index}</TableCell>
                  <TableCell sx={{ width: columnWidths.type }} onClick={() => handleCellClick(history.id, 'type')}>
                    {renderEditableCell(history, 'type', history.type, typeOptions)}
                  </TableCell>
                  <TableCell sx={{ width: columnWidths.content }} onClick={() => handleCellClick(history.id, 'content')}>
                    {renderEditableCell(history, 'content', history.content)}
                  </TableCell>
                  <TableCell sx={{ width: columnWidths.vendor }} onClick={() => handleCellClick(history.id, 'vendor')}>
                    {renderEditableCell(history, 'vendor', history.vendor)}
                  </TableCell>
                  <TableCell sx={{ width: columnWidths.amount }} onClick={() => handleCellClick(history.id, 'amount')}>
                    {renderEditableCell(history, 'amount', history.amount)}
                  </TableCell>
                  <TableCell sx={{ width: columnWidths.startDate }} onClick={() => handleCellClick(history.id, 'startDate')}>
                    {renderEditableCell(history, 'startDate', history.startDate)}
                  </TableCell>
                  <TableCell sx={{ width: columnWidths.completionDate }} onClick={() => handleCellClick(history.id, 'completionDate')}>
                    {renderEditableCell(history, 'completionDate', history.completionDate)}
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>

        {/* ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò - ÌïòÎã® Í≥†Ï†ï */}
        <Box
          sx={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            mt: 'auto',
            pt: 2,
            px: 2,
            borderTop: '1px solid',
            borderColor: 'divider',
            backgroundColor: 'background.paper',
            position: 'sticky',
            bottom: 0
          }}
        >
          <Typography variant="body2" color="text.secondary">
            {maintenanceHistories.length > 0
              ? `${startIndex + 1}-${Math.min(endIndex, maintenanceHistories.length)} of ${maintenanceHistories.length}`
              : '0-0 of 0'}
          </Typography>
          {totalPages > 1 && (
            <Pagination
              count={totalPages}
              page={currentPage}
              onChange={handlePageChange}
              color="primary"
              size="small"
              showFirstButton
              showLastButton
              sx={{
                '& .MuiPaginationItem-root': {
                  fontSize: '0.875rem',
                  minWidth: '32px',
                  height: '32px',
                  borderRadius: '4px'
                },
                '& .MuiPaginationItem-page.Mui-selected': {
                  backgroundColor: 'primary.main',
                  color: 'white !important',
                  borderRadius: '4px',
                  fontWeight: 500,
                  '&:hover': {
                    backgroundColor: 'primary.dark',
                    color: 'white !important'
                  }
                },
                '& .MuiPaginationItem-page': {
                  borderRadius: '4px',
                  '&:hover': {
                    backgroundColor: 'grey.100'
                  }
                }
              }}
            />
          )}
        </Box>
      </Box>
    );
  }
);

PurchaseMaintenanceTab.displayName = 'PurchaseMaintenanceTab';

// Î©îÏù∏ SoftwareEditDialog Ïª¥Ìè¨ÎÑåÌä∏
interface SoftwareEditDialogProps {
  open: boolean;
  onClose: () => void;
  task: TaskTableData | null;
  onSave: (task: TaskTableData) => void;
  assignees: string[];
  assigneeAvatars: Record<string, string>;
  statusOptions: SoftwareStatus[];
  statusColors: Record<SoftwareStatus, any>;
  canCreateData?: boolean;
  canEditOwn?: boolean;
  canEditOthers?: boolean;
}

const SoftwareEditDialog = memo(
  ({ open, onClose, task, onSave, assignees, assigneeAvatars, statusOptions, statusColors, canCreateData = true, canEditOwn = true, canEditOthers = true }: SoftwareEditDialogProps) => {
    // ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ
    // const { renderCount, logStats } = usePerformanceMonitor('TaskEditDialog');

    // Supabase ÌõÖ ÏÇ¨Ïö©
    const { createSoftware, updateSoftware } = useSupabaseSoftware();

    // ÏÑ∏ÏÖò Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
    const { data: session } = useSession();

    // GROUP015 ÏÜåÌîÑÌä∏Ïõ®Ïñ¥Î∂ÑÎ•ò ÌõÖ ÏÇ¨Ïö©
    const { softwareCategories, loading: categoriesLoading, error: categoriesError } = useGroup015();
    const { historyTypes, loading: historyTypesLoading, error: historyTypesError } = useGroup017();

    // Users ÌõÖ ÏÇ¨Ïö©
    const { users, loading: usersLoading, error: usersError } = useSupabaseUsers();

    // ÌòÑÏû¨ Î°úÍ∑∏Ïù∏Ìïú ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥
    const currentUser = React.useMemo(() => {
      if (!session?.user?.email || users.length === 0) return null;
      return users.find((u) => u.email === session.user.email);
    }, [session, users]);

    // üîê Í∂åÌïú Ï≤¥ÌÅ¨: Îç∞Ïù¥ÌÑ∞ ÏÜåÏú†Ïûê ÌôïÏù∏
    const isOwner = React.useMemo(() => {
      if (!task) {
        console.log('üîê SoftwareEditDialog - Ïã†Í∑ú ÏÉùÏÑ± Î™®Îìú: isOwner = true');
        return true; // Ïã†Í∑ú ÏÉùÏÑ±Ïù∏ Í≤ΩÏö∞ true
      }
      if (!currentUser) {
        console.log('üîê SoftwareEditDialog - ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê ÏóÜÏùå: isOwner = false');
        return false; // Î°úÍ∑∏Ïù∏ÌïòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞ false
      }

      const currentUserName = currentUser?.user_name;
      const softwareData = task as any;

      const isCreator = softwareData.createdBy === currentUserName;
      const isAssignee = task.assignee === currentUserName;
      const isOwnerResult = isCreator || isAssignee;

      console.log('üîê SoftwareEditDialog - ÏÜåÏú†Ïûê ÌôïÏù∏:', {
        taskId: task.id,
        currentUserName,
        createdBy: softwareData.createdBy,
        assignee: task.assignee,
        isCreator,
        isAssignee,
        isOwner: isOwnerResult,
        canEditOwn,
        canEditOthers,
        finalCanEdit: canEditOthers || (canEditOwn && isOwnerResult)
      });

      return isOwnerResult;
    }, [task, currentUser, canEditOwn, canEditOthers]);

    // GROUP002 ÏÉÅÌÉú ÌõÖ ÏÇ¨Ïö©
    const { statusOptions: masterStatusOptions, loading: statusLoading, error: statusError } = useGroup002();

    // GROUP016 ÎùºÏù¥ÏÑºÏä§ Ïú†Ìòï ÌõÖ ÏÇ¨Ïö©
    const { licenseTypes: masterLicenseTypes, loading: licenseLoading, error: licenseError } = useGroup016();

    // ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ ÏÇ¨Ïö©ÏûêÏù¥Î†• ÌõÖ ÏÇ¨Ïö©
    const { saveUserHistories, getUserHistories } = useSupabaseSoftwareUser();
    // ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• ÌõÖ ÏÇ¨Ïö©
    const { savePurchaseHistories, getPurchaseHistories } = useSupabaseSoftwareHistory();

    // ÌîºÎìúÎ∞± ÌõÖ
    const {
      feedbacks,
      loading: feedbackLoading,
      error: feedbackError,
      addFeedback,
      updateFeedback,
      deleteFeedback
    } = useSupabaseFeedback(PAGE_IDENTIFIERS.SOFTWARE, task?.id?.toString());

    const [editTab, setEditTab] = useState(0);
    const [draggedItemId, setDraggedItemId] = useState<number | null>(null);
    const [softwareState, dispatch] = useReducer(editSoftwareReducer, {
      softwareName: '',
      description: '',
      softwareCategory: '',
      spec: '',
      status: 'ÎåÄÍ∏∞',
      startDate: '',
      completedDate: '',
      currentUser: '',
      assignee: '',
      team: '',
      solutionProvider: '',
      userCount: 0,
      licenseType: '',
      licenseKey: '',
      registrationDate: '',
      code: ''
    });

    // ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ Î∂ÑÎ•ò ÏòµÏÖò - GROUP015ÏóêÏÑú ÎèôÏ†ÅÏúºÎ°ú Î°úÎìúÎê® (softwareCategories Î≥ÄÏàòÎäî useGroup015 ÌõÖÏóêÏÑú Ï†úÍ≥µ)

    // ÎùºÏù¥ÏÑºÏä§ Ïú†Ìòï ÏòµÏÖò (Î©îÎ™®Ïù¥Ï†úÏù¥ÏÖò)
    const licenseTypes = useMemo(
      () => ['ÏÉÅÏö© ÎùºÏù¥ÏÑºÏä§', 'Ïò§ÌîàÏÜåÏä§', 'ÌîÑÎ¶¨Ïõ®Ïñ¥', 'ÏÖ∞Ïñ¥Ïõ®Ïñ¥', 'ÏÇ¨Ïù¥Ìä∏ ÎùºÏù¥ÏÑºÏä§', 'Î≥ºÎ•® ÎùºÏù¥ÏÑºÏä§', 'Íµ¨ÎèÖÌòï', 'ÏûÑÎåÄÌòï'],
      []
    );

    // ÏΩîÎìú ÏûêÎèô ÏÉùÏÑ± Ìï®Ïàò (IT-SW-YY-NNN ÌòïÏãù)
    const generateSoftwareCode = useCallback(async () => {
      const currentYear = new Date().getFullYear();
      const currentYearStr = currentYear.toString().slice(-2); // Ïó∞ÎèÑ Îí§ 2ÏûêÎ¶¨

      try {
        // SupabaseÏóêÏÑú ÌòÑÏû¨ Ïó∞ÎèÑÏùò ÏµúÎåÄ ÏùºÎ†®Î≤àÌò∏ Ï°∞Ìöå
        const { data, error } = await supabase
          .from('it_software_data')
          .select('code')
          .like('code', `IT-SW-${currentYearStr}-%`)
          .order('code', { ascending: false })
          .limit(1);

        let nextSequence = 1;

        if (data && data.length > 0 && data[0].code) {
          // Í∏∞Ï°¥ ÏΩîÎìúÏóêÏÑú ÏùºÎ†®Î≤àÌò∏ Ï∂îÏ∂ú (IT-SW-25-001 -> 001)
          const lastCode = data[0].code;
          const sequencePart = lastCode.split('-')[3];
          if (sequencePart) {
            nextSequence = parseInt(sequencePart) + 1;
          }
        }

        // ÏùºÎ†®Î≤àÌò∏Î•º 3ÏûêÎ¶¨Î°ú Ìè¨Îß∑ (001, 002, ...)
        const formattedSequence = nextSequence.toString().padStart(3, '0');

        return `IT-SW-${currentYearStr}-${formattedSequence}`;
      } catch (error) {
        console.error('‚ùå ÏΩîÎìú ÏÉùÏÑ± Ï§ë Ïò§Î•ò:', error);
        // Ïò§Î•ò Ïãú ÏûÑÏãú ÏΩîÎìú ÏÉùÏÑ±
        const sequence = String(Date.now()).slice(-3);
        return `IT-SW-${currentYearStr}-${sequence}`;
      }
    }, []);

    // ÌòÑÏû¨ ÎÇ†Ïßú ÏÉùÏÑ± Ìï®Ïàò
    const getCurrentDate = useCallback(() => {
      const today = new Date();
      return today.toISOString().split('T')[0]; // YYYY-MM-DD ÌòïÏãù
    }, []);

    // Software Î≥ÄÍ≤Ω Ïãú ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
    React.useEffect(() => {
      if (task) {
        dispatch({ type: 'SET_SOFTWARE', software: task });
      } else if (open) {
        // ÏÉà Software ÏÉùÏÑ± Ïãú ÏûêÎèôÏúºÎ°ú ÏΩîÎìúÏôÄ Îì±Î°ùÏùº ÏÑ§Ï†ï
        const initializeNewSoftware = async () => {
          try {
            console.log('üÜï ÏÉà ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ ÏΩîÎìú ÏÉùÏÑ± ÏãúÏûë...');
            const newCode = await generateSoftwareCode();
            const newRegistrationDate = getCurrentDate();
            console.log('‚úÖ ÏÉùÏÑ±Îêú ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ ÏΩîÎìú:', newCode);
            dispatch({ type: 'INIT_NEW_SOFTWARE', code: newCode, registrationDate: newRegistrationDate });
          } catch (error) {
            console.error('‚ùå ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ ÏΩîÎìú ÏÉùÏÑ± Ïã§Ìå®:', error);
            // Ïã§Ìå® Ïãú ÏûÑÏãú ÏΩîÎìú ÏÇ¨Ïö©
            const currentYear = new Date().getFullYear().toString().slice(-2);
            const tempCode = `IT-SW-${currentYear}-TMP`;
            const newRegistrationDate = getCurrentDate();
            dispatch({ type: 'INIT_NEW_SOFTWARE', code: tempCode, registrationDate: newRegistrationDate });
          }
        };

        initializeNewSoftware();
      }
    }, [task, open]);

    // ÏÉà ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ ÏÉùÏÑ± Ïãú ÌåÄÍ≥º Îã¥ÎãπÏûê ÏûêÎèô ÏÑ§Ï†ï
    React.useEffect(() => {
      if (!task && open && currentUser) {
        // ÌåÄÍ≥º Îã¥ÎãπÏûêÍ∞Ä ÎπÑÏñ¥ÏûàÏùÑ ÎïåÎßå ÏÑ§Ï†ï
        if (!softwareState.team && currentUser.department) {
          dispatch({ type: 'SET_FIELD', field: 'team', value: currentUser.department });
        }
        if (!softwareState.assignee && currentUser.user_name) {
          dispatch({ type: 'SET_FIELD', field: 'assignee', value: currentUser.user_name });
        }
      }
    }, [task, open, currentUser, softwareState.team, softwareState.assignee]);

    // ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ Î°úÍ∑∏ Ï†úÍ±∞ (ÌîÑÎ°úÎçïÏÖò Ï§ÄÎπÑ)
    // useEffect(() => {
    //   if (process.env.NODE_ENV === 'development' && renderCount > 1) {
    //     console.log(`üîÑ TaskEditDialog Î†åÎçîÎßÅ ÌöüÏàò: ${renderCount}`);
    //     if (renderCount % 10 === 0) {
    //       const stats = logStats();
    //       console.log('üìä TaskEditDialog ÏÑ±Îä• ÌÜµÍ≥Ñ:', stats);
    //     }
    //   }
    // }, [renderCount, logStats]);

    // Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏ ÏÉÅÌÉú (Í≥ÑÏ∏µ Íµ¨Ï°∞ ÏßÄÏõê)
    const [checklistItems, setChecklistItems] = useState<
      Array<{
        id: number;
        text: string;
        checked: boolean;
        parentId?: number;
        level: number;
        expanded: boolean;
        status?: string;
        dueDate?: string;
        progressRate?: number;
        assignee?: string;
      }>
    >([]);
    const [newChecklistText, setNewChecklistText] = useState('');
    const [editingChecklistId, setEditingChecklistId] = useState<number | null>(null);
    const [editingChecklistText, setEditingChecklistText] = useState('');

    // ÏΩîÎ©òÌä∏ ÏÉÅÌÉú - feedbacksÏóêÏÑú Î≥ÄÌôò
    const comments = useMemo(() => {
      return feedbacks.map((feedback) => {
        // user_nameÏúºÎ°ú ÏÇ¨Ïö©Ïûê Ï∞æÍ∏∞
        const feedbackUser = users.find((u) => u.user_name === feedback.user_name);

        return {
          id: feedback.id,
          author: feedback.user_name,
          content: feedback.description,
          timestamp: new Date(feedback.created_at).toLocaleString('ko-KR'),
          avatar: feedback.user_profile_image || feedbackUser?.profile_image_url || undefined,
          department: feedback.user_department || feedback.team || feedbackUser?.department || '',
          position: feedback.user_position || feedbackUser?.position || '',
          role: feedback.metadata?.role || feedbackUser?.role || ''
        };
      });
    }, [feedbacks, users]);

    const [newComment, setNewComment] = useState('');
    const [editingCommentId, setEditingCommentId] = useState<string | null>(null);
    const [editingCommentText, setEditingCommentText] = useState('');

    // ÏÇ¨Ïö©ÏûêÏù¥Î†• ÏÉÅÌÉú (DB Ïó∞Îèô)
    const [currentUserHistories, setCurrentUserHistories] = useState<UserHistory[]>([]);

    // Í∏∞Ï°¥ ÏÇ¨Ïö©ÏûêÏù¥Î†• ÏÉÅÌÉú (Ìò∏ÌôòÏÑ± Ïú†ÏßÄ)
    const [userHistory, setUserHistory] = useState<
      Array<{
        id: number;
        userName: string;
        department: string;
        startDate: string;
        endDate: string;
        status: string;
        memo: string;
        registrationDate: string;
      }>
    >([]);
    const [editingUserHistoryId, setEditingUserHistoryId] = useState<number | null>(null);
    const [editingUserHistoryData, setEditingUserHistoryData] = useState<any>({});

    // Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• ÏÉÅÌÉú
    const [purchaseHistory, setPurchaseHistory] = useState<
      Array<{
        id: number;
        type: string;
        vendor: string;
        amount: string;
        contractDate: string;
        startDate: string;
        endDate: string;
        status: string;
        memo: string;
        registrationDate: string;
      }>
    >([]);
    const [editingPurchaseHistoryId, setEditingPurchaseHistoryId] = useState<number | null>(null);
    const [editingPurchaseHistoryData, setEditingPurchaseHistoryData] = useState<any>({});

    // ÏóêÎü¨ ÏÉÅÌÉú
    const [validationError, setValidationError] = useState<string>('');

    // ÏµúÏ†ÅÌôîÎêú Ìï∏Îì§Îü¨Îì§
    const handleFieldChange = useCallback((field: keyof EditSoftwareState, value: string | number) => {
      dispatch({ type: 'SET_FIELD', field, value });
    }, []);

    const handleTabChange = useCallback((event: React.SyntheticEvent, newValue: number) => {
      setEditTab(newValue);
    }, []);

    const handleSave = useCallback(async () => {
      try {
        // ÌïÑÏàò ÏûÖÎ†• Í≤ÄÏ¶ù
        if (!softwareState.softwareName || !softwareState.softwareName.trim()) {
          setValidationError('ÏÜåÌîÑÌä∏Ïõ®Ïñ¥Î™ÖÏùÄ ÌïÑÏàò ÏûÖÎ†• Ìï≠Î™©ÏûÖÎãàÎã§.');
          return;
        }

        if (!softwareState.assignee || !softwareState.assignee.trim()) {
          setValidationError('Îã¥ÎãπÏûêÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
          return;
        }

        if (!softwareState.softwareCategory || !softwareState.softwareCategory.trim()) {
          setValidationError('ÏÜåÌîÑÌä∏Ïõ®Ïñ¥Î∂ÑÎ•òÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
          return;
        }

        if (!softwareState.solutionProvider || !softwareState.solutionProvider.trim()) {
          setValidationError('ÏÜîÎ£®ÏÖòÏóÖÏ≤¥Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
          return;
        }

        if (!softwareState.licenseType || !softwareState.licenseType.trim()) {
          setValidationError('ÎùºÏù¥ÏÑºÏä§Ïú†ÌòïÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
          return;
        }

        // ÏóêÎü¨ Ï¥àÍ∏∞Ìôî
        setValidationError('');

        console.log('üíæ ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• ÏãúÏûë...');

        // SupabaseÏóê Ï†ÄÏû•Ìï† Îç∞Ïù¥ÌÑ∞ Ï§ÄÎπÑ
        const softwareData: Partial<SoftwareData> = {
          software_name: softwareState.softwareName?.trim() || '',
          work_content: softwareState.softwareName?.trim() || '',
          description: softwareState.description?.trim() || '',
          software_category: softwareState.softwareCategory?.trim() || '',
          spec: softwareState.spec?.trim() || '',
          status: softwareState.status || 'ÎåÄÍ∏∞',
          assignee: softwareState.assignee?.trim() || '',
          current_users: softwareState.currentUser?.trim() || '',
          solution_provider: softwareState.solutionProvider?.trim() || '',
          user_count: Number(softwareState.userCount) || 0,
          license_type: softwareState.licenseType?.trim() || '',
          license_key: softwareState.licenseKey?.trim() || '',
          start_date: softwareState.startDate
            ? softwareState.startDate.includes('T')
              ? softwareState.startDate.split('T')[0]
              : softwareState.startDate
            : new Date().toISOString().split('T')[0],
          completed_date: softwareState.completedDate
            ? softwareState.completedDate.includes('T')
              ? softwareState.completedDate.split('T')[0]
              : softwareState.completedDate
            : null,
          code: softwareState.code?.trim() || '',
          team: softwareState.team?.trim() || '',
          department: 'IT'
        };

        let savedData;

        if (!task || !task.id) {
          // ÏÉà Software ÏÉùÏÑ±
          console.log('üÜï ÏÉà ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ ÏÉùÏÑ±:', softwareData);
          savedData = await createSoftware(softwareData);
        } else {
          // Í∏∞Ï°¥ Software ÏàòÏ†ï
          if (!task.id || task.id <= 0) {
            throw new Error('Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ IDÏûÖÎãàÎã§.');
          }

          console.log('üîÑ ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ ÏàòÏ†ï:', { id: task.id, data: softwareData });
          savedData = await updateSoftware(task.id, softwareData);
        }

        console.log('‚úÖ Supabase Ï†ÄÏû• ÏÑ±Í≥µ:', savedData);

        // ÏÇ¨Ïö©ÏûêÏù¥Î†• Ï†ÄÏû• (data_relation.md Ìå®ÌÑ¥ Ï†ÅÏö©)
        console.log('üîç ÏÇ¨Ïö©ÏûêÏù¥Î†• Ï†ÄÏû• Ï≤¥ÌÅ¨:');
        console.log('  - currentUserHistories.length:', currentUserHistories.length);
        console.log('  - currentUserHistories:', JSON.stringify(currentUserHistories, null, 2));
        console.log('  - savedData:', savedData);
        console.log('  - savedData?.id:', savedData?.id);
        console.log('  - typeof savedData?.id:', typeof savedData?.id);

        if (currentUserHistories.length > 0) {
          if (!savedData?.id) {
            console.error('‚ùå ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ IDÍ∞Ä ÏóÜÏñ¥ÏÑú ÏÇ¨Ïö©ÏûêÏù¥Î†•ÏùÑ Ï†ÄÏû•Ìï† Ïàò ÏóÜÏäµÎãàÎã§.');
            console.error('  savedData Ï†ÑÏ≤¥:', JSON.stringify(savedData, null, 2));
          } else {
            console.log('üíæ ÏÇ¨Ïö©ÏûêÏù¥Î†• Ï†ÄÏû• ÏãúÏûë...', {
              softwareId: savedData.id,
              userCount: currentUserHistories.length,
              users: currentUserHistories
            });

            try {
              const userHistorySaveResult = await saveUserHistories(savedData.id, currentUserHistories);

              if (userHistorySaveResult) {
                console.log('‚úÖ ÏÇ¨Ïö©ÏûêÏù¥Î†• Ï†ÄÏû• ÏÑ±Í≥µ');
              } else {
                console.warn('‚ö†Ô∏è ÏÇ¨Ïö©ÏûêÏù¥Î†• Ï†ÄÏû• Ïã§Ìå® - ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ Îç∞Ïù¥ÌÑ∞Îäî Ï†ÄÏû•Îê®');
              }
            } catch (saveError) {
              console.error('‚ùå ÏÇ¨Ïö©ÏûêÏù¥Î†• Ï†ÄÏû• Ï§ë ÏòàÏô∏ Î∞úÏÉù:', saveError);
            }
          }
        } else {
          console.log('‚ÑπÔ∏è Ï†ÄÏû•Ìï† ÏÇ¨Ïö©ÏûêÏù¥Î†•Ïù¥ ÏóÜÏäµÎãàÎã§.');
        }

        // Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Ï†ÄÏû• (data_relation.md Ìå®ÌÑ¥)
        console.log('üîç Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Ï†ÄÏû• Ï≤¥ÌÅ¨:');
        console.log('  - purchaseHistory.length:', purchaseHistory.length);
        console.log('  - savedData?.id:', savedData?.id);

        if (purchaseHistory.length > 0) {
          if (!savedData?.id) {
            console.error('‚ùå ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ IDÍ∞Ä ÏóÜÏñ¥ÏÑú Íµ¨Îß§Ïù¥Î†•ÏùÑ Ï†ÄÏû•Ìï† Ïàò ÏóÜÏäµÎãàÎã§.');
          } else {
            console.log('üíæ Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Ï†ÄÏû• ÏãúÏûë...', {
              softwareId: savedData.id,
              historyCount: purchaseHistory.length,
              histories: purchaseHistory
            });

            try {
              const purchaseHistorySaveResult = await savePurchaseHistories(savedData.id, purchaseHistory);

              if (purchaseHistorySaveResult) {
                console.log('‚úÖ Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Ï†ÄÏû• ÏÑ±Í≥µ');
              } else {
                console.warn('‚ö†Ô∏è Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Ï†ÄÏû• Ïã§Ìå® - ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ Îç∞Ïù¥ÌÑ∞Îäî Ï†ÄÏû•Îê®');
              }
            } catch (saveError) {
              console.error('‚ùå Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Ï†ÄÏû• Ï§ë ÏòàÏô∏ Î∞úÏÉù:', saveError);
            }
          }
        } else {
          console.log('‚ÑπÔ∏è Ï†ÄÏû•Ìï† Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†•Ïù¥ ÏóÜÏäµÎãàÎã§.');
        }

        // TaskTableData ÌòïÏãùÏúºÎ°ú Î≥ÄÌôòÌïòÏó¨ Î∂ÄÎ™® Ïª¥Ìè¨ÎÑåÌä∏Ïóê Ï†ÑÎã¨
        const resultTask: TaskTableData = {
          id: savedData.id || task?.id || Date.now(),
          no: savedData.no || Date.now(),
          workContent: softwareState.softwareName,
          assignee: softwareState.assignee,
          status: softwareState.status as any,
          code: softwareState.code,
          registrationDate: savedData.registration_date || softwareState.registrationDate,
          startDate: softwareState.startDate || new Date().toISOString().split('T')[0],
          completedDate: softwareState.completedDate,
          description: softwareState.description,
          softwareName: softwareState.softwareName,
          softwareCategory: softwareState.softwareCategory,
          spec: softwareState.spec,
          currentUser: softwareState.currentUser,
          solutionProvider: softwareState.solutionProvider,
          userCount: softwareState.userCount,
          licenseType: softwareState.licenseType,
          licenseKey: softwareState.licenseKey,
          attachments: [],
          team: 'Í∞úÎ∞úÌåÄ' as any,
          department: 'IT' as any
        };

        onSave(resultTask);
        onClose();
      } catch (error: any) {
        console.error('‚ùå ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ Ï†ÄÏû• Ïã§Ìå®:', error);
        setValidationError(error.message || 'Ï†ÄÏû• Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
      }
    }, [
      task,
      softwareState,
      onSave,
      onClose,
      createSoftware,
      updateSoftware,
      currentUserHistories,
      saveUserHistories,
      purchaseHistory,
      savePurchaseHistories
    ]);

    const handleClose = useCallback(() => {
      setEditTab(0);
      dispatch({ type: 'RESET' });
      setChecklistItems([]);
      setUserHistory([]);
      setPurchaseHistory([]);
      setPurchaseHistoryLoaded(false); // Íµ¨Îß§Ïù¥Î†• Î°úÎìú ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
      setNewComment('');
      setNewChecklistText('');
      setValidationError(''); // ÏóêÎü¨ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
      onClose();
    }, [onClose]);

    // Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏ Ìï∏Îì§Îü¨Îì§
    const handleAddChecklistItem = useCallback(() => {
      if (!newChecklistText.trim()) return;

      const newItem = {
        id: Date.now(),
        text: newChecklistText.trim(),
        checked: false,
        level: 0,
        expanded: true,
        status: 'Í≥ÑÌöçÏ§ë',
        dueDate: '',
        progressRate: 0,
        assignee: 'ÍπÄÏ≤†Ïàò' // Í∏∞Î≥∏ Îã¥ÎãπÏûê
      };

      setChecklistItems((prev) => [...prev, newItem]);
      setNewChecklistText('');
    }, [newChecklistText]);

    const handleEditChecklistItem = useCallback((id: number, text: string) => {
      setEditingChecklistId(id);
      setEditingChecklistText(text);
    }, []);

    const handleSaveEditChecklistItem = useCallback(() => {
      if (!editingChecklistText.trim() || editingChecklistId === null) return;

      setChecklistItems((prev) =>
        prev.map((item) => (item.id === editingChecklistId ? { ...item, text: editingChecklistText.trim() } : item))
      );

      setEditingChecklistId(null);
      setEditingChecklistText('');
    }, [editingChecklistText, editingChecklistId]);

    const handleCancelEditChecklistItem = useCallback(() => {
      setEditingChecklistId(null);
      setEditingChecklistText('');
    }, []);

    const handleDeleteChecklistItem = useCallback((id: number) => {
      setChecklistItems((prev) => {
        // ÏÇ≠Ï†úÌï† Ìï≠Î™©Í≥º Í∑∏ ÌïòÏúÑ Ìï≠Î™©Îì§ÏùÑ Î™®Îëê Ï∞æÍ∏∞
        const findAllChildren = (parentId: number): number[] => {
          const children = prev.filter((item) => item.parentId === parentId).map((item) => item.id);
          const allChildren = [...children];
          children.forEach((childId) => {
            allChildren.push(...findAllChildren(childId));
          });
          return allChildren;
        };

        const toDelete = [id, ...findAllChildren(id)];
        return prev.filter((item) => !toDelete.includes(item.id));
      });
    }, []);

    // ÎìúÎûòÍ∑∏ Ïï§ ÎìúÎ°≠ Ìï∏Îì§Îü¨Îì§
    const handleDragStart = useCallback((e: React.DragEvent, itemId: number) => {
      e.dataTransfer.setData('text/plain', itemId.toString());
      e.dataTransfer.effectAllowed = 'move';
      setDraggedItemId(itemId);
    }, []);

    const handleDragOver = useCallback((e: React.DragEvent) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
    }, []);

    const handleDragEnd = useCallback(() => {
      setDraggedItemId(null);
    }, []);

    const handleDrop = useCallback((e: React.DragEvent, targetId: number) => {
      e.preventDefault();
      const draggedId = parseInt(e.dataTransfer.getData('text/plain'));

      if (draggedId === targetId) return; // ÏûêÍ∏∞ ÏûêÏã†ÏóêÍ≤åÎäî ÎìúÎ°≠ Î∂àÍ∞Ä

      setChecklistItems((prev) => {
        // ÏàúÌôò Ï∞∏Ï°∞ Î∞©ÏßÄ: ÎìúÎûòÍ∑∏Îêú Ìï≠Î™©Ïù¥ ÌÉÄÍ≤üÏùò ÏÉÅÏúÑÏù∏ÏßÄ ÌôïÏù∏
        const isParentOf = (parentId: number, childId: number): boolean => {
          const child = prev.find((item) => item.id === childId);
          if (!child || !child.parentId) return false;
          if (child.parentId === parentId) return true;
          return isParentOf(parentId, child.parentId);
        };

        if (isParentOf(draggedId, targetId)) return prev; // ÏàúÌôò Ï∞∏Ï°∞ Î∞©ÏßÄ

        const target = prev.find((item) => item.id === targetId);
        if (!target) return prev;

        return prev.map((item) => {
          if (item.id === draggedId) {
            return {
              ...item,
              parentId: targetId,
              level: target.level + 1
            };
          }
          return item;
        });
      });

      // ÌÉÄÍ≤ü Ìï≠Î™©ÏùÑ ÏûêÎèôÏúºÎ°ú ÌéºÏπòÍ∏∞
      setChecklistItems((prev) => prev.map((item) => (item.id === targetId ? { ...item, expanded: true } : item)));

      // ÎìúÎûòÍ∑∏ ÏôÑÎ£å ÌõÑ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
      setDraggedItemId(null);
    }, []);

    // Ï†ëÍ∏∞/ÌéºÏπòÍ∏∞ Ìï∏Îì§Îü¨
    const handleToggleExpanded = useCallback((id: number) => {
      setChecklistItems((prev) => prev.map((item) => (item.id === id ? { ...item, expanded: !item.expanded } : item)));
    }, []);

    const handleToggleChecklistItem = useCallback((index: number) => {
      setChecklistItems((prev) => prev.map((item, i) => (i === index ? { ...item, checked: !item.checked } : item)));
    }, []);

    // Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏ ÏÉÅÌÉú Î≥ÄÍ≤Ω Ìï∏Îì§Îü¨
    const handleChecklistStatusChange = useCallback((id: number, status: string) => {
      setChecklistItems((prev) =>
        prev.map((item) =>
          item.id === id
            ? {
                ...item,
                status,
                progressRate: status === 'ÏôÑÎ£å' ? 100 : status === 'Ï∑®ÏÜå' ? 0 : item.progressRate
              }
            : item
        )
      );
    }, []);

    // Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏ ÏôÑÎ£åÏùº Î≥ÄÍ≤Ω Ìï∏Îì§Îü¨
    const handleChecklistDueDateChange = useCallback((id: number, dueDate: string) => {
      setChecklistItems((prev) => prev.map((item) => (item.id === id ? { ...item, dueDate } : item)));
    }, []);

    // Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏ ÏßÑÏ≤ôÏú® Î≥ÄÍ≤Ω Ìï∏Îì§Îü¨
    const handleChecklistProgressRateChange = useCallback((id: number, progressRate: number) => {
      setChecklistItems((prev) => prev.map((item) => (item.id === id ? { ...item, progressRate } : item)));
    }, []);

    // ÏΩîÎ©òÌä∏ Ìï∏Îì§Îü¨Îì§
    const handleAddComment = useCallback(async () => {
      if (!newComment.trim() || !task?.id) return;

      const currentUserName = currentUser?.user_name || 'ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê';
      const currentTeam = currentUser?.department || '';
      const currentPosition = currentUser?.position || '';
      const currentProfileImage = currentUser?.profile_image_url || '';
      const currentRole = currentUser?.role || '';

      await addFeedback({
        page: PAGE_IDENTIFIERS.SOFTWARE,
        record_id: task.id.toString(),
        action_type: 'Í∏∞Î°ù',
        description: newComment,
        user_name: currentUserName,
        team: currentTeam,
        user_department: currentTeam,
        user_position: currentPosition,
        user_profile_image: currentProfileImage,
        metadata: { role: currentRole }
      });

      setNewComment('');
    }, [newComment, task?.id, addFeedback, currentUser]);

    const handleEditComment = useCallback((commentId: string, content: string) => {
      setEditingCommentId(commentId);
      setEditingCommentText(content);
    }, []);

    const handleSaveEditComment = useCallback(async () => {
      if (!editingCommentText.trim() || !editingCommentId) return;

      await updateFeedback(editingCommentId, {
        description: editingCommentText
      });

      setEditingCommentId(null);
      setEditingCommentText('');
    }, [editingCommentText, editingCommentId, updateFeedback]);

    const handleCancelEditComment = useCallback(() => {
      setEditingCommentId(null);
      setEditingCommentText('');
    }, []);

    const handleDeleteComment = useCallback(
      async (commentId: string) => {
        await deleteFeedback(commentId);
      },
      [deleteFeedback]
    );

    // ÏÇ¨Ïö©ÏûêÏù¥Î†• Ìï∏Îì§Îü¨Îì§
    const handleAddUserHistory = useCallback((userHistoryItem: any) => {
      setUserHistory((prev) => [...prev, userHistoryItem]);
    }, []);

    const handleEditUserHistory = useCallback((id: number, data: any) => {
      setEditingUserHistoryId(id);
      setEditingUserHistoryData(data);
    }, []);

    const handleSaveEditUserHistory = useCallback(() => {
      if (!editingUserHistoryData || editingUserHistoryId === null) return;

      setUserHistory((prev) => prev.map((item) => (item.id === editingUserHistoryId ? { ...item, ...editingUserHistoryData } : item)));

      setEditingUserHistoryId(null);
      setEditingUserHistoryData({});
    }, [editingUserHistoryData, editingUserHistoryId]);

    const handleCancelEditUserHistory = useCallback(() => {
      setEditingUserHistoryId(null);
      setEditingUserHistoryData({});
    }, []);

    const handleDeleteUserHistory = useCallback((id: number) => {
      setUserHistory((prev) => prev.filter((item) => item.id !== id));
    }, []);

    const handleEditUserHistoryDataChange = useCallback((data: any) => {
      setEditingUserHistoryData(data);
    }, []);

    // Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Ìï∏Îì§Îü¨Îì§
    const handleAddPurchaseHistory = useCallback((purchaseHistoryItem: any) => {
      console.log('üìù Î©îÏù∏ Ïª¥Ìè¨ÎÑåÌä∏ - Íµ¨Îß§Ïù¥Î†• Ï∂îÍ∞Ä:', purchaseHistoryItem);
      console.log('   Ï∂îÍ∞ÄÌïòÎ†§Îäî ÏïÑÏù¥ÌÖú ID:', purchaseHistoryItem.id);
      setPurchaseHistory((prev) => {
        console.log('   Ïù¥Ï†Ñ Ïù¥Î†•:', prev.length + 'Í∞ú', prev);
        // ID Ï§ëÎ≥µ Ï≤¥ÌÅ¨
        const existingIds = prev.map((item) => item.id);
        console.log('   Í∏∞Ï°¥ IDÎì§:', existingIds);

        if (existingIds.includes(purchaseHistoryItem.id)) {
          console.warn('‚ö†Ô∏è Ï§ëÎ≥µ ID Í∞êÏßÄ! ID:', purchaseHistoryItem.id);
          return prev; // Ï§ëÎ≥µÏù¥Î©¥ Ï∂îÍ∞ÄÌïòÏßÄ ÏïäÏùå
        }

        const updated = [...prev, purchaseHistoryItem];
        console.log('   ÏóÖÎç∞Ïù¥Ìä∏Îêú Ïù¥Î†•:', updated.length + 'Í∞ú', updated);
        return updated;
      });
    }, []);

    const handleEditPurchaseHistory = useCallback((id: number, data: any) => {
      // ÏßÅÏ†ë purchaseHistory ÏÉÅÌÉúÎ•º ÏóÖÎç∞Ïù¥Ìä∏
      setPurchaseHistory((prev) => prev.map((item) => (item.id === id ? { ...item, ...data } : item)));
    }, []);

    const handleSaveEditPurchaseHistory = useCallback(() => {
      if (!editingPurchaseHistoryData || editingPurchaseHistoryId === null) return;

      setPurchaseHistory((prev) =>
        prev.map((item) => (item.id === editingPurchaseHistoryId ? { ...item, ...editingPurchaseHistoryData } : item))
      );

      setEditingPurchaseHistoryId(null);
      setEditingPurchaseHistoryData({});
    }, [editingPurchaseHistoryData, editingPurchaseHistoryId]);

    const handleCancelEditPurchaseHistory = useCallback(() => {
      setEditingPurchaseHistoryId(null);
      setEditingPurchaseHistoryData({});
    }, []);

    const handleDeletePurchaseHistory = useCallback((id: number) => {
      setPurchaseHistory((prev) => prev.filter((item) => item.id !== id));
    }, []);

    const handleEditPurchaseHistoryDataChange = useCallback((data: any) => {
      setEditingPurchaseHistoryData(data);
    }, []);

    // ÏÇ¨Ïö©ÏûêÏù¥Î†• Î≥ÄÍ≤Ω Ìï∏Îì§Îü¨
    const handleUserHistoriesChange = useCallback((histories: UserHistory[]) => {
      setCurrentUserHistories(histories);
    }, []);

    // Ìé∏Ïßë Î™®ÎìúÏùº Îïå Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Î°úÎìú (Ìïú Î≤àÎßå Ïã§Ìñâ)
    const [purchaseHistoryLoaded, setPurchaseHistoryLoaded] = useState(false);

    // taskÍ∞Ä Î≥ÄÍ≤ΩÎê† ÎïåÎßàÎã§ Íµ¨Îß§Ïù¥Î†• Î°úÎìú ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
    useEffect(() => {
      setPurchaseHistoryLoaded(false);
      setPurchaseHistory([]);
    }, [task?.id]);

    // Íµ¨Îß§Ïù¥Î†• Î°úÎìú
    useEffect(() => {
      if (task && task.id && task.id > 0 && !purchaseHistoryLoaded) {
        const loadPurchaseHistories = async () => {
          console.log('üìñ Ìé∏Ïßë Î™®Îìú - Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Î°úÎìú Ï§ë...', task.id);
          setPurchaseHistoryLoaded(true);
          try {
            const histories = await getPurchaseHistories(task.id);
            if (histories && histories.length > 0) {
              console.log('‚úÖ Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Î°úÎìú ÏÑ±Í≥µ:', histories.length + 'Í∞ú');
              setPurchaseHistory(histories);
            } else {
              console.log('‚ÑπÔ∏è Ï†ÄÏû•Îêú Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†•Ïù¥ ÏóÜÏäµÎãàÎã§.');
              setPurchaseHistory([]);
            }
          } catch (error) {
            console.warn('‚ö†Ô∏è Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†• Î°úÎìú Ï§ë Ïò§Î•ò:', error);
            setPurchaseHistory([]);
          }
        };

        loadPurchaseHistories();
      }
    }, [task?.id, purchaseHistoryLoaded, getPurchaseHistories]);

    // Î©îÎ™®Ïù¥Ï†úÏù¥ÏÖòÎêú ÌÉ≠ Ïª¥Ìè¨ÎÑåÌä∏ props
    const overviewTabProps = useMemo(
      () => ({
        softwareState,
        onFieldChange: handleFieldChange,
        users,
        usersLoading,
        usersError,
        softwareCategories,
        licenseTypes,
        statusOptions,
        statusColors,
        categoriesLoading,
        categoriesError,
        statusLoading,
        statusError,
        masterStatusOptions,
        licenseLoading,
        licenseError,
        masterLicenseTypes
      }),
      [
        softwareState,
        users,
        usersLoading,
        usersError,
        categoriesLoading,
        categoriesError,
        statusLoading,
        statusError,
        licenseLoading,
        licenseError
      ]
    );

    const userHistoryTabProps = useMemo(
      () => ({
        softwareId: task?.id || 0,
        mode: task ? ('edit' as const) : ('add' as const),
        userHistories: currentUserHistories,
        onUserHistoriesChange: handleUserHistoriesChange
      }),
      [task, currentUserHistories, handleUserHistoriesChange]
    );

    const recordTabProps = useMemo(
      () => ({
        comments,
        newComment,
        onNewCommentChange: setNewComment,
        onAddComment: handleAddComment,
        editingCommentId,
        editingCommentText,
        onEditComment: handleEditComment,
        onSaveEditComment: handleSaveEditComment,
        onCancelEditComment: handleCancelEditComment,
        onDeleteComment: handleDeleteComment,
        onEditCommentTextChange: setEditingCommentText,
        currentUserName: currentUser?.user_name,
        currentUserAvatar: currentUser?.profile_image_url,
        currentUserRole: currentUser?.role,
        currentUserDepartment: currentUser?.department
      }),
      [
        comments,
        newComment,
        editingCommentId,
        editingCommentText,
        handleAddComment,
        handleEditComment,
        handleSaveEditComment,
        handleCancelEditComment,
        handleDeleteComment,
        currentUser
      ]
    );

    const purchaseMaintenanceTabProps = useMemo(
      () => ({
        purchaseHistory,
        historyTypes,
        onAddPurchaseHistory: handleAddPurchaseHistory,
        editingPurchaseHistoryId,
        editingPurchaseHistoryData,
        onEditPurchaseHistory: handleEditPurchaseHistory,
        onSaveEditPurchaseHistory: handleSaveEditPurchaseHistory,
        onCancelEditPurchaseHistory: handleCancelEditPurchaseHistory,
        onDeletePurchaseHistory: handleDeletePurchaseHistory,
        onEditPurchaseHistoryDataChange: handleEditPurchaseHistoryDataChange
      }),
      [
        purchaseHistory,
        historyTypes,
        editingPurchaseHistoryId,
        editingPurchaseHistoryData,
        handleAddPurchaseHistory,
        handleEditPurchaseHistory,
        handleSaveEditPurchaseHistory,
        handleCancelEditPurchaseHistory,
        handleDeletePurchaseHistory,
        handleEditPurchaseHistoryDataChange
      ]
    );

    return (
      <Dialog
        open={open}
        onClose={handleClose}
        maxWidth="lg"
        fullWidth
        PaperProps={{
          sx: {
            height: '840px',
            maxHeight: '840px',
            overflow: 'hidden'
          }
        }}
      >
        <DialogTitle sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', pr: 2, pt: 2 }}>
          <Box>
            <Typography variant="h6" component="div" sx={{ fontSize: '14px', color: 'rgba(0, 0, 0, 0.75)', fontWeight: 500 }}>
              ÏÜåÌîÑÌä∏Ïõ®Ïñ¥Í¥ÄÎ¶¨ Ìé∏Ïßë
            </Typography>
            {task && (
              <Typography variant="body2" sx={{ fontSize: '12px', color: '#666666', fontWeight: 500 }}>
                {(task as any).softwareName || task.workContent} ({task.code})
              </Typography>
            )}
          </Box>

          {/* üîê Í∂åÌïú Ï≤¥ÌÅ¨: ÏÉà ÏÜåÌîÑÌä∏Ïõ®Ïñ¥(task null)Îäî canCreateData/canEditOwn, Í∏∞Ï°¥ ÏÜåÌîÑÌä∏Ïõ®Ïñ¥Îäî canEditOthers ÎòêÎäî (canEditOwn && isOwner) */}
          <Box sx={{ display: 'flex', gap: 1, mt: 0.5 }}>
            <Button
              onClick={handleClose}
              variant="outlined"
              size="small"
              disabled={!task ? !(canCreateData || canEditOwn) : !(canEditOthers || (canEditOwn && isOwner))}
              sx={{
                minWidth: '60px',
                '&.Mui-disabled': {
                  borderColor: 'grey.300',
                  color: 'grey.500'
                }
              }}
            >
              Ï∑®ÏÜå
            </Button>
            <Button
              onClick={handleSave}
              variant="contained"
              size="small"
              disabled={!task ? !(canCreateData || canEditOwn) : !(canEditOthers || (canEditOwn && isOwner))}
              sx={{
                minWidth: '60px',
                '&.Mui-disabled': {
                  backgroundColor: 'grey.300',
                  color: 'grey.500'
                }
              }}
            >
              Ï†ÄÏû•
            </Button>
          </Box>
        </DialogTitle>

        <Box sx={{ borderBottom: 1, borderColor: 'divider', px: 2, backgroundColor: 'background.paper' }}>
          <Tabs value={editTab} onChange={handleTabChange}>
            <Tab label="Í∞úÏöî" />
            <Tab label="ÏÇ¨Ïö©ÏûêÏù¥Î†•" />
            <Tab label="Íµ¨Îß§/Ïú†ÏßÄÎ≥¥ÏàòÏù¥Î†•" />
            <Tab label="Í∏∞Î°ù" />
            <Tab label="ÏûêÎ£å" />
          </Tabs>
        </Box>

        <DialogContent sx={{ p: 0, overflow: 'hidden' }}>
          {editTab === 0 && <OverviewTab {...overviewTabProps} />}
          {editTab === 1 && <UserHistoryTab {...userHistoryTabProps} canEditOwn={canEditOwn && isOwner} canEditOthers={canEditOthers} />}
          {editTab === 2 && <PurchaseMaintenanceTab {...purchaseMaintenanceTabProps} canEditOwn={canEditOwn && isOwner} canEditOthers={canEditOthers} />}
          {editTab === 3 && <RecordTab {...recordTabProps} />}
          {editTab === 4 && <MaterialTab recordId={task?.id} currentUser={currentUser} canEditOwn={canEditOwn && isOwner} canEditOthers={canEditOthers} />}
        </DialogContent>

        {/* ÏóêÎü¨ Î©îÏãúÏßÄ ÌëúÏãú */}
        {validationError && (
          <Box sx={{ px: 2, pb: 2 }}>
            <Alert severity="error" sx={{ mt: 1 }}>
              {validationError}
            </Alert>
          </Box>
        )}
      </Dialog>
    );
  }
);

SoftwareEditDialog.displayName = 'SoftwareEditDialog';

export default SoftwareEditDialog;
