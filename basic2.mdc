# 고급 테이블 기반 관리 페이지 설계 가이드 (Basic2)

## 📋 개요
교육실적 탭에서 구현된 우수한 패턴을 기반으로 한 종합적인 설계 가이드입니다. 인라인 편집, 파일 관리, 데이터 검증, 상태 관리 등의 고급 기능을 포함합니다.

---

## 🏗️ 1. 전체 아키텍처 패턴

### 1.1 컴포넌트 계층 구조
```
MainComponent (EducationManagement)
├── MainCard (레이아웃 래퍼)
│   ├── 헤더 필터 영역
│   ├── Tabs 네비게이션
│   └── TabContent
│       └── DataTable (EducationRecordsTable)
│           ├── 액션 버튼 영역
│           ├── TableContainer
│           ├── Pagination
│           └── AttachmentDialog
```

### 1.2 상태 관리 패턴
```typescript
// 메인 상태
const [records, setRecords] = useState<DataRecord[]>([]);
const [selectedRecords, setSelectedRecords] = useState<number[]>([]);

// UI 상태
const [editingCell, setEditingCell] = useState<{rowId: number, field: string} | null>(null);
const [page, setPage] = useState(0);
const [rowsPerPage, setRowsPerPage] = useState(10);
const [goToPage, setGoToPage] = useState('');

// 모달 상태
const [attachmentDialog, setAttachmentDialog] = useState<{open: boolean, recordId: number | null}>({
  open: false,
  recordId: null
});
```

---

## 🎨 2. 디자인 시스템 및 스타일링

### 2.1 색상 체계

#### 상태별 파스텔 색상 (Status Colors)
```typescript
const getStatusPastelColor = (status: string) => {
  const colors: Record<string, any> = {
    '예정': { bgcolor: '#fff8e1', color: '#f57f17' },    // 연한 노란색
    '진행': { bgcolor: '#fff3e0', color: '#f57c00' },    // 연한 주황색
    '완료': { bgcolor: '#e8f5e8', color: '#388e3c' },    // 연한 초록색
    '취소': { bgcolor: '#ffebee', color: '#d32f2f' }     // 연한 빨간색
  };
  return colors[status] || { bgcolor: '#f5f5f5', color: '#666' };
};
```

#### 필수 입력 필드 스타일
```typescript
const requiredFieldStyle = {
  border: '1px dashed #d32f2f',           // 빨간색 점선 테두리
  borderColor: '#d32f2f',
  backgroundColor: '#ffebee',              // 연한 빨간색 배경
  color: '#d32f2f',                       // 빨간색 텍스트
  fontStyle: 'italic'                     // 이탤릭체
};
```

#### 테이블 헤더 스타일
```typescript
const tableHeaderStyle = {
  backgroundColor: 'grey.50',              // 연한 회색 배경
  fontWeight: 600,                        // 굵은 폰트
  py: 2                                   // 수직 패딩
};
```

### 2.2 컬럼 너비 최적화
```typescript
const columnWidths = {
  checkbox: 50,        // 체크박스
  no: 60,             // 순번
  date: 100,          // 날짜 (YYYY-MM-DD)
  code: 110,          // 코드 (EDU-24-001)
  team: 80,           // 팀명
  department: 70,     // 부서명
  assignee: 120,      // 담당자 (아바타 + 이름)
  category: 90,       // 카테고리
  content: 250,       // 내용 (메인 컬럼)
  status: 80,         // 상태
  attachment: 70      // 첨부파일
};
```

---

## ⚙️ 3. 핵심 기능 구현 패턴

### 3.1 인라인 편집 시스템

#### 편집 상태 관리
```typescript
interface EditingCell {
  rowId: number;
  field: string;
}

const [editingCell, setEditingCell] = useState<EditingCell | null>(null);

const handleCellClick = (rowId: number, field: string) => {
  // 편집 불가 필드 제외
  if (field !== 'registrationDate' && field !== 'code') {
    setEditingCell({ rowId, field });
  }
};

const handleCellBlur = () => {
  setEditingCell(null);
};
```

#### 렌더링 패턴
```typescript
const renderEditableCell = (record: DataRecord, field: string, value: any) => {
  const isEditing = editingCell?.rowId === record.id && editingCell?.field === field;
  const isRequiredField = ['assignee', 'content', 'completionDate'].includes(field);
  const isRequiredEmpty = isRequiredField && record.isNew && !value;

  // 편집 모드
  if (isEditing) {
    return renderEditComponent(field, value, record);
  }

  // 읽기 모드
  return renderDisplayComponent(field, value, record, isRequiredEmpty);
};
```

### 3.2 필드별 편집 컴포넌트

#### Select 드롭다운
```typescript
// 상태/카테고리 필드
if (field === 'educationType' || field === 'status') {
  const options = field === 'educationType' ? educationTypeOptions : statusOptions;
  
  return (
    <Select
      value={value}
      onChange={(e) => handleCellEdit(record.id, field, e.target.value)}
      onBlur={handleCellBlur}
      size="small"
      autoFocus
      sx={{ minWidth: 100 }}
    >
      {options.map(option => (
        <MenuItem key={option} value={option}>{option}</MenuItem>
      ))}
    </Select>
  );
}
```

#### 담당자 선택 (아바타 포함)
```typescript
if (field === 'assignee') {
  return (
    <Select
      value={value}
      onChange={(e) => handleCellEdit(record.id, field, e.target.value)}
      renderValue={(selected) => {
        const assignee = assigneeList.find(a => a.name === selected);
        return assignee ? (
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
            <Avatar sx={{ width: 24, height: 24, bgcolor: 'primary.main' }}>
              {assignee.name.charAt(0)}
            </Avatar>
            <Typography variant="body2">{assignee.name}</Typography>
          </Box>
        ) : selected;
      }}
    >
      {assigneeList.map(assignee => (
        <MenuItem key={assignee.id} value={assignee.name}>
          <ListItemAvatar>
            <Avatar sx={{ width: 32, height: 32, bgcolor: 'primary.main' }}>
              {assignee.name.charAt(0)}
            </Avatar>
          </ListItemAvatar>
          <ListItemText primary={assignee.name} secondary={assignee.team} />
        </MenuItem>
      ))}
    </Select>
  );
}
```

### 3.3 데이터 검증 시스템

#### 필수 필드 검증
```typescript
const validateRequiredFields = (record: DataRecord): boolean => {
  return !!(record.assignee && record.content && record.completionDate);
};

// 새 행 추가 시 검증
const handleAddRecord = () => {
  const newRecord: DataRecord = {
    id: generateId(),
    registrationDate: generateRegistrationDate(),
    code: generateCode(),
    assignee: '',
    content: '',
    completionDate: '',
    isNew: true  // 새 행 표시
  };
  setRecords(prev => [newRecord, ...prev]);
};

// 삭제 시 불완전한 행 체크
const handleDeleteRecords = () => {
  const incompleteNewRecords = records.filter(record => 
    selectedRecords.includes(record.id) && record.isNew && !validateRequiredFields(record)
  );
  
  if (incompleteNewRecords.length > 0) {
    alert('필수값이 입력되지 않은 새 행이 포함되어 있습니다.');
    return;
  }
  
  setRecords(prev => prev.filter(record => !selectedRecords.includes(record.id)));
  setSelectedRecords([]);
};
```

---

## 📁 4. 파일 관리 시스템

### 4.1 첨부파일 인터페이스
```typescript
interface AttachmentFile {
  id: number;
  name: string;
  type: string;
  size: string;
  file?: File;
  uploadDate: string;
}
```

### 4.2 파일 업로드 처리
```typescript
const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
  const files = event.target.files;
  if (!files || files.length === 0 || !attachmentDialog.recordId) return;

  const newAttachments = Array.from(files).map(file => ({
    id: Date.now() + Math.random(),
    name: file.name,
    type: file.type || 'application/octet-stream',
    size: formatFileSize(file.size),
    file: file,
    uploadDate: new Date().toISOString().split('T')[0]
  }));

  setRecords(prev => prev.map(record => {
    if (record.id === attachmentDialog.recordId) {
      const updatedAttachments = [...record.attachments, ...newAttachments];
      return {
        ...record,
        attachments: updatedAttachments,
        attachmentCount: updatedAttachments.length,
        attachment: updatedAttachments.length > 0
      };
    }
    return record;
  }));
};
```

### 4.3 파일 아이콘 시스템
```typescript
const getFileIcon = (type: string): string => {
  if (type.includes('pdf')) return '📄';
  if (type.includes('image')) return '🖼️';
  if (type.includes('video')) return '🎥';
  if (type.includes('audio')) return '🎵';
  if (type.includes('zip') || type.includes('rar')) return '📦';
  if (type.includes('word')) return '📝';
  if (type.includes('excel') || type.includes('spreadsheet')) return '📊';
  if (type.includes('powerpoint') || type.includes('presentation')) return '📈';
  return '📁';
};
```

---

## 🔍 5. 페이지네이션 및 필터링

### 5.1 고급 페이지네이션
```typescript
// 페이지네이션 상태
const [page, setPage] = useState(0);
const [rowsPerPage, setRowsPerPage] = useState(10);
const [goToPage, setGoToPage] = useState('');

// 계산된 값들
const totalPages = Math.ceil(filteredRecords.length / rowsPerPage);
const paginatedRecords = useMemo(() => {
  const startIndex = page * rowsPerPage;
  return filteredRecords.slice(startIndex, startIndex + rowsPerPage);
}, [filteredRecords, page, rowsPerPage]);

// Go to 기능
const handleGoToPage = () => {
  const targetPage = parseInt(goToPage) - 1;
  if (targetPage >= 0 && targetPage < totalPages) {
    setPage(targetPage);
  }
  setGoToPage('');
};
```

### 5.2 다중 필터 시스템
```typescript
// 필터 상태
const [selectedDepartment, setSelectedDepartment] = useState('ALL');
const [selectedYear, setSelectedYear] = useState('전체');
const [selectedAssignee, setSelectedAssignee] = useState('전체');

// 필터링 로직
const filteredRecords = useMemo(() => {
  return records.filter(record => {
    // 부서 필터
    if (department !== 'ALL' && record.department !== department) return false;
    
    // 연도 필터
    if (selectedYear !== '전체') {
      const recordYear = new Date(record.registrationDate).getFullYear().toString();
      if (recordYear !== selectedYear) return false;
    }
    
    // 담당자 필터
    if (selectedAssignee !== '전체' && record.assignee !== selectedAssignee) return false;
    
    return true;
  });
}, [records, department, selectedYear, selectedAssignee]);
```

---

## 🎯 6. 액션 버튼 및 상호작용

### 6.1 액션 버튼 레이아웃
```typescript
<Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 2, gap: 1 }}>
  <Button
    variant="contained"
    startIcon={<Add size={16} />}
    size="small"
    onClick={handleAddRecord}
    sx={{ px: 2 }}
  >
    추가
  </Button>
  <Button
    variant="outlined"
    startIcon={<Minus size={16} />}
    size="small"
    color="error"
    disabled={selectedRecords.length === 0}
    onClick={handleDeleteRecords}
    sx={{ 
      px: 2,
      borderColor: selectedRecords.length > 0 ? 'error.main' : 'grey.300',
      color: selectedRecords.length > 0 ? 'error.main' : 'grey.500'
    }}
  >
    삭제 {selectedRecords.length > 0 && `(${selectedRecords.length})`}
  </Button>
</Box>
```

### 6.2 체크박스 선택 시스템
```typescript
// 전체 선택
const handleSelectAll = (event: React.ChangeEvent<HTMLInputElement>) => {
  if (event.target.checked) {
    setSelectedRecords(paginatedRecords.map(record => record.id));
  } else {
    setSelectedRecords([]);
  }
};

// 개별 선택
const handleSelectRecord = (recordId: number) => {
  setSelectedRecords(prev => 
    prev.includes(recordId)
      ? prev.filter(id => id !== recordId)
      : [...prev, recordId]
  );
};
```

---

## 📱 7. 반응형 디자인 고려사항

### 7.1 테이블 반응형 처리
```typescript
<TableContainer 
  component={Paper} 
  variant="outlined" 
  sx={{ 
    borderRadius: 2,
    overflowX: 'auto',
    '& .MuiTable-root': {
      minWidth: 1200  // 최소 너비 보장
    }
  }}
>
```

### 7.2 모바일 대응 패턴
```typescript
// 헤더 필터 영역
<Box sx={{ 
  display: 'flex', 
  gap: 2, 
  alignItems: 'center', 
  flexWrap: 'wrap',  // 모바일에서 줄바꿈
  '& > *': {
    minWidth: 'max-content'  // 최소 너비 보장
  }
}}>
```

---

## 🛠️ 8. 유틸리티 함수 모음

### 8.1 ID 생성 함수
```typescript
const generateCode = () => {
  const year = new Date().getFullYear().toString().slice(-2);
  const maxId = Math.max(...records.map(r => r.id), 0);
  const nextNumber = (maxId + 1).toString().padStart(3, '0');
  return `EDU-${year}-${nextNumber}`;
};

const generateRegistrationDate = () => {
  return new Date().toISOString().split('T')[0];
};
```

### 8.2 파일 크기 포맷팅
```typescript
const formatFileSize = (bytes: number): string => {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
};
```

---

## 📋 9. 구현 체크리스트

### 9.1 기본 구조
- [ ] MainCard 레이아웃 설정
- [ ] Tabs 네비게이션 구현
- [ ] 필터 영역 구성
- [ ] 테이블 기본 구조

### 9.2 데이터 관리
- [ ] 인터페이스 정의 (Record, Attachment 등)
- [ ] 상태 관리 설정
- [ ] CRUD 기능 구현
- [ ] 데이터 검증 로직

### 9.3 인라인 편집
- [ ] 편집 상태 관리
- [ ] 필드별 편집 컴포넌트
- [ ] 편집 모드 전환
- [ ] 데이터 업데이트 처리

### 9.4 파일 관리
- [ ] 파일 업로드 기능
- [ ] 첨부파일 다이얼로그
- [ ] 파일 목록 표시
- [ ] 다운로드/삭제 기능

### 9.5 UI/UX
- [ ] 색상 시스템 적용
- [ ] 상태별 시각적 피드백
- [ ] 필수 입력 표시
- [ ] 반응형 디자인

### 9.6 페이지네이션
- [ ] 기본 페이지네이션
- [ ] Row per page 설정
- [ ] Go to 기능
- [ ] 상태 표시

---

## 🔧 10. 커스터마이징 가이드

### 10.1 새로운 필드 추가
1. 인터페이스에 필드 추가
2. `renderEditableCell`에 렌더링 로직 추가
3. 테이블 헤더/바디에 컬럼 추가
4. 필요시 검증 로직 추가

### 10.2 새로운 상태 추가
1. 상태 옵션 배열에 추가
2. 색상 매핑 함수에 추가
3. 필요시 비즈니스 로직 업데이트

### 10.3 새로운 액션 추가
1. 액션 버튼 영역에 버튼 추가
2. 핸들러 함수 구현
3. 권한/상태 체크 로직 추가

---

## 📚 11. 참고 자료

### 11.1 관련 라이브러리
- **Material-UI**: 테이블, 폼 컴포넌트
- **@wandersonalwes/iconsax-react**: 아이콘 시스템
- **React Hooks**: 상태 관리 및 사이드 이펙트

### 11.2 핵심 패턴
- **인라인 편집**: 클릭-투-에디트 패턴
- **상태 관리**: useState + useMemo 조합
- **컴포넌트 분리**: 기능별 컴포넌트 분리
- **타입 안정성**: TypeScript 인터페이스 활용

---

## 💡 12. 베스트 프랙티스

### 12.1 성능 최적화
- `useMemo`를 활용한 계산 최적화
- 컴포넌트 분리로 리렌더링 최소화
- 페이지네이션으로 대용량 데이터 처리

### 12.2 사용자 경험
- 즉시 피드백 (호버, 포커스 효과)
- 명확한 상태 표시 (필수 입력, 에러 상태)
- 직관적인 인터랙션 (클릭-투-에디트)

### 12.3 유지보수성
- 명확한 인터페이스 정의
- 재사용 가능한 유틸리티 함수
- 일관된 코딩 스타일
- 충분한 주석과 문서화

---

*이 가이드는 교육실적 관리 시스템의 우수한 패턴을 기반으로 작성되었으며, 유사한 관리 페이지 개발 시 참고 자료로 활용할 수 있습니다.*
description:
globs:
alwaysApply: false
---
